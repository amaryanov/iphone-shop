/* soapC.cpp
   Generated by gSOAP 2.7.11 from ../AmazonWebServices.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.11 2008-07-31 07:50:19 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest:
		return soap_in_ns1__ModifyShoppingCartItemsRequest(soap, NULL, NULL, "ns1:ModifyShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest:
		return soap_in_ns1__RemoveShoppingCartItemsRequest(soap, NULL, NULL, "ns1:RemoveShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest:
		return soap_in_ns1__AddShoppingCartItemsRequest(soap, NULL, NULL, "ns1:AddShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__ClearShoppingCartRequest:
		return soap_in_ns1__ClearShoppingCartRequest(soap, NULL, NULL, "ns1:ClearShoppingCartRequest");
	case SOAP_TYPE_ns1__GetShoppingCartRequest:
		return soap_in_ns1__GetShoppingCartRequest(soap, NULL, NULL, "ns1:GetShoppingCartRequest");
	case SOAP_TYPE_ns1__ShoppingCart:
		return soap_in_ns1__ShoppingCart(soap, NULL, NULL, "ns1:ShoppingCart");
	case SOAP_TYPE_ns1__AddItem:
		return soap_in_ns1__AddItem(soap, NULL, NULL, "ns1:AddItem");
	case SOAP_TYPE_AddItemArray:
		return soap_in_AddItemArray(soap, NULL, NULL, "ns1:AddItem");
	case SOAP_TYPE_ns1__ItemQuantity:
		return soap_in_ns1__ItemQuantity(soap, NULL, NULL, "ns1:ItemQuantity");
	case SOAP_TYPE_ItemQuantityArray:
		return soap_in_ItemQuantityArray(soap, NULL, NULL, "ns1:ItemQuantity");
	case SOAP_TYPE_ns1__Item:
		return soap_in_ns1__Item(soap, NULL, NULL, "ns1:Item");
	case SOAP_TYPE_ItemArray:
		return soap_in_ItemArray(soap, NULL, NULL, "ns1:Item");
	case SOAP_TYPE_ItemIdArray:
		return soap_in_ItemIdArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__SimilarityRequest:
		return soap_in_ns1__SimilarityRequest(soap, NULL, NULL, "ns1:SimilarityRequest");
	case SOAP_TYPE_ns1__SellerRequest:
		return soap_in_ns1__SellerRequest(soap, NULL, NULL, "ns1:SellerRequest");
	case SOAP_TYPE_ns1__SellerProfileRequest:
		return soap_in_ns1__SellerProfileRequest(soap, NULL, NULL, "ns1:SellerProfileRequest");
	case SOAP_TYPE_ns1__MarketplaceRequest:
		return soap_in_ns1__MarketplaceRequest(soap, NULL, NULL, "ns1:MarketplaceRequest");
	case SOAP_TYPE_ns1__WishlistRequest:
		return soap_in_ns1__WishlistRequest(soap, NULL, NULL, "ns1:WishlistRequest");
	case SOAP_TYPE_ns1__ListManiaRequest:
		return soap_in_ns1__ListManiaRequest(soap, NULL, NULL, "ns1:ListManiaRequest");
	case SOAP_TYPE_ns1__ManufacturerRequest:
		return soap_in_ns1__ManufacturerRequest(soap, NULL, NULL, "ns1:ManufacturerRequest");
	case SOAP_TYPE_ns1__ExchangeRequest:
		return soap_in_ns1__ExchangeRequest(soap, NULL, NULL, "ns1:ExchangeRequest");
	case SOAP_TYPE_ns1__DirectorRequest:
		return soap_in_ns1__DirectorRequest(soap, NULL, NULL, "ns1:DirectorRequest");
	case SOAP_TYPE_ns1__ActorRequest:
		return soap_in_ns1__ActorRequest(soap, NULL, NULL, "ns1:ActorRequest");
	case SOAP_TYPE_ns1__AuthorRequest:
		return soap_in_ns1__AuthorRequest(soap, NULL, NULL, "ns1:AuthorRequest");
	case SOAP_TYPE_ns1__ArtistRequest:
		return soap_in_ns1__ArtistRequest(soap, NULL, NULL, "ns1:ArtistRequest");
	case SOAP_TYPE_ns1__UpcRequest:
		return soap_in_ns1__UpcRequest(soap, NULL, NULL, "ns1:UpcRequest");
	case SOAP_TYPE_ns1__BlendedRequest:
		return soap_in_ns1__BlendedRequest(soap, NULL, NULL, "ns1:BlendedRequest");
	case SOAP_TYPE_ns1__AsinRequest:
		return soap_in_ns1__AsinRequest(soap, NULL, NULL, "ns1:AsinRequest");
	case SOAP_TYPE_ns1__BrowseNodeRequest:
		return soap_in_ns1__BrowseNodeRequest(soap, NULL, NULL, "ns1:BrowseNodeRequest");
	case SOAP_TYPE_ns1__PowerRequest:
		return soap_in_ns1__PowerRequest(soap, NULL, NULL, "ns1:PowerRequest");
	case SOAP_TYPE_ns1__KeywordRequest:
		return soap_in_ns1__KeywordRequest(soap, NULL, NULL, "ns1:KeywordRequest");
	case SOAP_TYPE_ns1__ThirdPartyProductDetails:
		return soap_in_ns1__ThirdPartyProductDetails(soap, NULL, NULL, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_ThirdPartyProductDetailsArray:
		return soap_in_ThirdPartyProductDetailsArray(soap, NULL, NULL, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_ns1__ThirdPartyProductInfo:
		return soap_in_ns1__ThirdPartyProductInfo(soap, NULL, NULL, "ns1:ThirdPartyProductInfo");
	case SOAP_TYPE_ns1__Feedback:
		return soap_in_ns1__Feedback(soap, NULL, NULL, "ns1:Feedback");
	case SOAP_TYPE_FeedbackArray:
		return soap_in_FeedbackArray(soap, NULL, NULL, "ns1:Feedback");
	case SOAP_TYPE_ns1__SellerFeedback:
		return soap_in_ns1__SellerFeedback(soap, NULL, NULL, "ns1:SellerFeedback");
	case SOAP_TYPE_ns1__ListingProductDetails:
		return soap_in_ns1__ListingProductDetails(soap, NULL, NULL, "ns1:ListingProductDetails");
	case SOAP_TYPE_ListingProductDetailsArray:
		return soap_in_ListingProductDetailsArray(soap, NULL, NULL, "ns1:ListingProductDetails");
	case SOAP_TYPE_ns1__ListingProductInfo:
		return soap_in_ns1__ListingProductInfo(soap, NULL, NULL, "ns1:ListingProductInfo");
	case SOAP_TYPE_SellerSearchDetailsArray:
		return soap_in_SellerSearchDetailsArray(soap, NULL, NULL, "ns1:SellerSearchDetails");
	case SOAP_TYPE_ns1__SellerSearchDetails:
		return soap_in_ns1__SellerSearchDetails(soap, NULL, NULL, "ns1:SellerSearchDetails");
	case SOAP_TYPE_SellerProfileDetailsArray:
		return soap_in_SellerProfileDetailsArray(soap, NULL, NULL, "ns1:SellerProfileDetails");
	case SOAP_TYPE_ns1__SellerProfileDetails:
		return soap_in_ns1__SellerProfileDetails(soap, NULL, NULL, "ns1:SellerProfileDetails");
	case SOAP_TYPE_MarketplaceSearchDetailsArray:
		return soap_in_MarketplaceSearchDetailsArray(soap, NULL, NULL, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_ns1__MarketplaceSearchDetails:
		return soap_in_ns1__MarketplaceSearchDetails(soap, NULL, NULL, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_ns1__SellerSearch:
		return soap_in_ns1__SellerSearch(soap, NULL, NULL, "ns1:SellerSearch");
	case SOAP_TYPE_ns1__SellerProfile:
		return soap_in_ns1__SellerProfile(soap, NULL, NULL, "ns1:SellerProfile");
	case SOAP_TYPE_ns1__MarketplaceSearch:
		return soap_in_ns1__MarketplaceSearch(soap, NULL, NULL, "ns1:MarketplaceSearch");
	case SOAP_TYPE_ListArray:
		return soap_in_ListArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_SimilarProductsArray:
		return soap_in_SimilarProductsArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__CustomerReview:
		return soap_in_ns1__CustomerReview(soap, NULL, NULL, "ns1:CustomerReview");
	case SOAP_TYPE_CustomerReviewArray:
		return soap_in_CustomerReviewArray(soap, NULL, NULL, "ns1:CustomerReview");
	case SOAP_TYPE_ns1__Reviews:
		return soap_in_ns1__Reviews(soap, NULL, NULL, "ns1:Reviews");
	case SOAP_TYPE_PlatformArray:
		return soap_in_PlatformArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_AccessoryArray:
		return soap_in_AccessoryArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__Track:
		return soap_in_ns1__Track(soap, NULL, NULL, "ns1:Track");
	case SOAP_TYPE_TrackArray:
		return soap_in_TrackArray(soap, NULL, NULL, "ns1:Track");
	case SOAP_TYPE_FeaturesArray:
		return soap_in_FeaturesArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__BrowseNode:
		return soap_in_ns1__BrowseNode(soap, NULL, NULL, "ns1:BrowseNode");
	case SOAP_TYPE_BrowseNodeArray:
		return soap_in_BrowseNodeArray(soap, NULL, NULL, "ns1:BrowseNode");
	case SOAP_TYPE_DirectorArray:
		return soap_in_DirectorArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_StarringArray:
		return soap_in_StarringArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_AuthorArray:
		return soap_in_AuthorArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ArtistArray:
		return soap_in_ArtistArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__KeyPhrase:
		return soap_in_ns1__KeyPhrase(soap, NULL, NULL, "ns1:KeyPhrase");
	case SOAP_TYPE_KeyPhraseArray:
		return soap_in_KeyPhraseArray(soap, NULL, NULL, "ns1:KeyPhrase");
	case SOAP_TYPE_ns1__Details:
		return soap_in_ns1__Details(soap, NULL, NULL, "ns1:Details");
	case SOAP_TYPE_DetailsArray:
		return soap_in_DetailsArray(soap, NULL, NULL, "ns1:Details");
	case SOAP_TYPE_ns1__ProductInfo:
		return soap_in_ns1__ProductInfo(soap, NULL, NULL, "ns1:ProductInfo");
	case SOAP_TYPE_ns1__ProductLine:
		return soap_in_ns1__ProductLine(soap, NULL, NULL, "ns1:ProductLine");
	case SOAP_TYPE_ProductLineArray:
		return soap_in_ProductLineArray(soap, NULL, NULL, "ns1:ProductLine");
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_:
		return soap_in_ns1__ModifyShoppingCartItemsRequest_(soap, NULL, NULL, "ns1:ModifyShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse:
		return soap_in_ns1__ModifyShoppingCartItemsRequestResponse(soap, NULL, NULL, "ns1:ModifyShoppingCartItemsRequestResponse");
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_:
		return soap_in_ns1__RemoveShoppingCartItemsRequest_(soap, NULL, NULL, "ns1:RemoveShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse:
		return soap_in_ns1__RemoveShoppingCartItemsRequestResponse(soap, NULL, NULL, "ns1:RemoveShoppingCartItemsRequestResponse");
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest_:
		return soap_in_ns1__AddShoppingCartItemsRequest_(soap, NULL, NULL, "ns1:AddShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse:
		return soap_in_ns1__AddShoppingCartItemsRequestResponse(soap, NULL, NULL, "ns1:AddShoppingCartItemsRequestResponse");
	case SOAP_TYPE_ns1__ClearShoppingCartRequest_:
		return soap_in_ns1__ClearShoppingCartRequest_(soap, NULL, NULL, "ns1:ClearShoppingCartRequest");
	case SOAP_TYPE_ns1__ClearShoppingCartRequestResponse:
		return soap_in_ns1__ClearShoppingCartRequestResponse(soap, NULL, NULL, "ns1:ClearShoppingCartRequestResponse");
	case SOAP_TYPE_ns1__GetShoppingCartRequest_:
		return soap_in_ns1__GetShoppingCartRequest_(soap, NULL, NULL, "ns1:GetShoppingCartRequest");
	case SOAP_TYPE_ns1__GetShoppingCartRequestResponse:
		return soap_in_ns1__GetShoppingCartRequestResponse(soap, NULL, NULL, "ns1:GetShoppingCartRequestResponse");
	case SOAP_TYPE_ns1__SimilaritySearchRequest:
		return soap_in_ns1__SimilaritySearchRequest(soap, NULL, NULL, "ns1:SimilaritySearchRequest");
	case SOAP_TYPE_ns1__SimilaritySearchRequestResponse:
		return soap_in_ns1__SimilaritySearchRequestResponse(soap, NULL, NULL, "ns1:SimilaritySearchRequestResponse");
	case SOAP_TYPE_ns1__MarketplaceSearchRequest:
		return soap_in_ns1__MarketplaceSearchRequest(soap, NULL, NULL, "ns1:MarketplaceSearchRequest");
	case SOAP_TYPE_ns1__MarketplaceSearchRequestResponse:
		return soap_in_ns1__MarketplaceSearchRequestResponse(soap, NULL, NULL, "ns1:MarketplaceSearchRequestResponse");
	case SOAP_TYPE_ns1__SellerSearchRequest:
		return soap_in_ns1__SellerSearchRequest(soap, NULL, NULL, "ns1:SellerSearchRequest");
	case SOAP_TYPE_ns1__SellerSearchRequestResponse:
		return soap_in_ns1__SellerSearchRequestResponse(soap, NULL, NULL, "ns1:SellerSearchRequestResponse");
	case SOAP_TYPE_ns1__SellerProfileSearchRequest:
		return soap_in_ns1__SellerProfileSearchRequest(soap, NULL, NULL, "ns1:SellerProfileSearchRequest");
	case SOAP_TYPE_ns1__SellerProfileSearchRequestResponse:
		return soap_in_ns1__SellerProfileSearchRequestResponse(soap, NULL, NULL, "ns1:SellerProfileSearchRequestResponse");
	case SOAP_TYPE_ns1__WishlistSearchRequest:
		return soap_in_ns1__WishlistSearchRequest(soap, NULL, NULL, "ns1:WishlistSearchRequest");
	case SOAP_TYPE_ns1__WishlistSearchRequestResponse:
		return soap_in_ns1__WishlistSearchRequestResponse(soap, NULL, NULL, "ns1:WishlistSearchRequestResponse");
	case SOAP_TYPE_ns1__ListManiaSearchRequest:
		return soap_in_ns1__ListManiaSearchRequest(soap, NULL, NULL, "ns1:ListManiaSearchRequest");
	case SOAP_TYPE_ns1__ListManiaSearchRequestResponse:
		return soap_in_ns1__ListManiaSearchRequestResponse(soap, NULL, NULL, "ns1:ListManiaSearchRequestResponse");
	case SOAP_TYPE_ns1__ExchangeSearchRequest:
		return soap_in_ns1__ExchangeSearchRequest(soap, NULL, NULL, "ns1:ExchangeSearchRequest");
	case SOAP_TYPE_ns1__ExchangeSearchRequestResponse:
		return soap_in_ns1__ExchangeSearchRequestResponse(soap, NULL, NULL, "ns1:ExchangeSearchRequestResponse");
	case SOAP_TYPE_ns1__DirectorSearchRequest:
		return soap_in_ns1__DirectorSearchRequest(soap, NULL, NULL, "ns1:DirectorSearchRequest");
	case SOAP_TYPE_ns1__DirectorSearchRequestResponse:
		return soap_in_ns1__DirectorSearchRequestResponse(soap, NULL, NULL, "ns1:DirectorSearchRequestResponse");
	case SOAP_TYPE_ns1__ManufacturerSearchRequest:
		return soap_in_ns1__ManufacturerSearchRequest(soap, NULL, NULL, "ns1:ManufacturerSearchRequest");
	case SOAP_TYPE_ns1__ManufacturerSearchRequestResponse:
		return soap_in_ns1__ManufacturerSearchRequestResponse(soap, NULL, NULL, "ns1:ManufacturerSearchRequestResponse");
	case SOAP_TYPE_ns1__ActorSearchRequest:
		return soap_in_ns1__ActorSearchRequest(soap, NULL, NULL, "ns1:ActorSearchRequest");
	case SOAP_TYPE_ns1__ActorSearchRequestResponse:
		return soap_in_ns1__ActorSearchRequestResponse(soap, NULL, NULL, "ns1:ActorSearchRequestResponse");
	case SOAP_TYPE_ns1__ArtistSearchRequest:
		return soap_in_ns1__ArtistSearchRequest(soap, NULL, NULL, "ns1:ArtistSearchRequest");
	case SOAP_TYPE_ns1__ArtistSearchRequestResponse:
		return soap_in_ns1__ArtistSearchRequestResponse(soap, NULL, NULL, "ns1:ArtistSearchRequestResponse");
	case SOAP_TYPE_ns1__AuthorSearchRequest:
		return soap_in_ns1__AuthorSearchRequest(soap, NULL, NULL, "ns1:AuthorSearchRequest");
	case SOAP_TYPE_ns1__AuthorSearchRequestResponse:
		return soap_in_ns1__AuthorSearchRequestResponse(soap, NULL, NULL, "ns1:AuthorSearchRequestResponse");
	case SOAP_TYPE_ns1__UpcSearchRequest:
		return soap_in_ns1__UpcSearchRequest(soap, NULL, NULL, "ns1:UpcSearchRequest");
	case SOAP_TYPE_ns1__UpcSearchRequestResponse:
		return soap_in_ns1__UpcSearchRequestResponse(soap, NULL, NULL, "ns1:UpcSearchRequestResponse");
	case SOAP_TYPE_ns1__BlendedSearchRequest:
		return soap_in_ns1__BlendedSearchRequest(soap, NULL, NULL, "ns1:BlendedSearchRequest");
	case SOAP_TYPE_ns1__BlendedSearchRequestResponse:
		return soap_in_ns1__BlendedSearchRequestResponse(soap, NULL, NULL, "ns1:BlendedSearchRequestResponse");
	case SOAP_TYPE_ns1__AsinSearchRequest:
		return soap_in_ns1__AsinSearchRequest(soap, NULL, NULL, "ns1:AsinSearchRequest");
	case SOAP_TYPE_ns1__AsinSearchRequestResponse:
		return soap_in_ns1__AsinSearchRequestResponse(soap, NULL, NULL, "ns1:AsinSearchRequestResponse");
	case SOAP_TYPE_ns1__BrowseNodeSearchRequest:
		return soap_in_ns1__BrowseNodeSearchRequest(soap, NULL, NULL, "ns1:BrowseNodeSearchRequest");
	case SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse:
		return soap_in_ns1__BrowseNodeSearchRequestResponse(soap, NULL, NULL, "ns1:BrowseNodeSearchRequestResponse");
	case SOAP_TYPE_ns1__PowerSearchRequest:
		return soap_in_ns1__PowerSearchRequest(soap, NULL, NULL, "ns1:PowerSearchRequest");
	case SOAP_TYPE_ns1__PowerSearchRequestResponse:
		return soap_in_ns1__PowerSearchRequestResponse(soap, NULL, NULL, "ns1:PowerSearchRequestResponse");
	case SOAP_TYPE_ns1__KeywordSearchRequest:
		return soap_in_ns1__KeywordSearchRequest(soap, NULL, NULL, "ns1:KeywordSearchRequest");
	case SOAP_TYPE_ns1__KeywordSearchRequestResponse:
		return soap_in_ns1__KeywordSearchRequestResponse(soap, NULL, NULL, "ns1:KeywordSearchRequestResponse");
	case SOAP_TYPE_PointerTons1__ModifyShoppingCartItemsRequest:
		return soap_in_PointerTons1__ModifyShoppingCartItemsRequest(soap, NULL, NULL, "ns1:ModifyShoppingCartItemsRequest");
	case SOAP_TYPE_PointerTons1__RemoveShoppingCartItemsRequest:
		return soap_in_PointerTons1__RemoveShoppingCartItemsRequest(soap, NULL, NULL, "ns1:RemoveShoppingCartItemsRequest");
	case SOAP_TYPE_PointerTons1__AddShoppingCartItemsRequest:
		return soap_in_PointerTons1__AddShoppingCartItemsRequest(soap, NULL, NULL, "ns1:AddShoppingCartItemsRequest");
	case SOAP_TYPE_PointerTons1__ClearShoppingCartRequest:
		return soap_in_PointerTons1__ClearShoppingCartRequest(soap, NULL, NULL, "ns1:ClearShoppingCartRequest");
	case SOAP_TYPE_PointerTons1__GetShoppingCartRequest:
		return soap_in_PointerTons1__GetShoppingCartRequest(soap, NULL, NULL, "ns1:GetShoppingCartRequest");
	case SOAP_TYPE_PointerTons1__ShoppingCart:
		return soap_in_PointerTons1__ShoppingCart(soap, NULL, NULL, "ns1:ShoppingCart");
	case SOAP_TYPE_PointerTons1__SimilarityRequest:
		return soap_in_PointerTons1__SimilarityRequest(soap, NULL, NULL, "ns1:SimilarityRequest");
	case SOAP_TYPE_PointerTons1__MarketplaceRequest:
		return soap_in_PointerTons1__MarketplaceRequest(soap, NULL, NULL, "ns1:MarketplaceRequest");
	case SOAP_TYPE_PointerTons1__MarketplaceSearch:
		return soap_in_PointerTons1__MarketplaceSearch(soap, NULL, NULL, "ns1:MarketplaceSearch");
	case SOAP_TYPE_PointerTons1__SellerRequest:
		return soap_in_PointerTons1__SellerRequest(soap, NULL, NULL, "ns1:SellerRequest");
	case SOAP_TYPE_PointerTons1__SellerSearch:
		return soap_in_PointerTons1__SellerSearch(soap, NULL, NULL, "ns1:SellerSearch");
	case SOAP_TYPE_PointerTons1__SellerProfileRequest:
		return soap_in_PointerTons1__SellerProfileRequest(soap, NULL, NULL, "ns1:SellerProfileRequest");
	case SOAP_TYPE_PointerTons1__SellerProfile:
		return soap_in_PointerTons1__SellerProfile(soap, NULL, NULL, "ns1:SellerProfile");
	case SOAP_TYPE_PointerTons1__WishlistRequest:
		return soap_in_PointerTons1__WishlistRequest(soap, NULL, NULL, "ns1:WishlistRequest");
	case SOAP_TYPE_PointerTons1__ListManiaRequest:
		return soap_in_PointerTons1__ListManiaRequest(soap, NULL, NULL, "ns1:ListManiaRequest");
	case SOAP_TYPE_PointerTons1__ExchangeRequest:
		return soap_in_PointerTons1__ExchangeRequest(soap, NULL, NULL, "ns1:ExchangeRequest");
	case SOAP_TYPE_PointerTons1__DirectorRequest:
		return soap_in_PointerTons1__DirectorRequest(soap, NULL, NULL, "ns1:DirectorRequest");
	case SOAP_TYPE_PointerTons1__ManufacturerRequest:
		return soap_in_PointerTons1__ManufacturerRequest(soap, NULL, NULL, "ns1:ManufacturerRequest");
	case SOAP_TYPE_PointerTons1__ActorRequest:
		return soap_in_PointerTons1__ActorRequest(soap, NULL, NULL, "ns1:ActorRequest");
	case SOAP_TYPE_PointerTons1__ArtistRequest:
		return soap_in_PointerTons1__ArtistRequest(soap, NULL, NULL, "ns1:ArtistRequest");
	case SOAP_TYPE_PointerTons1__AuthorRequest:
		return soap_in_PointerTons1__AuthorRequest(soap, NULL, NULL, "ns1:AuthorRequest");
	case SOAP_TYPE_PointerTons1__UpcRequest:
		return soap_in_PointerTons1__UpcRequest(soap, NULL, NULL, "ns1:UpcRequest");
	case SOAP_TYPE_PointerTons1__BlendedRequest:
		return soap_in_PointerTons1__BlendedRequest(soap, NULL, NULL, "ns1:BlendedRequest");
	case SOAP_TYPE_PointerToProductLineArray:
		return soap_in_PointerToProductLineArray(soap, NULL, NULL, "ns1:ProductLine");
	case SOAP_TYPE_PointerTons1__AsinRequest:
		return soap_in_PointerTons1__AsinRequest(soap, NULL, NULL, "ns1:AsinRequest");
	case SOAP_TYPE_PointerTons1__BrowseNodeRequest:
		return soap_in_PointerTons1__BrowseNodeRequest(soap, NULL, NULL, "ns1:BrowseNodeRequest");
	case SOAP_TYPE_PointerTons1__PowerRequest:
		return soap_in_PointerTons1__PowerRequest(soap, NULL, NULL, "ns1:PowerRequest");
	case SOAP_TYPE_PointerTons1__KeywordRequest:
		return soap_in_PointerTons1__KeywordRequest(soap, NULL, NULL, "ns1:KeywordRequest");
	case SOAP_TYPE_PointerToPointerTons1__AddItem:
		return soap_in_PointerToPointerTons1__AddItem(soap, NULL, NULL, "ns1:AddItem");
	case SOAP_TYPE_PointerTons1__AddItem:
		return soap_in_PointerTons1__AddItem(soap, NULL, NULL, "ns1:AddItem");
	case SOAP_TYPE_PointerToPointerTons1__ItemQuantity:
		return soap_in_PointerToPointerTons1__ItemQuantity(soap, NULL, NULL, "ns1:ItemQuantity");
	case SOAP_TYPE_PointerTons1__ItemQuantity:
		return soap_in_PointerTons1__ItemQuantity(soap, NULL, NULL, "ns1:ItemQuantity");
	case SOAP_TYPE_PointerToPointerTons1__Item:
		return soap_in_PointerToPointerTons1__Item(soap, NULL, NULL, "ns1:Item");
	case SOAP_TYPE_PointerTons1__Item:
		return soap_in_PointerTons1__Item(soap, NULL, NULL, "ns1:Item");
	case SOAP_TYPE_PointerToPointerTons1__ThirdPartyProductDetails:
		return soap_in_PointerToPointerTons1__ThirdPartyProductDetails(soap, NULL, NULL, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_PointerTons1__ThirdPartyProductDetails:
		return soap_in_PointerTons1__ThirdPartyProductDetails(soap, NULL, NULL, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_PointerToPointerTons1__Feedback:
		return soap_in_PointerToPointerTons1__Feedback(soap, NULL, NULL, "ns1:Feedback");
	case SOAP_TYPE_PointerTons1__Feedback:
		return soap_in_PointerTons1__Feedback(soap, NULL, NULL, "ns1:Feedback");
	case SOAP_TYPE_PointerToPointerTons1__ListingProductDetails:
		return soap_in_PointerToPointerTons1__ListingProductDetails(soap, NULL, NULL, "ns1:ListingProductDetails");
	case SOAP_TYPE_PointerTons1__ListingProductDetails:
		return soap_in_PointerTons1__ListingProductDetails(soap, NULL, NULL, "ns1:ListingProductDetails");
	case SOAP_TYPE_PointerToPointerTons1__SellerSearchDetails:
		return soap_in_PointerToPointerTons1__SellerSearchDetails(soap, NULL, NULL, "ns1:SellerSearchDetails");
	case SOAP_TYPE_PointerTons1__SellerSearchDetails:
		return soap_in_PointerTons1__SellerSearchDetails(soap, NULL, NULL, "ns1:SellerSearchDetails");
	case SOAP_TYPE_PointerToPointerTons1__SellerProfileDetails:
		return soap_in_PointerToPointerTons1__SellerProfileDetails(soap, NULL, NULL, "ns1:SellerProfileDetails");
	case SOAP_TYPE_PointerTons1__SellerProfileDetails:
		return soap_in_PointerTons1__SellerProfileDetails(soap, NULL, NULL, "ns1:SellerProfileDetails");
	case SOAP_TYPE_PointerToPointerTons1__MarketplaceSearchDetails:
		return soap_in_PointerToPointerTons1__MarketplaceSearchDetails(soap, NULL, NULL, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_PointerTons1__MarketplaceSearchDetails:
		return soap_in_PointerTons1__MarketplaceSearchDetails(soap, NULL, NULL, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_PointerToPointerTons1__CustomerReview:
		return soap_in_PointerToPointerTons1__CustomerReview(soap, NULL, NULL, "ns1:CustomerReview");
	case SOAP_TYPE_PointerTons1__CustomerReview:
		return soap_in_PointerTons1__CustomerReview(soap, NULL, NULL, "ns1:CustomerReview");
	case SOAP_TYPE_PointerToPointerTons1__Track:
		return soap_in_PointerToPointerTons1__Track(soap, NULL, NULL, "ns1:Track");
	case SOAP_TYPE_PointerTons1__Track:
		return soap_in_PointerTons1__Track(soap, NULL, NULL, "ns1:Track");
	case SOAP_TYPE_PointerToPointerTons1__BrowseNode:
		return soap_in_PointerToPointerTons1__BrowseNode(soap, NULL, NULL, "ns1:BrowseNode");
	case SOAP_TYPE_PointerTons1__BrowseNode:
		return soap_in_PointerTons1__BrowseNode(soap, NULL, NULL, "ns1:BrowseNode");
	case SOAP_TYPE_PointerToPointerTons1__KeyPhrase:
		return soap_in_PointerToPointerTons1__KeyPhrase(soap, NULL, NULL, "ns1:KeyPhrase");
	case SOAP_TYPE_PointerTons1__KeyPhrase:
		return soap_in_PointerTons1__KeyPhrase(soap, NULL, NULL, "ns1:KeyPhrase");
	case SOAP_TYPE_PointerToPointerTons1__Details:
		return soap_in_PointerToPointerTons1__Details(soap, NULL, NULL, "ns1:Details");
	case SOAP_TYPE_PointerTons1__Details:
		return soap_in_PointerTons1__Details(soap, NULL, NULL, "ns1:Details");
	case SOAP_TYPE_PointerToPointerTons1__ProductLine:
		return soap_in_PointerToPointerTons1__ProductLine(soap, NULL, NULL, "ns1:ProductLine");
	case SOAP_TYPE_PointerTons1__ProductLine:
		return soap_in_PointerTons1__ProductLine(soap, NULL, NULL, "ns1:ProductLine");
	case SOAP_TYPE_PointerToItemQuantityArray:
		return soap_in_PointerToItemQuantityArray(soap, NULL, NULL, "ns1:ItemQuantity");
	case SOAP_TYPE_PointerToItemIdArray:
		return soap_in_PointerToItemIdArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToAddItemArray:
		return soap_in_PointerToAddItemArray(soap, NULL, NULL, "ns1:AddItem");
	case SOAP_TYPE_PointerToItemArray:
		return soap_in_PointerToItemArray(soap, NULL, NULL, "ns1:Item");
	case SOAP_TYPE_PointerToThirdPartyProductDetailsArray:
		return soap_in_PointerToThirdPartyProductDetailsArray(soap, NULL, NULL, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_PointerToFeedbackArray:
		return soap_in_PointerToFeedbackArray(soap, NULL, NULL, "ns1:Feedback");
	case SOAP_TYPE_PointerToListingProductDetailsArray:
		return soap_in_PointerToListingProductDetailsArray(soap, NULL, NULL, "ns1:ListingProductDetails");
	case SOAP_TYPE_PointerTons1__SellerFeedback:
		return soap_in_PointerTons1__SellerFeedback(soap, NULL, NULL, "ns1:SellerFeedback");
	case SOAP_TYPE_PointerTons1__ListingProductInfo:
		return soap_in_PointerTons1__ListingProductInfo(soap, NULL, NULL, "ns1:ListingProductInfo");
	case SOAP_TYPE_PointerToSellerSearchDetailsArray:
		return soap_in_PointerToSellerSearchDetailsArray(soap, NULL, NULL, "ns1:SellerSearchDetails");
	case SOAP_TYPE_PointerToSellerProfileDetailsArray:
		return soap_in_PointerToSellerProfileDetailsArray(soap, NULL, NULL, "ns1:SellerProfileDetails");
	case SOAP_TYPE_PointerToMarketplaceSearchDetailsArray:
		return soap_in_PointerToMarketplaceSearchDetailsArray(soap, NULL, NULL, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_PointerToCustomerReviewArray:
		return soap_in_PointerToCustomerReviewArray(soap, NULL, NULL, "ns1:CustomerReview");
	case SOAP_TYPE_PointerToListArray:
		return soap_in_PointerToListArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToSimilarProductsArray:
		return soap_in_PointerToSimilarProductsArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__Reviews:
		return soap_in_PointerTons1__Reviews(soap, NULL, NULL, "ns1:Reviews");
	case SOAP_TYPE_PointerToPlatformArray:
		return soap_in_PointerToPlatformArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToAccessoryArray:
		return soap_in_PointerToAccessoryArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToTrackArray:
		return soap_in_PointerToTrackArray(soap, NULL, NULL, "ns1:Track");
	case SOAP_TYPE_PointerToFeaturesArray:
		return soap_in_PointerToFeaturesArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToBrowseNodeArray:
		return soap_in_PointerToBrowseNodeArray(soap, NULL, NULL, "ns1:BrowseNode");
	case SOAP_TYPE_PointerTons1__ThirdPartyProductInfo:
		return soap_in_PointerTons1__ThirdPartyProductInfo(soap, NULL, NULL, "ns1:ThirdPartyProductInfo");
	case SOAP_TYPE_PointerToDirectorArray:
		return soap_in_PointerToDirectorArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToStarringArray:
		return soap_in_PointerToStarringArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToAuthorArray:
		return soap_in_PointerToAuthorArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToArtistArray:
		return soap_in_PointerToArtistArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToKeyPhraseArray:
		return soap_in_PointerToKeyPhraseArray(soap, NULL, NULL, "ns1:KeyPhrase");
	case SOAP_TYPE_PointerToDetailsArray:
		return soap_in_PointerToDetailsArray(soap, NULL, NULL, "ns1:Details");
	case SOAP_TYPE_PointerTons1__ProductInfo:
		return soap_in_PointerTons1__ProductInfo(soap, NULL, NULL, "ns1:ProductInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ModifyShoppingCartItemsRequest"))
		{	*type = SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest;
			return soap_in_ns1__ModifyShoppingCartItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveShoppingCartItemsRequest"))
		{	*type = SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest;
			return soap_in_ns1__RemoveShoppingCartItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddShoppingCartItemsRequest"))
		{	*type = SOAP_TYPE_ns1__AddShoppingCartItemsRequest;
			return soap_in_ns1__AddShoppingCartItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearShoppingCartRequest"))
		{	*type = SOAP_TYPE_ns1__ClearShoppingCartRequest;
			return soap_in_ns1__ClearShoppingCartRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShoppingCartRequest"))
		{	*type = SOAP_TYPE_ns1__GetShoppingCartRequest;
			return soap_in_ns1__GetShoppingCartRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ShoppingCart"))
		{	*type = SOAP_TYPE_ns1__ShoppingCart;
			return soap_in_ns1__ShoppingCart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddItem"))
		{	*type = SOAP_TYPE_ns1__AddItem;
			return soap_in_ns1__AddItem(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AddItem"))
		{	*type = SOAP_TYPE_AddItemArray;
			return soap_in_AddItemArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemQuantity"))
		{	*type = SOAP_TYPE_ns1__ItemQuantity;
			return soap_in_ns1__ItemQuantity(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ItemQuantity"))
		{	*type = SOAP_TYPE_ItemQuantityArray;
			return soap_in_ItemQuantityArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Item"))
		{	*type = SOAP_TYPE_ns1__Item;
			return soap_in_ns1__Item(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Item"))
		{	*type = SOAP_TYPE_ItemArray;
			return soap_in_ItemArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ItemIdArray;
			return soap_in_ItemIdArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SimilarityRequest"))
		{	*type = SOAP_TYPE_ns1__SimilarityRequest;
			return soap_in_ns1__SimilarityRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerRequest"))
		{	*type = SOAP_TYPE_ns1__SellerRequest;
			return soap_in_ns1__SellerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerProfileRequest"))
		{	*type = SOAP_TYPE_ns1__SellerProfileRequest;
			return soap_in_ns1__SellerProfileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketplaceRequest"))
		{	*type = SOAP_TYPE_ns1__MarketplaceRequest;
			return soap_in_ns1__MarketplaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WishlistRequest"))
		{	*type = SOAP_TYPE_ns1__WishlistRequest;
			return soap_in_ns1__WishlistRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListManiaRequest"))
		{	*type = SOAP_TYPE_ns1__ListManiaRequest;
			return soap_in_ns1__ListManiaRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ManufacturerRequest"))
		{	*type = SOAP_TYPE_ns1__ManufacturerRequest;
			return soap_in_ns1__ManufacturerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeRequest"))
		{	*type = SOAP_TYPE_ns1__ExchangeRequest;
			return soap_in_ns1__ExchangeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DirectorRequest"))
		{	*type = SOAP_TYPE_ns1__DirectorRequest;
			return soap_in_ns1__DirectorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActorRequest"))
		{	*type = SOAP_TYPE_ns1__ActorRequest;
			return soap_in_ns1__ActorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuthorRequest"))
		{	*type = SOAP_TYPE_ns1__AuthorRequest;
			return soap_in_ns1__AuthorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArtistRequest"))
		{	*type = SOAP_TYPE_ns1__ArtistRequest;
			return soap_in_ns1__ArtistRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpcRequest"))
		{	*type = SOAP_TYPE_ns1__UpcRequest;
			return soap_in_ns1__UpcRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BlendedRequest"))
		{	*type = SOAP_TYPE_ns1__BlendedRequest;
			return soap_in_ns1__BlendedRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AsinRequest"))
		{	*type = SOAP_TYPE_ns1__AsinRequest;
			return soap_in_ns1__AsinRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BrowseNodeRequest"))
		{	*type = SOAP_TYPE_ns1__BrowseNodeRequest;
			return soap_in_ns1__BrowseNodeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PowerRequest"))
		{	*type = SOAP_TYPE_ns1__PowerRequest;
			return soap_in_ns1__PowerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:KeywordRequest"))
		{	*type = SOAP_TYPE_ns1__KeywordRequest;
			return soap_in_ns1__KeywordRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ThirdPartyProductDetails"))
		{	*type = SOAP_TYPE_ns1__ThirdPartyProductDetails;
			return soap_in_ns1__ThirdPartyProductDetails(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ThirdPartyProductDetails"))
		{	*type = SOAP_TYPE_ThirdPartyProductDetailsArray;
			return soap_in_ThirdPartyProductDetailsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ThirdPartyProductInfo"))
		{	*type = SOAP_TYPE_ns1__ThirdPartyProductInfo;
			return soap_in_ns1__ThirdPartyProductInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Feedback"))
		{	*type = SOAP_TYPE_ns1__Feedback;
			return soap_in_ns1__Feedback(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Feedback"))
		{	*type = SOAP_TYPE_FeedbackArray;
			return soap_in_FeedbackArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerFeedback"))
		{	*type = SOAP_TYPE_ns1__SellerFeedback;
			return soap_in_ns1__SellerFeedback(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListingProductDetails"))
		{	*type = SOAP_TYPE_ns1__ListingProductDetails;
			return soap_in_ns1__ListingProductDetails(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ListingProductDetails"))
		{	*type = SOAP_TYPE_ListingProductDetailsArray;
			return soap_in_ListingProductDetailsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListingProductInfo"))
		{	*type = SOAP_TYPE_ns1__ListingProductInfo;
			return soap_in_ns1__ListingProductInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:SellerSearchDetails"))
		{	*type = SOAP_TYPE_SellerSearchDetailsArray;
			return soap_in_SellerSearchDetailsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerSearchDetails"))
		{	*type = SOAP_TYPE_ns1__SellerSearchDetails;
			return soap_in_ns1__SellerSearchDetails(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:SellerProfileDetails"))
		{	*type = SOAP_TYPE_SellerProfileDetailsArray;
			return soap_in_SellerProfileDetailsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerProfileDetails"))
		{	*type = SOAP_TYPE_ns1__SellerProfileDetails;
			return soap_in_ns1__SellerProfileDetails(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MarketplaceSearchDetails"))
		{	*type = SOAP_TYPE_MarketplaceSearchDetailsArray;
			return soap_in_MarketplaceSearchDetailsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketplaceSearchDetails"))
		{	*type = SOAP_TYPE_ns1__MarketplaceSearchDetails;
			return soap_in_ns1__MarketplaceSearchDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerSearch"))
		{	*type = SOAP_TYPE_ns1__SellerSearch;
			return soap_in_ns1__SellerSearch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerProfile"))
		{	*type = SOAP_TYPE_ns1__SellerProfile;
			return soap_in_ns1__SellerProfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketplaceSearch"))
		{	*type = SOAP_TYPE_ns1__MarketplaceSearch;
			return soap_in_ns1__MarketplaceSearch(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ListArray;
			return soap_in_ListArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_SimilarProductsArray;
			return soap_in_SimilarProductsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CustomerReview"))
		{	*type = SOAP_TYPE_ns1__CustomerReview;
			return soap_in_ns1__CustomerReview(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CustomerReview"))
		{	*type = SOAP_TYPE_CustomerReviewArray;
			return soap_in_CustomerReviewArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Reviews"))
		{	*type = SOAP_TYPE_ns1__Reviews;
			return soap_in_ns1__Reviews(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_PlatformArray;
			return soap_in_PlatformArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_AccessoryArray;
			return soap_in_AccessoryArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Track"))
		{	*type = SOAP_TYPE_ns1__Track;
			return soap_in_ns1__Track(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Track"))
		{	*type = SOAP_TYPE_TrackArray;
			return soap_in_TrackArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_FeaturesArray;
			return soap_in_FeaturesArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BrowseNode"))
		{	*type = SOAP_TYPE_ns1__BrowseNode;
			return soap_in_ns1__BrowseNode(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:BrowseNode"))
		{	*type = SOAP_TYPE_BrowseNodeArray;
			return soap_in_BrowseNodeArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_DirectorArray;
			return soap_in_DirectorArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_StarringArray;
			return soap_in_StarringArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_AuthorArray;
			return soap_in_AuthorArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ArtistArray;
			return soap_in_ArtistArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:KeyPhrase"))
		{	*type = SOAP_TYPE_ns1__KeyPhrase;
			return soap_in_ns1__KeyPhrase(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:KeyPhrase"))
		{	*type = SOAP_TYPE_KeyPhraseArray;
			return soap_in_KeyPhraseArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Details"))
		{	*type = SOAP_TYPE_ns1__Details;
			return soap_in_ns1__Details(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Details"))
		{	*type = SOAP_TYPE_DetailsArray;
			return soap_in_DetailsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProductInfo"))
		{	*type = SOAP_TYPE_ns1__ProductInfo;
			return soap_in_ns1__ProductInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProductLine"))
		{	*type = SOAP_TYPE_ns1__ProductLine;
			return soap_in_ns1__ProductLine(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ProductLine"))
		{	*type = SOAP_TYPE_ProductLineArray;
			return soap_in_ProductLineArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ModifyShoppingCartItemsRequest"))
		{	*type = SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_;
			return soap_in_ns1__ModifyShoppingCartItemsRequest_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ModifyShoppingCartItemsRequestResponse"))
		{	*type = SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse;
			return soap_in_ns1__ModifyShoppingCartItemsRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveShoppingCartItemsRequest"))
		{	*type = SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_;
			return soap_in_ns1__RemoveShoppingCartItemsRequest_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveShoppingCartItemsRequestResponse"))
		{	*type = SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse;
			return soap_in_ns1__RemoveShoppingCartItemsRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddShoppingCartItemsRequest"))
		{	*type = SOAP_TYPE_ns1__AddShoppingCartItemsRequest_;
			return soap_in_ns1__AddShoppingCartItemsRequest_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddShoppingCartItemsRequestResponse"))
		{	*type = SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse;
			return soap_in_ns1__AddShoppingCartItemsRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearShoppingCartRequest"))
		{	*type = SOAP_TYPE_ns1__ClearShoppingCartRequest_;
			return soap_in_ns1__ClearShoppingCartRequest_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearShoppingCartRequestResponse"))
		{	*type = SOAP_TYPE_ns1__ClearShoppingCartRequestResponse;
			return soap_in_ns1__ClearShoppingCartRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShoppingCartRequest"))
		{	*type = SOAP_TYPE_ns1__GetShoppingCartRequest_;
			return soap_in_ns1__GetShoppingCartRequest_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShoppingCartRequestResponse"))
		{	*type = SOAP_TYPE_ns1__GetShoppingCartRequestResponse;
			return soap_in_ns1__GetShoppingCartRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SimilaritySearchRequest"))
		{	*type = SOAP_TYPE_ns1__SimilaritySearchRequest;
			return soap_in_ns1__SimilaritySearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SimilaritySearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__SimilaritySearchRequestResponse;
			return soap_in_ns1__SimilaritySearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketplaceSearchRequest"))
		{	*type = SOAP_TYPE_ns1__MarketplaceSearchRequest;
			return soap_in_ns1__MarketplaceSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketplaceSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__MarketplaceSearchRequestResponse;
			return soap_in_ns1__MarketplaceSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerSearchRequest"))
		{	*type = SOAP_TYPE_ns1__SellerSearchRequest;
			return soap_in_ns1__SellerSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__SellerSearchRequestResponse;
			return soap_in_ns1__SellerSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerProfileSearchRequest"))
		{	*type = SOAP_TYPE_ns1__SellerProfileSearchRequest;
			return soap_in_ns1__SellerProfileSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellerProfileSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__SellerProfileSearchRequestResponse;
			return soap_in_ns1__SellerProfileSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WishlistSearchRequest"))
		{	*type = SOAP_TYPE_ns1__WishlistSearchRequest;
			return soap_in_ns1__WishlistSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WishlistSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__WishlistSearchRequestResponse;
			return soap_in_ns1__WishlistSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListManiaSearchRequest"))
		{	*type = SOAP_TYPE_ns1__ListManiaSearchRequest;
			return soap_in_ns1__ListManiaSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListManiaSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__ListManiaSearchRequestResponse;
			return soap_in_ns1__ListManiaSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeSearchRequest"))
		{	*type = SOAP_TYPE_ns1__ExchangeSearchRequest;
			return soap_in_ns1__ExchangeSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__ExchangeSearchRequestResponse;
			return soap_in_ns1__ExchangeSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DirectorSearchRequest"))
		{	*type = SOAP_TYPE_ns1__DirectorSearchRequest;
			return soap_in_ns1__DirectorSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DirectorSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__DirectorSearchRequestResponse;
			return soap_in_ns1__DirectorSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ManufacturerSearchRequest"))
		{	*type = SOAP_TYPE_ns1__ManufacturerSearchRequest;
			return soap_in_ns1__ManufacturerSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ManufacturerSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__ManufacturerSearchRequestResponse;
			return soap_in_ns1__ManufacturerSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActorSearchRequest"))
		{	*type = SOAP_TYPE_ns1__ActorSearchRequest;
			return soap_in_ns1__ActorSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActorSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__ActorSearchRequestResponse;
			return soap_in_ns1__ActorSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArtistSearchRequest"))
		{	*type = SOAP_TYPE_ns1__ArtistSearchRequest;
			return soap_in_ns1__ArtistSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArtistSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__ArtistSearchRequestResponse;
			return soap_in_ns1__ArtistSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuthorSearchRequest"))
		{	*type = SOAP_TYPE_ns1__AuthorSearchRequest;
			return soap_in_ns1__AuthorSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuthorSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__AuthorSearchRequestResponse;
			return soap_in_ns1__AuthorSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpcSearchRequest"))
		{	*type = SOAP_TYPE_ns1__UpcSearchRequest;
			return soap_in_ns1__UpcSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpcSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__UpcSearchRequestResponse;
			return soap_in_ns1__UpcSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BlendedSearchRequest"))
		{	*type = SOAP_TYPE_ns1__BlendedSearchRequest;
			return soap_in_ns1__BlendedSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BlendedSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__BlendedSearchRequestResponse;
			return soap_in_ns1__BlendedSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AsinSearchRequest"))
		{	*type = SOAP_TYPE_ns1__AsinSearchRequest;
			return soap_in_ns1__AsinSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AsinSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__AsinSearchRequestResponse;
			return soap_in_ns1__AsinSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BrowseNodeSearchRequest"))
		{	*type = SOAP_TYPE_ns1__BrowseNodeSearchRequest;
			return soap_in_ns1__BrowseNodeSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BrowseNodeSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse;
			return soap_in_ns1__BrowseNodeSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PowerSearchRequest"))
		{	*type = SOAP_TYPE_ns1__PowerSearchRequest;
			return soap_in_ns1__PowerSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PowerSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__PowerSearchRequestResponse;
			return soap_in_ns1__PowerSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:KeywordSearchRequest"))
		{	*type = SOAP_TYPE_ns1__KeywordSearchRequest;
			return soap_in_ns1__KeywordSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:KeywordSearchRequestResponse"))
		{	*type = SOAP_TYPE_ns1__KeywordSearchRequestResponse;
			return soap_in_ns1__KeywordSearchRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest:
		return ((ns1__ModifyShoppingCartItemsRequest *)ptr)->soap_out(soap, tag, id, "ns1:ModifyShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest:
		return ((ns1__RemoveShoppingCartItemsRequest *)ptr)->soap_out(soap, tag, id, "ns1:RemoveShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest:
		return ((ns1__AddShoppingCartItemsRequest *)ptr)->soap_out(soap, tag, id, "ns1:AddShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__ClearShoppingCartRequest:
		return ((ns1__ClearShoppingCartRequest *)ptr)->soap_out(soap, tag, id, "ns1:ClearShoppingCartRequest");
	case SOAP_TYPE_ns1__GetShoppingCartRequest:
		return ((ns1__GetShoppingCartRequest *)ptr)->soap_out(soap, tag, id, "ns1:GetShoppingCartRequest");
	case SOAP_TYPE_ns1__ShoppingCart:
		return ((ns1__ShoppingCart *)ptr)->soap_out(soap, tag, id, "ns1:ShoppingCart");
	case SOAP_TYPE_ns1__AddItem:
		return ((ns1__AddItem *)ptr)->soap_out(soap, tag, id, "ns1:AddItem");
	case SOAP_TYPE_AddItemArray:
		return ((AddItemArray *)ptr)->soap_out(soap, tag, id, "ns1:AddItem");
	case SOAP_TYPE_ns1__ItemQuantity:
		return ((ns1__ItemQuantity *)ptr)->soap_out(soap, tag, id, "ns1:ItemQuantity");
	case SOAP_TYPE_ItemQuantityArray:
		return ((ItemQuantityArray *)ptr)->soap_out(soap, tag, id, "ns1:ItemQuantity");
	case SOAP_TYPE_ns1__Item:
		return ((ns1__Item *)ptr)->soap_out(soap, tag, id, "ns1:Item");
	case SOAP_TYPE_ItemArray:
		return ((ItemArray *)ptr)->soap_out(soap, tag, id, "ns1:Item");
	case SOAP_TYPE_ItemIdArray:
		return ((ItemIdArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ns1__SimilarityRequest:
		return ((ns1__SimilarityRequest *)ptr)->soap_out(soap, tag, id, "ns1:SimilarityRequest");
	case SOAP_TYPE_ns1__SellerRequest:
		return ((ns1__SellerRequest *)ptr)->soap_out(soap, tag, id, "ns1:SellerRequest");
	case SOAP_TYPE_ns1__SellerProfileRequest:
		return ((ns1__SellerProfileRequest *)ptr)->soap_out(soap, tag, id, "ns1:SellerProfileRequest");
	case SOAP_TYPE_ns1__MarketplaceRequest:
		return ((ns1__MarketplaceRequest *)ptr)->soap_out(soap, tag, id, "ns1:MarketplaceRequest");
	case SOAP_TYPE_ns1__WishlistRequest:
		return ((ns1__WishlistRequest *)ptr)->soap_out(soap, tag, id, "ns1:WishlistRequest");
	case SOAP_TYPE_ns1__ListManiaRequest:
		return ((ns1__ListManiaRequest *)ptr)->soap_out(soap, tag, id, "ns1:ListManiaRequest");
	case SOAP_TYPE_ns1__ManufacturerRequest:
		return ((ns1__ManufacturerRequest *)ptr)->soap_out(soap, tag, id, "ns1:ManufacturerRequest");
	case SOAP_TYPE_ns1__ExchangeRequest:
		return ((ns1__ExchangeRequest *)ptr)->soap_out(soap, tag, id, "ns1:ExchangeRequest");
	case SOAP_TYPE_ns1__DirectorRequest:
		return ((ns1__DirectorRequest *)ptr)->soap_out(soap, tag, id, "ns1:DirectorRequest");
	case SOAP_TYPE_ns1__ActorRequest:
		return ((ns1__ActorRequest *)ptr)->soap_out(soap, tag, id, "ns1:ActorRequest");
	case SOAP_TYPE_ns1__AuthorRequest:
		return ((ns1__AuthorRequest *)ptr)->soap_out(soap, tag, id, "ns1:AuthorRequest");
	case SOAP_TYPE_ns1__ArtistRequest:
		return ((ns1__ArtistRequest *)ptr)->soap_out(soap, tag, id, "ns1:ArtistRequest");
	case SOAP_TYPE_ns1__UpcRequest:
		return ((ns1__UpcRequest *)ptr)->soap_out(soap, tag, id, "ns1:UpcRequest");
	case SOAP_TYPE_ns1__BlendedRequest:
		return ((ns1__BlendedRequest *)ptr)->soap_out(soap, tag, id, "ns1:BlendedRequest");
	case SOAP_TYPE_ns1__AsinRequest:
		return ((ns1__AsinRequest *)ptr)->soap_out(soap, tag, id, "ns1:AsinRequest");
	case SOAP_TYPE_ns1__BrowseNodeRequest:
		return ((ns1__BrowseNodeRequest *)ptr)->soap_out(soap, tag, id, "ns1:BrowseNodeRequest");
	case SOAP_TYPE_ns1__PowerRequest:
		return ((ns1__PowerRequest *)ptr)->soap_out(soap, tag, id, "ns1:PowerRequest");
	case SOAP_TYPE_ns1__KeywordRequest:
		return ((ns1__KeywordRequest *)ptr)->soap_out(soap, tag, id, "ns1:KeywordRequest");
	case SOAP_TYPE_ns1__ThirdPartyProductDetails:
		return ((ns1__ThirdPartyProductDetails *)ptr)->soap_out(soap, tag, id, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_ThirdPartyProductDetailsArray:
		return ((ThirdPartyProductDetailsArray *)ptr)->soap_out(soap, tag, id, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_ns1__ThirdPartyProductInfo:
		return ((ns1__ThirdPartyProductInfo *)ptr)->soap_out(soap, tag, id, "ns1:ThirdPartyProductInfo");
	case SOAP_TYPE_ns1__Feedback:
		return ((ns1__Feedback *)ptr)->soap_out(soap, tag, id, "ns1:Feedback");
	case SOAP_TYPE_FeedbackArray:
		return ((FeedbackArray *)ptr)->soap_out(soap, tag, id, "ns1:Feedback");
	case SOAP_TYPE_ns1__SellerFeedback:
		return ((ns1__SellerFeedback *)ptr)->soap_out(soap, tag, id, "ns1:SellerFeedback");
	case SOAP_TYPE_ns1__ListingProductDetails:
		return ((ns1__ListingProductDetails *)ptr)->soap_out(soap, tag, id, "ns1:ListingProductDetails");
	case SOAP_TYPE_ListingProductDetailsArray:
		return ((ListingProductDetailsArray *)ptr)->soap_out(soap, tag, id, "ns1:ListingProductDetails");
	case SOAP_TYPE_ns1__ListingProductInfo:
		return ((ns1__ListingProductInfo *)ptr)->soap_out(soap, tag, id, "ns1:ListingProductInfo");
	case SOAP_TYPE_SellerSearchDetailsArray:
		return ((SellerSearchDetailsArray *)ptr)->soap_out(soap, tag, id, "ns1:SellerSearchDetails");
	case SOAP_TYPE_ns1__SellerSearchDetails:
		return ((ns1__SellerSearchDetails *)ptr)->soap_out(soap, tag, id, "ns1:SellerSearchDetails");
	case SOAP_TYPE_SellerProfileDetailsArray:
		return ((SellerProfileDetailsArray *)ptr)->soap_out(soap, tag, id, "ns1:SellerProfileDetails");
	case SOAP_TYPE_ns1__SellerProfileDetails:
		return ((ns1__SellerProfileDetails *)ptr)->soap_out(soap, tag, id, "ns1:SellerProfileDetails");
	case SOAP_TYPE_MarketplaceSearchDetailsArray:
		return ((MarketplaceSearchDetailsArray *)ptr)->soap_out(soap, tag, id, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_ns1__MarketplaceSearchDetails:
		return ((ns1__MarketplaceSearchDetails *)ptr)->soap_out(soap, tag, id, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_ns1__SellerSearch:
		return ((ns1__SellerSearch *)ptr)->soap_out(soap, tag, id, "ns1:SellerSearch");
	case SOAP_TYPE_ns1__SellerProfile:
		return ((ns1__SellerProfile *)ptr)->soap_out(soap, tag, id, "ns1:SellerProfile");
	case SOAP_TYPE_ns1__MarketplaceSearch:
		return ((ns1__MarketplaceSearch *)ptr)->soap_out(soap, tag, id, "ns1:MarketplaceSearch");
	case SOAP_TYPE_ListArray:
		return ((ListArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_SimilarProductsArray:
		return ((SimilarProductsArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ns1__CustomerReview:
		return ((ns1__CustomerReview *)ptr)->soap_out(soap, tag, id, "ns1:CustomerReview");
	case SOAP_TYPE_CustomerReviewArray:
		return ((CustomerReviewArray *)ptr)->soap_out(soap, tag, id, "ns1:CustomerReview");
	case SOAP_TYPE_ns1__Reviews:
		return ((ns1__Reviews *)ptr)->soap_out(soap, tag, id, "ns1:Reviews");
	case SOAP_TYPE_PlatformArray:
		return ((PlatformArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_AccessoryArray:
		return ((AccessoryArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ns1__Track:
		return ((ns1__Track *)ptr)->soap_out(soap, tag, id, "ns1:Track");
	case SOAP_TYPE_TrackArray:
		return ((TrackArray *)ptr)->soap_out(soap, tag, id, "ns1:Track");
	case SOAP_TYPE_FeaturesArray:
		return ((FeaturesArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ns1__BrowseNode:
		return ((ns1__BrowseNode *)ptr)->soap_out(soap, tag, id, "ns1:BrowseNode");
	case SOAP_TYPE_BrowseNodeArray:
		return ((BrowseNodeArray *)ptr)->soap_out(soap, tag, id, "ns1:BrowseNode");
	case SOAP_TYPE_DirectorArray:
		return ((DirectorArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_StarringArray:
		return ((StarringArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_AuthorArray:
		return ((AuthorArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ArtistArray:
		return ((ArtistArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ns1__KeyPhrase:
		return ((ns1__KeyPhrase *)ptr)->soap_out(soap, tag, id, "ns1:KeyPhrase");
	case SOAP_TYPE_KeyPhraseArray:
		return ((KeyPhraseArray *)ptr)->soap_out(soap, tag, id, "ns1:KeyPhrase");
	case SOAP_TYPE_ns1__Details:
		return ((ns1__Details *)ptr)->soap_out(soap, tag, id, "ns1:Details");
	case SOAP_TYPE_DetailsArray:
		return ((DetailsArray *)ptr)->soap_out(soap, tag, id, "ns1:Details");
	case SOAP_TYPE_ns1__ProductInfo:
		return ((ns1__ProductInfo *)ptr)->soap_out(soap, tag, id, "ns1:ProductInfo");
	case SOAP_TYPE_ns1__ProductLine:
		return ((ns1__ProductLine *)ptr)->soap_out(soap, tag, id, "ns1:ProductLine");
	case SOAP_TYPE_ProductLineArray:
		return ((ProductLineArray *)ptr)->soap_out(soap, tag, id, "ns1:ProductLine");
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_:
		return soap_out_ns1__ModifyShoppingCartItemsRequest_(soap, tag, id, (const struct ns1__ModifyShoppingCartItemsRequest_ *)ptr, "ns1:ModifyShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse:
		return soap_out_ns1__ModifyShoppingCartItemsRequestResponse(soap, tag, id, (const struct ns1__ModifyShoppingCartItemsRequestResponse *)ptr, "ns1:ModifyShoppingCartItemsRequestResponse");
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_:
		return soap_out_ns1__RemoveShoppingCartItemsRequest_(soap, tag, id, (const struct ns1__RemoveShoppingCartItemsRequest_ *)ptr, "ns1:RemoveShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse:
		return soap_out_ns1__RemoveShoppingCartItemsRequestResponse(soap, tag, id, (const struct ns1__RemoveShoppingCartItemsRequestResponse *)ptr, "ns1:RemoveShoppingCartItemsRequestResponse");
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest_:
		return soap_out_ns1__AddShoppingCartItemsRequest_(soap, tag, id, (const struct ns1__AddShoppingCartItemsRequest_ *)ptr, "ns1:AddShoppingCartItemsRequest");
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse:
		return soap_out_ns1__AddShoppingCartItemsRequestResponse(soap, tag, id, (const struct ns1__AddShoppingCartItemsRequestResponse *)ptr, "ns1:AddShoppingCartItemsRequestResponse");
	case SOAP_TYPE_ns1__ClearShoppingCartRequest_:
		return soap_out_ns1__ClearShoppingCartRequest_(soap, tag, id, (const struct ns1__ClearShoppingCartRequest_ *)ptr, "ns1:ClearShoppingCartRequest");
	case SOAP_TYPE_ns1__ClearShoppingCartRequestResponse:
		return soap_out_ns1__ClearShoppingCartRequestResponse(soap, tag, id, (const struct ns1__ClearShoppingCartRequestResponse *)ptr, "ns1:ClearShoppingCartRequestResponse");
	case SOAP_TYPE_ns1__GetShoppingCartRequest_:
		return soap_out_ns1__GetShoppingCartRequest_(soap, tag, id, (const struct ns1__GetShoppingCartRequest_ *)ptr, "ns1:GetShoppingCartRequest");
	case SOAP_TYPE_ns1__GetShoppingCartRequestResponse:
		return soap_out_ns1__GetShoppingCartRequestResponse(soap, tag, id, (const struct ns1__GetShoppingCartRequestResponse *)ptr, "ns1:GetShoppingCartRequestResponse");
	case SOAP_TYPE_ns1__SimilaritySearchRequest:
		return soap_out_ns1__SimilaritySearchRequest(soap, tag, id, (const struct ns1__SimilaritySearchRequest *)ptr, "ns1:SimilaritySearchRequest");
	case SOAP_TYPE_ns1__SimilaritySearchRequestResponse:
		return soap_out_ns1__SimilaritySearchRequestResponse(soap, tag, id, (const struct ns1__SimilaritySearchRequestResponse *)ptr, "ns1:SimilaritySearchRequestResponse");
	case SOAP_TYPE_ns1__MarketplaceSearchRequest:
		return soap_out_ns1__MarketplaceSearchRequest(soap, tag, id, (const struct ns1__MarketplaceSearchRequest *)ptr, "ns1:MarketplaceSearchRequest");
	case SOAP_TYPE_ns1__MarketplaceSearchRequestResponse:
		return soap_out_ns1__MarketplaceSearchRequestResponse(soap, tag, id, (const struct ns1__MarketplaceSearchRequestResponse *)ptr, "ns1:MarketplaceSearchRequestResponse");
	case SOAP_TYPE_ns1__SellerSearchRequest:
		return soap_out_ns1__SellerSearchRequest(soap, tag, id, (const struct ns1__SellerSearchRequest *)ptr, "ns1:SellerSearchRequest");
	case SOAP_TYPE_ns1__SellerSearchRequestResponse:
		return soap_out_ns1__SellerSearchRequestResponse(soap, tag, id, (const struct ns1__SellerSearchRequestResponse *)ptr, "ns1:SellerSearchRequestResponse");
	case SOAP_TYPE_ns1__SellerProfileSearchRequest:
		return soap_out_ns1__SellerProfileSearchRequest(soap, tag, id, (const struct ns1__SellerProfileSearchRequest *)ptr, "ns1:SellerProfileSearchRequest");
	case SOAP_TYPE_ns1__SellerProfileSearchRequestResponse:
		return soap_out_ns1__SellerProfileSearchRequestResponse(soap, tag, id, (const struct ns1__SellerProfileSearchRequestResponse *)ptr, "ns1:SellerProfileSearchRequestResponse");
	case SOAP_TYPE_ns1__WishlistSearchRequest:
		return soap_out_ns1__WishlistSearchRequest(soap, tag, id, (const struct ns1__WishlistSearchRequest *)ptr, "ns1:WishlistSearchRequest");
	case SOAP_TYPE_ns1__WishlistSearchRequestResponse:
		return soap_out_ns1__WishlistSearchRequestResponse(soap, tag, id, (const struct ns1__WishlistSearchRequestResponse *)ptr, "ns1:WishlistSearchRequestResponse");
	case SOAP_TYPE_ns1__ListManiaSearchRequest:
		return soap_out_ns1__ListManiaSearchRequest(soap, tag, id, (const struct ns1__ListManiaSearchRequest *)ptr, "ns1:ListManiaSearchRequest");
	case SOAP_TYPE_ns1__ListManiaSearchRequestResponse:
		return soap_out_ns1__ListManiaSearchRequestResponse(soap, tag, id, (const struct ns1__ListManiaSearchRequestResponse *)ptr, "ns1:ListManiaSearchRequestResponse");
	case SOAP_TYPE_ns1__ExchangeSearchRequest:
		return soap_out_ns1__ExchangeSearchRequest(soap, tag, id, (const struct ns1__ExchangeSearchRequest *)ptr, "ns1:ExchangeSearchRequest");
	case SOAP_TYPE_ns1__ExchangeSearchRequestResponse:
		return soap_out_ns1__ExchangeSearchRequestResponse(soap, tag, id, (const struct ns1__ExchangeSearchRequestResponse *)ptr, "ns1:ExchangeSearchRequestResponse");
	case SOAP_TYPE_ns1__DirectorSearchRequest:
		return soap_out_ns1__DirectorSearchRequest(soap, tag, id, (const struct ns1__DirectorSearchRequest *)ptr, "ns1:DirectorSearchRequest");
	case SOAP_TYPE_ns1__DirectorSearchRequestResponse:
		return soap_out_ns1__DirectorSearchRequestResponse(soap, tag, id, (const struct ns1__DirectorSearchRequestResponse *)ptr, "ns1:DirectorSearchRequestResponse");
	case SOAP_TYPE_ns1__ManufacturerSearchRequest:
		return soap_out_ns1__ManufacturerSearchRequest(soap, tag, id, (const struct ns1__ManufacturerSearchRequest *)ptr, "ns1:ManufacturerSearchRequest");
	case SOAP_TYPE_ns1__ManufacturerSearchRequestResponse:
		return soap_out_ns1__ManufacturerSearchRequestResponse(soap, tag, id, (const struct ns1__ManufacturerSearchRequestResponse *)ptr, "ns1:ManufacturerSearchRequestResponse");
	case SOAP_TYPE_ns1__ActorSearchRequest:
		return soap_out_ns1__ActorSearchRequest(soap, tag, id, (const struct ns1__ActorSearchRequest *)ptr, "ns1:ActorSearchRequest");
	case SOAP_TYPE_ns1__ActorSearchRequestResponse:
		return soap_out_ns1__ActorSearchRequestResponse(soap, tag, id, (const struct ns1__ActorSearchRequestResponse *)ptr, "ns1:ActorSearchRequestResponse");
	case SOAP_TYPE_ns1__ArtistSearchRequest:
		return soap_out_ns1__ArtistSearchRequest(soap, tag, id, (const struct ns1__ArtistSearchRequest *)ptr, "ns1:ArtistSearchRequest");
	case SOAP_TYPE_ns1__ArtistSearchRequestResponse:
		return soap_out_ns1__ArtistSearchRequestResponse(soap, tag, id, (const struct ns1__ArtistSearchRequestResponse *)ptr, "ns1:ArtistSearchRequestResponse");
	case SOAP_TYPE_ns1__AuthorSearchRequest:
		return soap_out_ns1__AuthorSearchRequest(soap, tag, id, (const struct ns1__AuthorSearchRequest *)ptr, "ns1:AuthorSearchRequest");
	case SOAP_TYPE_ns1__AuthorSearchRequestResponse:
		return soap_out_ns1__AuthorSearchRequestResponse(soap, tag, id, (const struct ns1__AuthorSearchRequestResponse *)ptr, "ns1:AuthorSearchRequestResponse");
	case SOAP_TYPE_ns1__UpcSearchRequest:
		return soap_out_ns1__UpcSearchRequest(soap, tag, id, (const struct ns1__UpcSearchRequest *)ptr, "ns1:UpcSearchRequest");
	case SOAP_TYPE_ns1__UpcSearchRequestResponse:
		return soap_out_ns1__UpcSearchRequestResponse(soap, tag, id, (const struct ns1__UpcSearchRequestResponse *)ptr, "ns1:UpcSearchRequestResponse");
	case SOAP_TYPE_ns1__BlendedSearchRequest:
		return soap_out_ns1__BlendedSearchRequest(soap, tag, id, (const struct ns1__BlendedSearchRequest *)ptr, "ns1:BlendedSearchRequest");
	case SOAP_TYPE_ns1__BlendedSearchRequestResponse:
		return soap_out_ns1__BlendedSearchRequestResponse(soap, tag, id, (const struct ns1__BlendedSearchRequestResponse *)ptr, "ns1:BlendedSearchRequestResponse");
	case SOAP_TYPE_ns1__AsinSearchRequest:
		return soap_out_ns1__AsinSearchRequest(soap, tag, id, (const struct ns1__AsinSearchRequest *)ptr, "ns1:AsinSearchRequest");
	case SOAP_TYPE_ns1__AsinSearchRequestResponse:
		return soap_out_ns1__AsinSearchRequestResponse(soap, tag, id, (const struct ns1__AsinSearchRequestResponse *)ptr, "ns1:AsinSearchRequestResponse");
	case SOAP_TYPE_ns1__BrowseNodeSearchRequest:
		return soap_out_ns1__BrowseNodeSearchRequest(soap, tag, id, (const struct ns1__BrowseNodeSearchRequest *)ptr, "ns1:BrowseNodeSearchRequest");
	case SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse:
		return soap_out_ns1__BrowseNodeSearchRequestResponse(soap, tag, id, (const struct ns1__BrowseNodeSearchRequestResponse *)ptr, "ns1:BrowseNodeSearchRequestResponse");
	case SOAP_TYPE_ns1__PowerSearchRequest:
		return soap_out_ns1__PowerSearchRequest(soap, tag, id, (const struct ns1__PowerSearchRequest *)ptr, "ns1:PowerSearchRequest");
	case SOAP_TYPE_ns1__PowerSearchRequestResponse:
		return soap_out_ns1__PowerSearchRequestResponse(soap, tag, id, (const struct ns1__PowerSearchRequestResponse *)ptr, "ns1:PowerSearchRequestResponse");
	case SOAP_TYPE_ns1__KeywordSearchRequest:
		return soap_out_ns1__KeywordSearchRequest(soap, tag, id, (const struct ns1__KeywordSearchRequest *)ptr, "ns1:KeywordSearchRequest");
	case SOAP_TYPE_ns1__KeywordSearchRequestResponse:
		return soap_out_ns1__KeywordSearchRequestResponse(soap, tag, id, (const struct ns1__KeywordSearchRequestResponse *)ptr, "ns1:KeywordSearchRequestResponse");
	case SOAP_TYPE_PointerTons1__ModifyShoppingCartItemsRequest:
		return soap_out_PointerTons1__ModifyShoppingCartItemsRequest(soap, tag, id, (ns1__ModifyShoppingCartItemsRequest *const*)ptr, "ns1:ModifyShoppingCartItemsRequest");
	case SOAP_TYPE_PointerTons1__RemoveShoppingCartItemsRequest:
		return soap_out_PointerTons1__RemoveShoppingCartItemsRequest(soap, tag, id, (ns1__RemoveShoppingCartItemsRequest *const*)ptr, "ns1:RemoveShoppingCartItemsRequest");
	case SOAP_TYPE_PointerTons1__AddShoppingCartItemsRequest:
		return soap_out_PointerTons1__AddShoppingCartItemsRequest(soap, tag, id, (ns1__AddShoppingCartItemsRequest *const*)ptr, "ns1:AddShoppingCartItemsRequest");
	case SOAP_TYPE_PointerTons1__ClearShoppingCartRequest:
		return soap_out_PointerTons1__ClearShoppingCartRequest(soap, tag, id, (ns1__ClearShoppingCartRequest *const*)ptr, "ns1:ClearShoppingCartRequest");
	case SOAP_TYPE_PointerTons1__GetShoppingCartRequest:
		return soap_out_PointerTons1__GetShoppingCartRequest(soap, tag, id, (ns1__GetShoppingCartRequest *const*)ptr, "ns1:GetShoppingCartRequest");
	case SOAP_TYPE_PointerTons1__ShoppingCart:
		return soap_out_PointerTons1__ShoppingCart(soap, tag, id, (ns1__ShoppingCart *const*)ptr, "ns1:ShoppingCart");
	case SOAP_TYPE_PointerTons1__SimilarityRequest:
		return soap_out_PointerTons1__SimilarityRequest(soap, tag, id, (ns1__SimilarityRequest *const*)ptr, "ns1:SimilarityRequest");
	case SOAP_TYPE_PointerTons1__MarketplaceRequest:
		return soap_out_PointerTons1__MarketplaceRequest(soap, tag, id, (ns1__MarketplaceRequest *const*)ptr, "ns1:MarketplaceRequest");
	case SOAP_TYPE_PointerTons1__MarketplaceSearch:
		return soap_out_PointerTons1__MarketplaceSearch(soap, tag, id, (ns1__MarketplaceSearch *const*)ptr, "ns1:MarketplaceSearch");
	case SOAP_TYPE_PointerTons1__SellerRequest:
		return soap_out_PointerTons1__SellerRequest(soap, tag, id, (ns1__SellerRequest *const*)ptr, "ns1:SellerRequest");
	case SOAP_TYPE_PointerTons1__SellerSearch:
		return soap_out_PointerTons1__SellerSearch(soap, tag, id, (ns1__SellerSearch *const*)ptr, "ns1:SellerSearch");
	case SOAP_TYPE_PointerTons1__SellerProfileRequest:
		return soap_out_PointerTons1__SellerProfileRequest(soap, tag, id, (ns1__SellerProfileRequest *const*)ptr, "ns1:SellerProfileRequest");
	case SOAP_TYPE_PointerTons1__SellerProfile:
		return soap_out_PointerTons1__SellerProfile(soap, tag, id, (ns1__SellerProfile *const*)ptr, "ns1:SellerProfile");
	case SOAP_TYPE_PointerTons1__WishlistRequest:
		return soap_out_PointerTons1__WishlistRequest(soap, tag, id, (ns1__WishlistRequest *const*)ptr, "ns1:WishlistRequest");
	case SOAP_TYPE_PointerTons1__ListManiaRequest:
		return soap_out_PointerTons1__ListManiaRequest(soap, tag, id, (ns1__ListManiaRequest *const*)ptr, "ns1:ListManiaRequest");
	case SOAP_TYPE_PointerTons1__ExchangeRequest:
		return soap_out_PointerTons1__ExchangeRequest(soap, tag, id, (ns1__ExchangeRequest *const*)ptr, "ns1:ExchangeRequest");
	case SOAP_TYPE_PointerTons1__DirectorRequest:
		return soap_out_PointerTons1__DirectorRequest(soap, tag, id, (ns1__DirectorRequest *const*)ptr, "ns1:DirectorRequest");
	case SOAP_TYPE_PointerTons1__ManufacturerRequest:
		return soap_out_PointerTons1__ManufacturerRequest(soap, tag, id, (ns1__ManufacturerRequest *const*)ptr, "ns1:ManufacturerRequest");
	case SOAP_TYPE_PointerTons1__ActorRequest:
		return soap_out_PointerTons1__ActorRequest(soap, tag, id, (ns1__ActorRequest *const*)ptr, "ns1:ActorRequest");
	case SOAP_TYPE_PointerTons1__ArtistRequest:
		return soap_out_PointerTons1__ArtistRequest(soap, tag, id, (ns1__ArtistRequest *const*)ptr, "ns1:ArtistRequest");
	case SOAP_TYPE_PointerTons1__AuthorRequest:
		return soap_out_PointerTons1__AuthorRequest(soap, tag, id, (ns1__AuthorRequest *const*)ptr, "ns1:AuthorRequest");
	case SOAP_TYPE_PointerTons1__UpcRequest:
		return soap_out_PointerTons1__UpcRequest(soap, tag, id, (ns1__UpcRequest *const*)ptr, "ns1:UpcRequest");
	case SOAP_TYPE_PointerTons1__BlendedRequest:
		return soap_out_PointerTons1__BlendedRequest(soap, tag, id, (ns1__BlendedRequest *const*)ptr, "ns1:BlendedRequest");
	case SOAP_TYPE_PointerToProductLineArray:
		return soap_out_PointerToProductLineArray(soap, tag, id, (ProductLineArray *const*)ptr, "ns1:ProductLine");
	case SOAP_TYPE_PointerTons1__AsinRequest:
		return soap_out_PointerTons1__AsinRequest(soap, tag, id, (ns1__AsinRequest *const*)ptr, "ns1:AsinRequest");
	case SOAP_TYPE_PointerTons1__BrowseNodeRequest:
		return soap_out_PointerTons1__BrowseNodeRequest(soap, tag, id, (ns1__BrowseNodeRequest *const*)ptr, "ns1:BrowseNodeRequest");
	case SOAP_TYPE_PointerTons1__PowerRequest:
		return soap_out_PointerTons1__PowerRequest(soap, tag, id, (ns1__PowerRequest *const*)ptr, "ns1:PowerRequest");
	case SOAP_TYPE_PointerTons1__KeywordRequest:
		return soap_out_PointerTons1__KeywordRequest(soap, tag, id, (ns1__KeywordRequest *const*)ptr, "ns1:KeywordRequest");
	case SOAP_TYPE_PointerToPointerTons1__AddItem:
		return soap_out_PointerToPointerTons1__AddItem(soap, tag, id, (ns1__AddItem **const*)ptr, "ns1:AddItem");
	case SOAP_TYPE_PointerTons1__AddItem:
		return soap_out_PointerTons1__AddItem(soap, tag, id, (ns1__AddItem *const*)ptr, "ns1:AddItem");
	case SOAP_TYPE_PointerToPointerTons1__ItemQuantity:
		return soap_out_PointerToPointerTons1__ItemQuantity(soap, tag, id, (ns1__ItemQuantity **const*)ptr, "ns1:ItemQuantity");
	case SOAP_TYPE_PointerTons1__ItemQuantity:
		return soap_out_PointerTons1__ItemQuantity(soap, tag, id, (ns1__ItemQuantity *const*)ptr, "ns1:ItemQuantity");
	case SOAP_TYPE_PointerToPointerTons1__Item:
		return soap_out_PointerToPointerTons1__Item(soap, tag, id, (ns1__Item **const*)ptr, "ns1:Item");
	case SOAP_TYPE_PointerTons1__Item:
		return soap_out_PointerTons1__Item(soap, tag, id, (ns1__Item *const*)ptr, "ns1:Item");
	case SOAP_TYPE_PointerToPointerTons1__ThirdPartyProductDetails:
		return soap_out_PointerToPointerTons1__ThirdPartyProductDetails(soap, tag, id, (ns1__ThirdPartyProductDetails **const*)ptr, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_PointerTons1__ThirdPartyProductDetails:
		return soap_out_PointerTons1__ThirdPartyProductDetails(soap, tag, id, (ns1__ThirdPartyProductDetails *const*)ptr, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_PointerToPointerTons1__Feedback:
		return soap_out_PointerToPointerTons1__Feedback(soap, tag, id, (ns1__Feedback **const*)ptr, "ns1:Feedback");
	case SOAP_TYPE_PointerTons1__Feedback:
		return soap_out_PointerTons1__Feedback(soap, tag, id, (ns1__Feedback *const*)ptr, "ns1:Feedback");
	case SOAP_TYPE_PointerToPointerTons1__ListingProductDetails:
		return soap_out_PointerToPointerTons1__ListingProductDetails(soap, tag, id, (ns1__ListingProductDetails **const*)ptr, "ns1:ListingProductDetails");
	case SOAP_TYPE_PointerTons1__ListingProductDetails:
		return soap_out_PointerTons1__ListingProductDetails(soap, tag, id, (ns1__ListingProductDetails *const*)ptr, "ns1:ListingProductDetails");
	case SOAP_TYPE_PointerToPointerTons1__SellerSearchDetails:
		return soap_out_PointerToPointerTons1__SellerSearchDetails(soap, tag, id, (ns1__SellerSearchDetails **const*)ptr, "ns1:SellerSearchDetails");
	case SOAP_TYPE_PointerTons1__SellerSearchDetails:
		return soap_out_PointerTons1__SellerSearchDetails(soap, tag, id, (ns1__SellerSearchDetails *const*)ptr, "ns1:SellerSearchDetails");
	case SOAP_TYPE_PointerToPointerTons1__SellerProfileDetails:
		return soap_out_PointerToPointerTons1__SellerProfileDetails(soap, tag, id, (ns1__SellerProfileDetails **const*)ptr, "ns1:SellerProfileDetails");
	case SOAP_TYPE_PointerTons1__SellerProfileDetails:
		return soap_out_PointerTons1__SellerProfileDetails(soap, tag, id, (ns1__SellerProfileDetails *const*)ptr, "ns1:SellerProfileDetails");
	case SOAP_TYPE_PointerToPointerTons1__MarketplaceSearchDetails:
		return soap_out_PointerToPointerTons1__MarketplaceSearchDetails(soap, tag, id, (ns1__MarketplaceSearchDetails **const*)ptr, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_PointerTons1__MarketplaceSearchDetails:
		return soap_out_PointerTons1__MarketplaceSearchDetails(soap, tag, id, (ns1__MarketplaceSearchDetails *const*)ptr, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_PointerToPointerTons1__CustomerReview:
		return soap_out_PointerToPointerTons1__CustomerReview(soap, tag, id, (ns1__CustomerReview **const*)ptr, "ns1:CustomerReview");
	case SOAP_TYPE_PointerTons1__CustomerReview:
		return soap_out_PointerTons1__CustomerReview(soap, tag, id, (ns1__CustomerReview *const*)ptr, "ns1:CustomerReview");
	case SOAP_TYPE_PointerToPointerTons1__Track:
		return soap_out_PointerToPointerTons1__Track(soap, tag, id, (ns1__Track **const*)ptr, "ns1:Track");
	case SOAP_TYPE_PointerTons1__Track:
		return soap_out_PointerTons1__Track(soap, tag, id, (ns1__Track *const*)ptr, "ns1:Track");
	case SOAP_TYPE_PointerToPointerTons1__BrowseNode:
		return soap_out_PointerToPointerTons1__BrowseNode(soap, tag, id, (ns1__BrowseNode **const*)ptr, "ns1:BrowseNode");
	case SOAP_TYPE_PointerTons1__BrowseNode:
		return soap_out_PointerTons1__BrowseNode(soap, tag, id, (ns1__BrowseNode *const*)ptr, "ns1:BrowseNode");
	case SOAP_TYPE_PointerToPointerTons1__KeyPhrase:
		return soap_out_PointerToPointerTons1__KeyPhrase(soap, tag, id, (ns1__KeyPhrase **const*)ptr, "ns1:KeyPhrase");
	case SOAP_TYPE_PointerTons1__KeyPhrase:
		return soap_out_PointerTons1__KeyPhrase(soap, tag, id, (ns1__KeyPhrase *const*)ptr, "ns1:KeyPhrase");
	case SOAP_TYPE_PointerToPointerTons1__Details:
		return soap_out_PointerToPointerTons1__Details(soap, tag, id, (ns1__Details **const*)ptr, "ns1:Details");
	case SOAP_TYPE_PointerTons1__Details:
		return soap_out_PointerTons1__Details(soap, tag, id, (ns1__Details *const*)ptr, "ns1:Details");
	case SOAP_TYPE_PointerToPointerTons1__ProductLine:
		return soap_out_PointerToPointerTons1__ProductLine(soap, tag, id, (ns1__ProductLine **const*)ptr, "ns1:ProductLine");
	case SOAP_TYPE_PointerTons1__ProductLine:
		return soap_out_PointerTons1__ProductLine(soap, tag, id, (ns1__ProductLine *const*)ptr, "ns1:ProductLine");
	case SOAP_TYPE_PointerToItemQuantityArray:
		return soap_out_PointerToItemQuantityArray(soap, tag, id, (ItemQuantityArray *const*)ptr, "ns1:ItemQuantity");
	case SOAP_TYPE_PointerToItemIdArray:
		return soap_out_PointerToItemIdArray(soap, tag, id, (ItemIdArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToAddItemArray:
		return soap_out_PointerToAddItemArray(soap, tag, id, (AddItemArray *const*)ptr, "ns1:AddItem");
	case SOAP_TYPE_PointerToItemArray:
		return soap_out_PointerToItemArray(soap, tag, id, (ItemArray *const*)ptr, "ns1:Item");
	case SOAP_TYPE_PointerToThirdPartyProductDetailsArray:
		return soap_out_PointerToThirdPartyProductDetailsArray(soap, tag, id, (ThirdPartyProductDetailsArray *const*)ptr, "ns1:ThirdPartyProductDetails");
	case SOAP_TYPE_PointerToFeedbackArray:
		return soap_out_PointerToFeedbackArray(soap, tag, id, (FeedbackArray *const*)ptr, "ns1:Feedback");
	case SOAP_TYPE_PointerToListingProductDetailsArray:
		return soap_out_PointerToListingProductDetailsArray(soap, tag, id, (ListingProductDetailsArray *const*)ptr, "ns1:ListingProductDetails");
	case SOAP_TYPE_PointerTons1__SellerFeedback:
		return soap_out_PointerTons1__SellerFeedback(soap, tag, id, (ns1__SellerFeedback *const*)ptr, "ns1:SellerFeedback");
	case SOAP_TYPE_PointerTons1__ListingProductInfo:
		return soap_out_PointerTons1__ListingProductInfo(soap, tag, id, (ns1__ListingProductInfo *const*)ptr, "ns1:ListingProductInfo");
	case SOAP_TYPE_PointerToSellerSearchDetailsArray:
		return soap_out_PointerToSellerSearchDetailsArray(soap, tag, id, (SellerSearchDetailsArray *const*)ptr, "ns1:SellerSearchDetails");
	case SOAP_TYPE_PointerToSellerProfileDetailsArray:
		return soap_out_PointerToSellerProfileDetailsArray(soap, tag, id, (SellerProfileDetailsArray *const*)ptr, "ns1:SellerProfileDetails");
	case SOAP_TYPE_PointerToMarketplaceSearchDetailsArray:
		return soap_out_PointerToMarketplaceSearchDetailsArray(soap, tag, id, (MarketplaceSearchDetailsArray *const*)ptr, "ns1:MarketplaceSearchDetails");
	case SOAP_TYPE_PointerToCustomerReviewArray:
		return soap_out_PointerToCustomerReviewArray(soap, tag, id, (CustomerReviewArray *const*)ptr, "ns1:CustomerReview");
	case SOAP_TYPE_PointerToListArray:
		return soap_out_PointerToListArray(soap, tag, id, (ListArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToSimilarProductsArray:
		return soap_out_PointerToSimilarProductsArray(soap, tag, id, (SimilarProductsArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__Reviews:
		return soap_out_PointerTons1__Reviews(soap, tag, id, (ns1__Reviews *const*)ptr, "ns1:Reviews");
	case SOAP_TYPE_PointerToPlatformArray:
		return soap_out_PointerToPlatformArray(soap, tag, id, (PlatformArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToAccessoryArray:
		return soap_out_PointerToAccessoryArray(soap, tag, id, (AccessoryArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToTrackArray:
		return soap_out_PointerToTrackArray(soap, tag, id, (TrackArray *const*)ptr, "ns1:Track");
	case SOAP_TYPE_PointerToFeaturesArray:
		return soap_out_PointerToFeaturesArray(soap, tag, id, (FeaturesArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToBrowseNodeArray:
		return soap_out_PointerToBrowseNodeArray(soap, tag, id, (BrowseNodeArray *const*)ptr, "ns1:BrowseNode");
	case SOAP_TYPE_PointerTons1__ThirdPartyProductInfo:
		return soap_out_PointerTons1__ThirdPartyProductInfo(soap, tag, id, (ns1__ThirdPartyProductInfo *const*)ptr, "ns1:ThirdPartyProductInfo");
	case SOAP_TYPE_PointerToDirectorArray:
		return soap_out_PointerToDirectorArray(soap, tag, id, (DirectorArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToStarringArray:
		return soap_out_PointerToStarringArray(soap, tag, id, (StarringArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToAuthorArray:
		return soap_out_PointerToAuthorArray(soap, tag, id, (AuthorArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToArtistArray:
		return soap_out_PointerToArtistArray(soap, tag, id, (ArtistArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToKeyPhraseArray:
		return soap_out_PointerToKeyPhraseArray(soap, tag, id, (KeyPhraseArray *const*)ptr, "ns1:KeyPhrase");
	case SOAP_TYPE_PointerToDetailsArray:
		return soap_out_PointerToDetailsArray(soap, tag, id, (DetailsArray *const*)ptr, "ns1:Details");
	case SOAP_TYPE_PointerTons1__ProductInfo:
		return soap_out_PointerTons1__ProductInfo(soap, tag, id, (ns1__ProductInfo *const*)ptr, "ns1:ProductInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest:
		((ns1__ModifyShoppingCartItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest:
		((ns1__RemoveShoppingCartItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest:
		((ns1__AddShoppingCartItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ClearShoppingCartRequest:
		((ns1__ClearShoppingCartRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetShoppingCartRequest:
		((ns1__GetShoppingCartRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ShoppingCart:
		((ns1__ShoppingCart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AddItem:
		((ns1__AddItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_AddItemArray:
		((AddItemArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ItemQuantity:
		((ns1__ItemQuantity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ItemQuantityArray:
		((ItemQuantityArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Item:
		((ns1__Item *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ItemArray:
		((ItemArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ItemIdArray:
		((ItemIdArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SimilarityRequest:
		((ns1__SimilarityRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellerRequest:
		((ns1__SellerRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellerProfileRequest:
		((ns1__SellerProfileRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MarketplaceRequest:
		((ns1__MarketplaceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__WishlistRequest:
		((ns1__WishlistRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListManiaRequest:
		((ns1__ListManiaRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ManufacturerRequest:
		((ns1__ManufacturerRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ExchangeRequest:
		((ns1__ExchangeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DirectorRequest:
		((ns1__DirectorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ActorRequest:
		((ns1__ActorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AuthorRequest:
		((ns1__AuthorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArtistRequest:
		((ns1__ArtistRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UpcRequest:
		((ns1__UpcRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BlendedRequest:
		((ns1__BlendedRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AsinRequest:
		((ns1__AsinRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BrowseNodeRequest:
		((ns1__BrowseNodeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PowerRequest:
		((ns1__PowerRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__KeywordRequest:
		((ns1__KeywordRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ThirdPartyProductDetails:
		((ns1__ThirdPartyProductDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ThirdPartyProductDetailsArray:
		((ThirdPartyProductDetailsArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ThirdPartyProductInfo:
		((ns1__ThirdPartyProductInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Feedback:
		((ns1__Feedback *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FeedbackArray:
		((FeedbackArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellerFeedback:
		((ns1__SellerFeedback *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListingProductDetails:
		((ns1__ListingProductDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ListingProductDetailsArray:
		((ListingProductDetailsArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListingProductInfo:
		((ns1__ListingProductInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_SellerSearchDetailsArray:
		((SellerSearchDetailsArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellerSearchDetails:
		((ns1__SellerSearchDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_SellerProfileDetailsArray:
		((SellerProfileDetailsArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellerProfileDetails:
		((ns1__SellerProfileDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MarketplaceSearchDetailsArray:
		((MarketplaceSearchDetailsArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MarketplaceSearchDetails:
		((ns1__MarketplaceSearchDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellerSearch:
		((ns1__SellerSearch *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellerProfile:
		((ns1__SellerProfile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MarketplaceSearch:
		((ns1__MarketplaceSearch *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ListArray:
		((ListArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_SimilarProductsArray:
		((SimilarProductsArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CustomerReview:
		((ns1__CustomerReview *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CustomerReviewArray:
		((CustomerReviewArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Reviews:
		((ns1__Reviews *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_PlatformArray:
		((PlatformArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_AccessoryArray:
		((AccessoryArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Track:
		((ns1__Track *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrackArray:
		((TrackArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_FeaturesArray:
		((FeaturesArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BrowseNode:
		((ns1__BrowseNode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_BrowseNodeArray:
		((BrowseNodeArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DirectorArray:
		((DirectorArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_StarringArray:
		((StarringArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_AuthorArray:
		((AuthorArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArtistArray:
		((ArtistArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__KeyPhrase:
		((ns1__KeyPhrase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_KeyPhraseArray:
		((KeyPhraseArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Details:
		((ns1__Details *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DetailsArray:
		((DetailsArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ProductInfo:
		((ns1__ProductInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ProductLine:
		((ns1__ProductLine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ProductLineArray:
		((ProductLineArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_:
		soap_serialize_ns1__ModifyShoppingCartItemsRequest_(soap, (const struct ns1__ModifyShoppingCartItemsRequest_ *)ptr);
		break;
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse:
		soap_serialize_ns1__ModifyShoppingCartItemsRequestResponse(soap, (const struct ns1__ModifyShoppingCartItemsRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_:
		soap_serialize_ns1__RemoveShoppingCartItemsRequest_(soap, (const struct ns1__RemoveShoppingCartItemsRequest_ *)ptr);
		break;
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse:
		soap_serialize_ns1__RemoveShoppingCartItemsRequestResponse(soap, (const struct ns1__RemoveShoppingCartItemsRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest_:
		soap_serialize_ns1__AddShoppingCartItemsRequest_(soap, (const struct ns1__AddShoppingCartItemsRequest_ *)ptr);
		break;
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse:
		soap_serialize_ns1__AddShoppingCartItemsRequestResponse(soap, (const struct ns1__AddShoppingCartItemsRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ClearShoppingCartRequest_:
		soap_serialize_ns1__ClearShoppingCartRequest_(soap, (const struct ns1__ClearShoppingCartRequest_ *)ptr);
		break;
	case SOAP_TYPE_ns1__ClearShoppingCartRequestResponse:
		soap_serialize_ns1__ClearShoppingCartRequestResponse(soap, (const struct ns1__ClearShoppingCartRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetShoppingCartRequest_:
		soap_serialize_ns1__GetShoppingCartRequest_(soap, (const struct ns1__GetShoppingCartRequest_ *)ptr);
		break;
	case SOAP_TYPE_ns1__GetShoppingCartRequestResponse:
		soap_serialize_ns1__GetShoppingCartRequestResponse(soap, (const struct ns1__GetShoppingCartRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SimilaritySearchRequest:
		soap_serialize_ns1__SimilaritySearchRequest(soap, (const struct ns1__SimilaritySearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__SimilaritySearchRequestResponse:
		soap_serialize_ns1__SimilaritySearchRequestResponse(soap, (const struct ns1__SimilaritySearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__MarketplaceSearchRequest:
		soap_serialize_ns1__MarketplaceSearchRequest(soap, (const struct ns1__MarketplaceSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__MarketplaceSearchRequestResponse:
		soap_serialize_ns1__MarketplaceSearchRequestResponse(soap, (const struct ns1__MarketplaceSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SellerSearchRequest:
		soap_serialize_ns1__SellerSearchRequest(soap, (const struct ns1__SellerSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__SellerSearchRequestResponse:
		soap_serialize_ns1__SellerSearchRequestResponse(soap, (const struct ns1__SellerSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SellerProfileSearchRequest:
		soap_serialize_ns1__SellerProfileSearchRequest(soap, (const struct ns1__SellerProfileSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__SellerProfileSearchRequestResponse:
		soap_serialize_ns1__SellerProfileSearchRequestResponse(soap, (const struct ns1__SellerProfileSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__WishlistSearchRequest:
		soap_serialize_ns1__WishlistSearchRequest(soap, (const struct ns1__WishlistSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__WishlistSearchRequestResponse:
		soap_serialize_ns1__WishlistSearchRequestResponse(soap, (const struct ns1__WishlistSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ListManiaSearchRequest:
		soap_serialize_ns1__ListManiaSearchRequest(soap, (const struct ns1__ListManiaSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ListManiaSearchRequestResponse:
		soap_serialize_ns1__ListManiaSearchRequestResponse(soap, (const struct ns1__ListManiaSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ExchangeSearchRequest:
		soap_serialize_ns1__ExchangeSearchRequest(soap, (const struct ns1__ExchangeSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ExchangeSearchRequestResponse:
		soap_serialize_ns1__ExchangeSearchRequestResponse(soap, (const struct ns1__ExchangeSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DirectorSearchRequest:
		soap_serialize_ns1__DirectorSearchRequest(soap, (const struct ns1__DirectorSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__DirectorSearchRequestResponse:
		soap_serialize_ns1__DirectorSearchRequestResponse(soap, (const struct ns1__DirectorSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ManufacturerSearchRequest:
		soap_serialize_ns1__ManufacturerSearchRequest(soap, (const struct ns1__ManufacturerSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ManufacturerSearchRequestResponse:
		soap_serialize_ns1__ManufacturerSearchRequestResponse(soap, (const struct ns1__ManufacturerSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ActorSearchRequest:
		soap_serialize_ns1__ActorSearchRequest(soap, (const struct ns1__ActorSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ActorSearchRequestResponse:
		soap_serialize_ns1__ActorSearchRequestResponse(soap, (const struct ns1__ActorSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ArtistSearchRequest:
		soap_serialize_ns1__ArtistSearchRequest(soap, (const struct ns1__ArtistSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ArtistSearchRequestResponse:
		soap_serialize_ns1__ArtistSearchRequestResponse(soap, (const struct ns1__ArtistSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__AuthorSearchRequest:
		soap_serialize_ns1__AuthorSearchRequest(soap, (const struct ns1__AuthorSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__AuthorSearchRequestResponse:
		soap_serialize_ns1__AuthorSearchRequestResponse(soap, (const struct ns1__AuthorSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UpcSearchRequest:
		soap_serialize_ns1__UpcSearchRequest(soap, (const struct ns1__UpcSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__UpcSearchRequestResponse:
		soap_serialize_ns1__UpcSearchRequestResponse(soap, (const struct ns1__UpcSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__BlendedSearchRequest:
		soap_serialize_ns1__BlendedSearchRequest(soap, (const struct ns1__BlendedSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__BlendedSearchRequestResponse:
		soap_serialize_ns1__BlendedSearchRequestResponse(soap, (const struct ns1__BlendedSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__AsinSearchRequest:
		soap_serialize_ns1__AsinSearchRequest(soap, (const struct ns1__AsinSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__AsinSearchRequestResponse:
		soap_serialize_ns1__AsinSearchRequestResponse(soap, (const struct ns1__AsinSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__BrowseNodeSearchRequest:
		soap_serialize_ns1__BrowseNodeSearchRequest(soap, (const struct ns1__BrowseNodeSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse:
		soap_serialize_ns1__BrowseNodeSearchRequestResponse(soap, (const struct ns1__BrowseNodeSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__PowerSearchRequest:
		soap_serialize_ns1__PowerSearchRequest(soap, (const struct ns1__PowerSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__PowerSearchRequestResponse:
		soap_serialize_ns1__PowerSearchRequestResponse(soap, (const struct ns1__PowerSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__KeywordSearchRequest:
		soap_serialize_ns1__KeywordSearchRequest(soap, (const struct ns1__KeywordSearchRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__KeywordSearchRequestResponse:
		soap_serialize_ns1__KeywordSearchRequestResponse(soap, (const struct ns1__KeywordSearchRequestResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ModifyShoppingCartItemsRequest:
		soap_serialize_PointerTons1__ModifyShoppingCartItemsRequest(soap, (ns1__ModifyShoppingCartItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RemoveShoppingCartItemsRequest:
		soap_serialize_PointerTons1__RemoveShoppingCartItemsRequest(soap, (ns1__RemoveShoppingCartItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AddShoppingCartItemsRequest:
		soap_serialize_PointerTons1__AddShoppingCartItemsRequest(soap, (ns1__AddShoppingCartItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ClearShoppingCartRequest:
		soap_serialize_PointerTons1__ClearShoppingCartRequest(soap, (ns1__ClearShoppingCartRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetShoppingCartRequest:
		soap_serialize_PointerTons1__GetShoppingCartRequest(soap, (ns1__GetShoppingCartRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ShoppingCart:
		soap_serialize_PointerTons1__ShoppingCart(soap, (ns1__ShoppingCart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SimilarityRequest:
		soap_serialize_PointerTons1__SimilarityRequest(soap, (ns1__SimilarityRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MarketplaceRequest:
		soap_serialize_PointerTons1__MarketplaceRequest(soap, (ns1__MarketplaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MarketplaceSearch:
		soap_serialize_PointerTons1__MarketplaceSearch(soap, (ns1__MarketplaceSearch *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellerRequest:
		soap_serialize_PointerTons1__SellerRequest(soap, (ns1__SellerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellerSearch:
		soap_serialize_PointerTons1__SellerSearch(soap, (ns1__SellerSearch *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellerProfileRequest:
		soap_serialize_PointerTons1__SellerProfileRequest(soap, (ns1__SellerProfileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellerProfile:
		soap_serialize_PointerTons1__SellerProfile(soap, (ns1__SellerProfile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__WishlistRequest:
		soap_serialize_PointerTons1__WishlistRequest(soap, (ns1__WishlistRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListManiaRequest:
		soap_serialize_PointerTons1__ListManiaRequest(soap, (ns1__ListManiaRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExchangeRequest:
		soap_serialize_PointerTons1__ExchangeRequest(soap, (ns1__ExchangeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DirectorRequest:
		soap_serialize_PointerTons1__DirectorRequest(soap, (ns1__DirectorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ManufacturerRequest:
		soap_serialize_PointerTons1__ManufacturerRequest(soap, (ns1__ManufacturerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ActorRequest:
		soap_serialize_PointerTons1__ActorRequest(soap, (ns1__ActorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArtistRequest:
		soap_serialize_PointerTons1__ArtistRequest(soap, (ns1__ArtistRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuthorRequest:
		soap_serialize_PointerTons1__AuthorRequest(soap, (ns1__AuthorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UpcRequest:
		soap_serialize_PointerTons1__UpcRequest(soap, (ns1__UpcRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BlendedRequest:
		soap_serialize_PointerTons1__BlendedRequest(soap, (ns1__BlendedRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToProductLineArray:
		soap_serialize_PointerToProductLineArray(soap, (ProductLineArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AsinRequest:
		soap_serialize_PointerTons1__AsinRequest(soap, (ns1__AsinRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BrowseNodeRequest:
		soap_serialize_PointerTons1__BrowseNodeRequest(soap, (ns1__BrowseNodeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PowerRequest:
		soap_serialize_PointerTons1__PowerRequest(soap, (ns1__PowerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__KeywordRequest:
		soap_serialize_PointerTons1__KeywordRequest(soap, (ns1__KeywordRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AddItem:
		soap_serialize_PointerToPointerTons1__AddItem(soap, (ns1__AddItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AddItem:
		soap_serialize_PointerTons1__AddItem(soap, (ns1__AddItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ItemQuantity:
		soap_serialize_PointerToPointerTons1__ItemQuantity(soap, (ns1__ItemQuantity **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemQuantity:
		soap_serialize_PointerTons1__ItemQuantity(soap, (ns1__ItemQuantity *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Item:
		soap_serialize_PointerToPointerTons1__Item(soap, (ns1__Item **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Item:
		soap_serialize_PointerTons1__Item(soap, (ns1__Item *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ThirdPartyProductDetails:
		soap_serialize_PointerToPointerTons1__ThirdPartyProductDetails(soap, (ns1__ThirdPartyProductDetails **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ThirdPartyProductDetails:
		soap_serialize_PointerTons1__ThirdPartyProductDetails(soap, (ns1__ThirdPartyProductDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Feedback:
		soap_serialize_PointerToPointerTons1__Feedback(soap, (ns1__Feedback **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Feedback:
		soap_serialize_PointerTons1__Feedback(soap, (ns1__Feedback *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ListingProductDetails:
		soap_serialize_PointerToPointerTons1__ListingProductDetails(soap, (ns1__ListingProductDetails **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListingProductDetails:
		soap_serialize_PointerTons1__ListingProductDetails(soap, (ns1__ListingProductDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SellerSearchDetails:
		soap_serialize_PointerToPointerTons1__SellerSearchDetails(soap, (ns1__SellerSearchDetails **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellerSearchDetails:
		soap_serialize_PointerTons1__SellerSearchDetails(soap, (ns1__SellerSearchDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SellerProfileDetails:
		soap_serialize_PointerToPointerTons1__SellerProfileDetails(soap, (ns1__SellerProfileDetails **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellerProfileDetails:
		soap_serialize_PointerTons1__SellerProfileDetails(soap, (ns1__SellerProfileDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MarketplaceSearchDetails:
		soap_serialize_PointerToPointerTons1__MarketplaceSearchDetails(soap, (ns1__MarketplaceSearchDetails **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MarketplaceSearchDetails:
		soap_serialize_PointerTons1__MarketplaceSearchDetails(soap, (ns1__MarketplaceSearchDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CustomerReview:
		soap_serialize_PointerToPointerTons1__CustomerReview(soap, (ns1__CustomerReview **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CustomerReview:
		soap_serialize_PointerTons1__CustomerReview(soap, (ns1__CustomerReview *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Track:
		soap_serialize_PointerToPointerTons1__Track(soap, (ns1__Track **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Track:
		soap_serialize_PointerTons1__Track(soap, (ns1__Track *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__BrowseNode:
		soap_serialize_PointerToPointerTons1__BrowseNode(soap, (ns1__BrowseNode **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BrowseNode:
		soap_serialize_PointerTons1__BrowseNode(soap, (ns1__BrowseNode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__KeyPhrase:
		soap_serialize_PointerToPointerTons1__KeyPhrase(soap, (ns1__KeyPhrase **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__KeyPhrase:
		soap_serialize_PointerTons1__KeyPhrase(soap, (ns1__KeyPhrase *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Details:
		soap_serialize_PointerToPointerTons1__Details(soap, (ns1__Details **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Details:
		soap_serialize_PointerTons1__Details(soap, (ns1__Details *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ProductLine:
		soap_serialize_PointerToPointerTons1__ProductLine(soap, (ns1__ProductLine **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProductLine:
		soap_serialize_PointerTons1__ProductLine(soap, (ns1__ProductLine *const*)ptr);
		break;
	case SOAP_TYPE_PointerToItemQuantityArray:
		soap_serialize_PointerToItemQuantityArray(soap, (ItemQuantityArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToItemIdArray:
		soap_serialize_PointerToItemIdArray(soap, (ItemIdArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToAddItemArray:
		soap_serialize_PointerToAddItemArray(soap, (AddItemArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToItemArray:
		soap_serialize_PointerToItemArray(soap, (ItemArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToThirdPartyProductDetailsArray:
		soap_serialize_PointerToThirdPartyProductDetailsArray(soap, (ThirdPartyProductDetailsArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToFeedbackArray:
		soap_serialize_PointerToFeedbackArray(soap, (FeedbackArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToListingProductDetailsArray:
		soap_serialize_PointerToListingProductDetailsArray(soap, (ListingProductDetailsArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellerFeedback:
		soap_serialize_PointerTons1__SellerFeedback(soap, (ns1__SellerFeedback *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListingProductInfo:
		soap_serialize_PointerTons1__ListingProductInfo(soap, (ns1__ListingProductInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSellerSearchDetailsArray:
		soap_serialize_PointerToSellerSearchDetailsArray(soap, (SellerSearchDetailsArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSellerProfileDetailsArray:
		soap_serialize_PointerToSellerProfileDetailsArray(soap, (SellerProfileDetailsArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMarketplaceSearchDetailsArray:
		soap_serialize_PointerToMarketplaceSearchDetailsArray(soap, (MarketplaceSearchDetailsArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCustomerReviewArray:
		soap_serialize_PointerToCustomerReviewArray(soap, (CustomerReviewArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToListArray:
		soap_serialize_PointerToListArray(soap, (ListArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSimilarProductsArray:
		soap_serialize_PointerToSimilarProductsArray(soap, (SimilarProductsArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Reviews:
		soap_serialize_PointerTons1__Reviews(soap, (ns1__Reviews *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPlatformArray:
		soap_serialize_PointerToPlatformArray(soap, (PlatformArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToAccessoryArray:
		soap_serialize_PointerToAccessoryArray(soap, (AccessoryArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrackArray:
		soap_serialize_PointerToTrackArray(soap, (TrackArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToFeaturesArray:
		soap_serialize_PointerToFeaturesArray(soap, (FeaturesArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToBrowseNodeArray:
		soap_serialize_PointerToBrowseNodeArray(soap, (BrowseNodeArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ThirdPartyProductInfo:
		soap_serialize_PointerTons1__ThirdPartyProductInfo(soap, (ns1__ThirdPartyProductInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDirectorArray:
		soap_serialize_PointerToDirectorArray(soap, (DirectorArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToStarringArray:
		soap_serialize_PointerToStarringArray(soap, (StarringArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToAuthorArray:
		soap_serialize_PointerToAuthorArray(soap, (AuthorArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArtistArray:
		soap_serialize_PointerToArtistArray(soap, (ArtistArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToKeyPhraseArray:
		soap_serialize_PointerToKeyPhraseArray(soap, (KeyPhraseArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDetailsArray:
		soap_serialize_PointerToDetailsArray(soap, (DetailsArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProductInfo:
		soap_serialize_PointerTons1__ProductInfo(soap, (ns1__ProductInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProductLine:
		return (void*)soap_instantiate_ns1__ProductLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProductInfo:
		return (void*)soap_instantiate_ns1__ProductInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Details:
		return (void*)soap_instantiate_ns1__Details(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__KeyPhrase:
		return (void*)soap_instantiate_ns1__KeyPhrase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BrowseNode:
		return (void*)soap_instantiate_ns1__BrowseNode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Track:
		return (void*)soap_instantiate_ns1__Track(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Reviews:
		return (void*)soap_instantiate_ns1__Reviews(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CustomerReview:
		return (void*)soap_instantiate_ns1__CustomerReview(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MarketplaceSearch:
		return (void*)soap_instantiate_ns1__MarketplaceSearch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerProfile:
		return (void*)soap_instantiate_ns1__SellerProfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerSearch:
		return (void*)soap_instantiate_ns1__SellerSearch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MarketplaceSearchDetails:
		return (void*)soap_instantiate_ns1__MarketplaceSearchDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerProfileDetails:
		return (void*)soap_instantiate_ns1__SellerProfileDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerSearchDetails:
		return (void*)soap_instantiate_ns1__SellerSearchDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListingProductInfo:
		return (void*)soap_instantiate_ns1__ListingProductInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListingProductDetails:
		return (void*)soap_instantiate_ns1__ListingProductDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerFeedback:
		return (void*)soap_instantiate_ns1__SellerFeedback(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Feedback:
		return (void*)soap_instantiate_ns1__Feedback(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ThirdPartyProductInfo:
		return (void*)soap_instantiate_ns1__ThirdPartyProductInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ThirdPartyProductDetails:
		return (void*)soap_instantiate_ns1__ThirdPartyProductDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__KeywordRequest:
		return (void*)soap_instantiate_ns1__KeywordRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PowerRequest:
		return (void*)soap_instantiate_ns1__PowerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BrowseNodeRequest:
		return (void*)soap_instantiate_ns1__BrowseNodeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AsinRequest:
		return (void*)soap_instantiate_ns1__AsinRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BlendedRequest:
		return (void*)soap_instantiate_ns1__BlendedRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpcRequest:
		return (void*)soap_instantiate_ns1__UpcRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArtistRequest:
		return (void*)soap_instantiate_ns1__ArtistRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AuthorRequest:
		return (void*)soap_instantiate_ns1__AuthorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActorRequest:
		return (void*)soap_instantiate_ns1__ActorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DirectorRequest:
		return (void*)soap_instantiate_ns1__DirectorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExchangeRequest:
		return (void*)soap_instantiate_ns1__ExchangeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ManufacturerRequest:
		return (void*)soap_instantiate_ns1__ManufacturerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListManiaRequest:
		return (void*)soap_instantiate_ns1__ListManiaRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WishlistRequest:
		return (void*)soap_instantiate_ns1__WishlistRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MarketplaceRequest:
		return (void*)soap_instantiate_ns1__MarketplaceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerProfileRequest:
		return (void*)soap_instantiate_ns1__SellerProfileRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerRequest:
		return (void*)soap_instantiate_ns1__SellerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SimilarityRequest:
		return (void*)soap_instantiate_ns1__SimilarityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Item:
		return (void*)soap_instantiate_ns1__Item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemQuantity:
		return (void*)soap_instantiate_ns1__ItemQuantity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddItem:
		return (void*)soap_instantiate_ns1__AddItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ShoppingCart:
		return (void*)soap_instantiate_ns1__ShoppingCart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetShoppingCartRequest:
		return (void*)soap_instantiate_ns1__GetShoppingCartRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearShoppingCartRequest:
		return (void*)soap_instantiate_ns1__ClearShoppingCartRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest:
		return (void*)soap_instantiate_ns1__AddShoppingCartItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest:
		return (void*)soap_instantiate_ns1__RemoveShoppingCartItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest:
		return (void*)soap_instantiate_ns1__ModifyShoppingCartItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ProductLineArray:
		return (void*)soap_instantiate_ProductLineArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DetailsArray:
		return (void*)soap_instantiate_DetailsArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_KeyPhraseArray:
		return (void*)soap_instantiate_KeyPhraseArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArtistArray:
		return (void*)soap_instantiate_ArtistArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_AuthorArray:
		return (void*)soap_instantiate_AuthorArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_StarringArray:
		return (void*)soap_instantiate_StarringArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DirectorArray:
		return (void*)soap_instantiate_DirectorArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_BrowseNodeArray:
		return (void*)soap_instantiate_BrowseNodeArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FeaturesArray:
		return (void*)soap_instantiate_FeaturesArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrackArray:
		return (void*)soap_instantiate_TrackArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_AccessoryArray:
		return (void*)soap_instantiate_AccessoryArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_PlatformArray:
		return (void*)soap_instantiate_PlatformArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CustomerReviewArray:
		return (void*)soap_instantiate_CustomerReviewArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SimilarProductsArray:
		return (void*)soap_instantiate_SimilarProductsArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ListArray:
		return (void*)soap_instantiate_ListArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MarketplaceSearchDetailsArray:
		return (void*)soap_instantiate_MarketplaceSearchDetailsArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SellerProfileDetailsArray:
		return (void*)soap_instantiate_SellerProfileDetailsArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SellerSearchDetailsArray:
		return (void*)soap_instantiate_SellerSearchDetailsArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ListingProductDetailsArray:
		return (void*)soap_instantiate_ListingProductDetailsArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FeedbackArray:
		return (void*)soap_instantiate_FeedbackArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ThirdPartyProductDetailsArray:
		return (void*)soap_instantiate_ThirdPartyProductDetailsArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ItemIdArray:
		return (void*)soap_instantiate_ItemIdArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ItemArray:
		return (void*)soap_instantiate_ItemArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ItemQuantityArray:
		return (void*)soap_instantiate_ItemQuantityArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_AddItemArray:
		return (void*)soap_instantiate_AddItemArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__KeywordSearchRequestResponse:
		return (void*)soap_instantiate_ns1__KeywordSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__KeywordSearchRequest:
		return (void*)soap_instantiate_ns1__KeywordSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PowerSearchRequestResponse:
		return (void*)soap_instantiate_ns1__PowerSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PowerSearchRequest:
		return (void*)soap_instantiate_ns1__PowerSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse:
		return (void*)soap_instantiate_ns1__BrowseNodeSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BrowseNodeSearchRequest:
		return (void*)soap_instantiate_ns1__BrowseNodeSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AsinSearchRequestResponse:
		return (void*)soap_instantiate_ns1__AsinSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AsinSearchRequest:
		return (void*)soap_instantiate_ns1__AsinSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BlendedSearchRequestResponse:
		return (void*)soap_instantiate_ns1__BlendedSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BlendedSearchRequest:
		return (void*)soap_instantiate_ns1__BlendedSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpcSearchRequestResponse:
		return (void*)soap_instantiate_ns1__UpcSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpcSearchRequest:
		return (void*)soap_instantiate_ns1__UpcSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AuthorSearchRequestResponse:
		return (void*)soap_instantiate_ns1__AuthorSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AuthorSearchRequest:
		return (void*)soap_instantiate_ns1__AuthorSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArtistSearchRequestResponse:
		return (void*)soap_instantiate_ns1__ArtistSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArtistSearchRequest:
		return (void*)soap_instantiate_ns1__ArtistSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActorSearchRequestResponse:
		return (void*)soap_instantiate_ns1__ActorSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActorSearchRequest:
		return (void*)soap_instantiate_ns1__ActorSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ManufacturerSearchRequestResponse:
		return (void*)soap_instantiate_ns1__ManufacturerSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ManufacturerSearchRequest:
		return (void*)soap_instantiate_ns1__ManufacturerSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DirectorSearchRequestResponse:
		return (void*)soap_instantiate_ns1__DirectorSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DirectorSearchRequest:
		return (void*)soap_instantiate_ns1__DirectorSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExchangeSearchRequestResponse:
		return (void*)soap_instantiate_ns1__ExchangeSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExchangeSearchRequest:
		return (void*)soap_instantiate_ns1__ExchangeSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListManiaSearchRequestResponse:
		return (void*)soap_instantiate_ns1__ListManiaSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListManiaSearchRequest:
		return (void*)soap_instantiate_ns1__ListManiaSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WishlistSearchRequestResponse:
		return (void*)soap_instantiate_ns1__WishlistSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WishlistSearchRequest:
		return (void*)soap_instantiate_ns1__WishlistSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerProfileSearchRequestResponse:
		return (void*)soap_instantiate_ns1__SellerProfileSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerProfileSearchRequest:
		return (void*)soap_instantiate_ns1__SellerProfileSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerSearchRequestResponse:
		return (void*)soap_instantiate_ns1__SellerSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellerSearchRequest:
		return (void*)soap_instantiate_ns1__SellerSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MarketplaceSearchRequestResponse:
		return (void*)soap_instantiate_ns1__MarketplaceSearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MarketplaceSearchRequest:
		return (void*)soap_instantiate_ns1__MarketplaceSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SimilaritySearchRequestResponse:
		return (void*)soap_instantiate_ns1__SimilaritySearchRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SimilaritySearchRequest:
		return (void*)soap_instantiate_ns1__SimilaritySearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetShoppingCartRequestResponse:
		return (void*)soap_instantiate_ns1__GetShoppingCartRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetShoppingCartRequest_:
		return (void*)soap_instantiate_ns1__GetShoppingCartRequest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearShoppingCartRequestResponse:
		return (void*)soap_instantiate_ns1__ClearShoppingCartRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearShoppingCartRequest_:
		return (void*)soap_instantiate_ns1__ClearShoppingCartRequest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse:
		return (void*)soap_instantiate_ns1__AddShoppingCartItemsRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest_:
		return (void*)soap_instantiate_ns1__AddShoppingCartItemsRequest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse:
		return (void*)soap_instantiate_ns1__RemoveShoppingCartItemsRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_:
		return (void*)soap_instantiate_ns1__RemoveShoppingCartItemsRequest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse:
		return (void*)soap_instantiate_ns1__ModifyShoppingCartItemsRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_:
		return (void*)soap_instantiate_ns1__ModifyShoppingCartItemsRequest_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ProductLine:
		if (p->size < 0)
			delete (ns1__ProductLine*)p->ptr;
		else
			delete[] (ns1__ProductLine*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ProductInfo:
		if (p->size < 0)
			delete (ns1__ProductInfo*)p->ptr;
		else
			delete[] (ns1__ProductInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Details:
		if (p->size < 0)
			delete (ns1__Details*)p->ptr;
		else
			delete[] (ns1__Details*)p->ptr;
		break;
	case SOAP_TYPE_ns1__KeyPhrase:
		if (p->size < 0)
			delete (ns1__KeyPhrase*)p->ptr;
		else
			delete[] (ns1__KeyPhrase*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BrowseNode:
		if (p->size < 0)
			delete (ns1__BrowseNode*)p->ptr;
		else
			delete[] (ns1__BrowseNode*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Track:
		if (p->size < 0)
			delete (ns1__Track*)p->ptr;
		else
			delete[] (ns1__Track*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Reviews:
		if (p->size < 0)
			delete (ns1__Reviews*)p->ptr;
		else
			delete[] (ns1__Reviews*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CustomerReview:
		if (p->size < 0)
			delete (ns1__CustomerReview*)p->ptr;
		else
			delete[] (ns1__CustomerReview*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MarketplaceSearch:
		if (p->size < 0)
			delete (ns1__MarketplaceSearch*)p->ptr;
		else
			delete[] (ns1__MarketplaceSearch*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerProfile:
		if (p->size < 0)
			delete (ns1__SellerProfile*)p->ptr;
		else
			delete[] (ns1__SellerProfile*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerSearch:
		if (p->size < 0)
			delete (ns1__SellerSearch*)p->ptr;
		else
			delete[] (ns1__SellerSearch*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MarketplaceSearchDetails:
		if (p->size < 0)
			delete (ns1__MarketplaceSearchDetails*)p->ptr;
		else
			delete[] (ns1__MarketplaceSearchDetails*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerProfileDetails:
		if (p->size < 0)
			delete (ns1__SellerProfileDetails*)p->ptr;
		else
			delete[] (ns1__SellerProfileDetails*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerSearchDetails:
		if (p->size < 0)
			delete (ns1__SellerSearchDetails*)p->ptr;
		else
			delete[] (ns1__SellerSearchDetails*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ListingProductInfo:
		if (p->size < 0)
			delete (ns1__ListingProductInfo*)p->ptr;
		else
			delete[] (ns1__ListingProductInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ListingProductDetails:
		if (p->size < 0)
			delete (ns1__ListingProductDetails*)p->ptr;
		else
			delete[] (ns1__ListingProductDetails*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerFeedback:
		if (p->size < 0)
			delete (ns1__SellerFeedback*)p->ptr;
		else
			delete[] (ns1__SellerFeedback*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Feedback:
		if (p->size < 0)
			delete (ns1__Feedback*)p->ptr;
		else
			delete[] (ns1__Feedback*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ThirdPartyProductInfo:
		if (p->size < 0)
			delete (ns1__ThirdPartyProductInfo*)p->ptr;
		else
			delete[] (ns1__ThirdPartyProductInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ThirdPartyProductDetails:
		if (p->size < 0)
			delete (ns1__ThirdPartyProductDetails*)p->ptr;
		else
			delete[] (ns1__ThirdPartyProductDetails*)p->ptr;
		break;
	case SOAP_TYPE_ns1__KeywordRequest:
		if (p->size < 0)
			delete (ns1__KeywordRequest*)p->ptr;
		else
			delete[] (ns1__KeywordRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PowerRequest:
		if (p->size < 0)
			delete (ns1__PowerRequest*)p->ptr;
		else
			delete[] (ns1__PowerRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BrowseNodeRequest:
		if (p->size < 0)
			delete (ns1__BrowseNodeRequest*)p->ptr;
		else
			delete[] (ns1__BrowseNodeRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AsinRequest:
		if (p->size < 0)
			delete (ns1__AsinRequest*)p->ptr;
		else
			delete[] (ns1__AsinRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BlendedRequest:
		if (p->size < 0)
			delete (ns1__BlendedRequest*)p->ptr;
		else
			delete[] (ns1__BlendedRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UpcRequest:
		if (p->size < 0)
			delete (ns1__UpcRequest*)p->ptr;
		else
			delete[] (ns1__UpcRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArtistRequest:
		if (p->size < 0)
			delete (ns1__ArtistRequest*)p->ptr;
		else
			delete[] (ns1__ArtistRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AuthorRequest:
		if (p->size < 0)
			delete (ns1__AuthorRequest*)p->ptr;
		else
			delete[] (ns1__AuthorRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ActorRequest:
		if (p->size < 0)
			delete (ns1__ActorRequest*)p->ptr;
		else
			delete[] (ns1__ActorRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DirectorRequest:
		if (p->size < 0)
			delete (ns1__DirectorRequest*)p->ptr;
		else
			delete[] (ns1__DirectorRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ExchangeRequest:
		if (p->size < 0)
			delete (ns1__ExchangeRequest*)p->ptr;
		else
			delete[] (ns1__ExchangeRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ManufacturerRequest:
		if (p->size < 0)
			delete (ns1__ManufacturerRequest*)p->ptr;
		else
			delete[] (ns1__ManufacturerRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ListManiaRequest:
		if (p->size < 0)
			delete (ns1__ListManiaRequest*)p->ptr;
		else
			delete[] (ns1__ListManiaRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__WishlistRequest:
		if (p->size < 0)
			delete (ns1__WishlistRequest*)p->ptr;
		else
			delete[] (ns1__WishlistRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MarketplaceRequest:
		if (p->size < 0)
			delete (ns1__MarketplaceRequest*)p->ptr;
		else
			delete[] (ns1__MarketplaceRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerProfileRequest:
		if (p->size < 0)
			delete (ns1__SellerProfileRequest*)p->ptr;
		else
			delete[] (ns1__SellerProfileRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerRequest:
		if (p->size < 0)
			delete (ns1__SellerRequest*)p->ptr;
		else
			delete[] (ns1__SellerRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SimilarityRequest:
		if (p->size < 0)
			delete (ns1__SimilarityRequest*)p->ptr;
		else
			delete[] (ns1__SimilarityRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Item:
		if (p->size < 0)
			delete (ns1__Item*)p->ptr;
		else
			delete[] (ns1__Item*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemQuantity:
		if (p->size < 0)
			delete (ns1__ItemQuantity*)p->ptr;
		else
			delete[] (ns1__ItemQuantity*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AddItem:
		if (p->size < 0)
			delete (ns1__AddItem*)p->ptr;
		else
			delete[] (ns1__AddItem*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ShoppingCart:
		if (p->size < 0)
			delete (ns1__ShoppingCart*)p->ptr;
		else
			delete[] (ns1__ShoppingCart*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GetShoppingCartRequest:
		if (p->size < 0)
			delete (ns1__GetShoppingCartRequest*)p->ptr;
		else
			delete[] (ns1__GetShoppingCartRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ClearShoppingCartRequest:
		if (p->size < 0)
			delete (ns1__ClearShoppingCartRequest*)p->ptr;
		else
			delete[] (ns1__ClearShoppingCartRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest:
		if (p->size < 0)
			delete (ns1__AddShoppingCartItemsRequest*)p->ptr;
		else
			delete[] (ns1__AddShoppingCartItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest:
		if (p->size < 0)
			delete (ns1__RemoveShoppingCartItemsRequest*)p->ptr;
		else
			delete[] (ns1__RemoveShoppingCartItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest:
		if (p->size < 0)
			delete (ns1__ModifyShoppingCartItemsRequest*)p->ptr;
		else
			delete[] (ns1__ModifyShoppingCartItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE_ProductLineArray:
		if (p->size < 0)
			delete (ProductLineArray*)p->ptr;
		else
			delete[] (ProductLineArray*)p->ptr;
		break;
	case SOAP_TYPE_DetailsArray:
		if (p->size < 0)
			delete (DetailsArray*)p->ptr;
		else
			delete[] (DetailsArray*)p->ptr;
		break;
	case SOAP_TYPE_KeyPhraseArray:
		if (p->size < 0)
			delete (KeyPhraseArray*)p->ptr;
		else
			delete[] (KeyPhraseArray*)p->ptr;
		break;
	case SOAP_TYPE_ArtistArray:
		if (p->size < 0)
			delete (ArtistArray*)p->ptr;
		else
			delete[] (ArtistArray*)p->ptr;
		break;
	case SOAP_TYPE_AuthorArray:
		if (p->size < 0)
			delete (AuthorArray*)p->ptr;
		else
			delete[] (AuthorArray*)p->ptr;
		break;
	case SOAP_TYPE_StarringArray:
		if (p->size < 0)
			delete (StarringArray*)p->ptr;
		else
			delete[] (StarringArray*)p->ptr;
		break;
	case SOAP_TYPE_DirectorArray:
		if (p->size < 0)
			delete (DirectorArray*)p->ptr;
		else
			delete[] (DirectorArray*)p->ptr;
		break;
	case SOAP_TYPE_BrowseNodeArray:
		if (p->size < 0)
			delete (BrowseNodeArray*)p->ptr;
		else
			delete[] (BrowseNodeArray*)p->ptr;
		break;
	case SOAP_TYPE_FeaturesArray:
		if (p->size < 0)
			delete (FeaturesArray*)p->ptr;
		else
			delete[] (FeaturesArray*)p->ptr;
		break;
	case SOAP_TYPE_TrackArray:
		if (p->size < 0)
			delete (TrackArray*)p->ptr;
		else
			delete[] (TrackArray*)p->ptr;
		break;
	case SOAP_TYPE_AccessoryArray:
		if (p->size < 0)
			delete (AccessoryArray*)p->ptr;
		else
			delete[] (AccessoryArray*)p->ptr;
		break;
	case SOAP_TYPE_PlatformArray:
		if (p->size < 0)
			delete (PlatformArray*)p->ptr;
		else
			delete[] (PlatformArray*)p->ptr;
		break;
	case SOAP_TYPE_CustomerReviewArray:
		if (p->size < 0)
			delete (CustomerReviewArray*)p->ptr;
		else
			delete[] (CustomerReviewArray*)p->ptr;
		break;
	case SOAP_TYPE_SimilarProductsArray:
		if (p->size < 0)
			delete (SimilarProductsArray*)p->ptr;
		else
			delete[] (SimilarProductsArray*)p->ptr;
		break;
	case SOAP_TYPE_ListArray:
		if (p->size < 0)
			delete (ListArray*)p->ptr;
		else
			delete[] (ListArray*)p->ptr;
		break;
	case SOAP_TYPE_MarketplaceSearchDetailsArray:
		if (p->size < 0)
			delete (MarketplaceSearchDetailsArray*)p->ptr;
		else
			delete[] (MarketplaceSearchDetailsArray*)p->ptr;
		break;
	case SOAP_TYPE_SellerProfileDetailsArray:
		if (p->size < 0)
			delete (SellerProfileDetailsArray*)p->ptr;
		else
			delete[] (SellerProfileDetailsArray*)p->ptr;
		break;
	case SOAP_TYPE_SellerSearchDetailsArray:
		if (p->size < 0)
			delete (SellerSearchDetailsArray*)p->ptr;
		else
			delete[] (SellerSearchDetailsArray*)p->ptr;
		break;
	case SOAP_TYPE_ListingProductDetailsArray:
		if (p->size < 0)
			delete (ListingProductDetailsArray*)p->ptr;
		else
			delete[] (ListingProductDetailsArray*)p->ptr;
		break;
	case SOAP_TYPE_FeedbackArray:
		if (p->size < 0)
			delete (FeedbackArray*)p->ptr;
		else
			delete[] (FeedbackArray*)p->ptr;
		break;
	case SOAP_TYPE_ThirdPartyProductDetailsArray:
		if (p->size < 0)
			delete (ThirdPartyProductDetailsArray*)p->ptr;
		else
			delete[] (ThirdPartyProductDetailsArray*)p->ptr;
		break;
	case SOAP_TYPE_ItemIdArray:
		if (p->size < 0)
			delete (ItemIdArray*)p->ptr;
		else
			delete[] (ItemIdArray*)p->ptr;
		break;
	case SOAP_TYPE_ItemArray:
		if (p->size < 0)
			delete (ItemArray*)p->ptr;
		else
			delete[] (ItemArray*)p->ptr;
		break;
	case SOAP_TYPE_ItemQuantityArray:
		if (p->size < 0)
			delete (ItemQuantityArray*)p->ptr;
		else
			delete[] (ItemQuantityArray*)p->ptr;
		break;
	case SOAP_TYPE_AddItemArray:
		if (p->size < 0)
			delete (AddItemArray*)p->ptr;
		else
			delete[] (AddItemArray*)p->ptr;
		break;
	case SOAP_TYPE_ns1__KeywordSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__KeywordSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__KeywordSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__KeywordSearchRequest:
		if (p->size < 0)
			delete (struct ns1__KeywordSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__KeywordSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PowerSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__PowerSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__PowerSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PowerSearchRequest:
		if (p->size < 0)
			delete (struct ns1__PowerSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__PowerSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__BrowseNodeSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__BrowseNodeSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BrowseNodeSearchRequest:
		if (p->size < 0)
			delete (struct ns1__BrowseNodeSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__BrowseNodeSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AsinSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__AsinSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__AsinSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AsinSearchRequest:
		if (p->size < 0)
			delete (struct ns1__AsinSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__AsinSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BlendedSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__BlendedSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__BlendedSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BlendedSearchRequest:
		if (p->size < 0)
			delete (struct ns1__BlendedSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__BlendedSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UpcSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__UpcSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__UpcSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UpcSearchRequest:
		if (p->size < 0)
			delete (struct ns1__UpcSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__UpcSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AuthorSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__AuthorSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__AuthorSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AuthorSearchRequest:
		if (p->size < 0)
			delete (struct ns1__AuthorSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__AuthorSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArtistSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__ArtistSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__ArtistSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArtistSearchRequest:
		if (p->size < 0)
			delete (struct ns1__ArtistSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__ArtistSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ActorSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__ActorSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__ActorSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ActorSearchRequest:
		if (p->size < 0)
			delete (struct ns1__ActorSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__ActorSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ManufacturerSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__ManufacturerSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__ManufacturerSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ManufacturerSearchRequest:
		if (p->size < 0)
			delete (struct ns1__ManufacturerSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__ManufacturerSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DirectorSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__DirectorSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__DirectorSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DirectorSearchRequest:
		if (p->size < 0)
			delete (struct ns1__DirectorSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__DirectorSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ExchangeSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__ExchangeSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__ExchangeSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ExchangeSearchRequest:
		if (p->size < 0)
			delete (struct ns1__ExchangeSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__ExchangeSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ListManiaSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__ListManiaSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__ListManiaSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ListManiaSearchRequest:
		if (p->size < 0)
			delete (struct ns1__ListManiaSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__ListManiaSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__WishlistSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__WishlistSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__WishlistSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__WishlistSearchRequest:
		if (p->size < 0)
			delete (struct ns1__WishlistSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__WishlistSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerProfileSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__SellerProfileSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__SellerProfileSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerProfileSearchRequest:
		if (p->size < 0)
			delete (struct ns1__SellerProfileSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__SellerProfileSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__SellerSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__SellerSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SellerSearchRequest:
		if (p->size < 0)
			delete (struct ns1__SellerSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__SellerSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MarketplaceSearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__MarketplaceSearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__MarketplaceSearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MarketplaceSearchRequest:
		if (p->size < 0)
			delete (struct ns1__MarketplaceSearchRequest*)p->ptr;
		else
			delete[] (struct ns1__MarketplaceSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SimilaritySearchRequestResponse:
		if (p->size < 0)
			delete (struct ns1__SimilaritySearchRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__SimilaritySearchRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SimilaritySearchRequest:
		if (p->size < 0)
			delete (struct ns1__SimilaritySearchRequest*)p->ptr;
		else
			delete[] (struct ns1__SimilaritySearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GetShoppingCartRequestResponse:
		if (p->size < 0)
			delete (struct ns1__GetShoppingCartRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__GetShoppingCartRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GetShoppingCartRequest_:
		if (p->size < 0)
			delete (struct ns1__GetShoppingCartRequest_*)p->ptr;
		else
			delete[] (struct ns1__GetShoppingCartRequest_*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ClearShoppingCartRequestResponse:
		if (p->size < 0)
			delete (struct ns1__ClearShoppingCartRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__ClearShoppingCartRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ClearShoppingCartRequest_:
		if (p->size < 0)
			delete (struct ns1__ClearShoppingCartRequest_*)p->ptr;
		else
			delete[] (struct ns1__ClearShoppingCartRequest_*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse:
		if (p->size < 0)
			delete (struct ns1__AddShoppingCartItemsRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__AddShoppingCartItemsRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AddShoppingCartItemsRequest_:
		if (p->size < 0)
			delete (struct ns1__AddShoppingCartItemsRequest_*)p->ptr;
		else
			delete[] (struct ns1__AddShoppingCartItemsRequest_*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse:
		if (p->size < 0)
			delete (struct ns1__RemoveShoppingCartItemsRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__RemoveShoppingCartItemsRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_:
		if (p->size < 0)
			delete (struct ns1__RemoveShoppingCartItemsRequest_*)p->ptr;
		else
			delete[] (struct ns1__RemoveShoppingCartItemsRequest_*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse:
		if (p->size < 0)
			delete (struct ns1__ModifyShoppingCartItemsRequestResponse*)p->ptr;
		else
			delete[] (struct ns1__ModifyShoppingCartItemsRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_:
		if (p->size < 0)
			delete (struct ns1__ModifyShoppingCartItemsRequest_*)p->ptr;
		else
			delete[] (struct ns1__ModifyShoppingCartItemsRequest_*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns1__ModifyShoppingCartItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::tag);
	soap_default_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::devtag);
	soap_default_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::CartId);
	soap_default_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::HMAC);
	this->ns1__ModifyShoppingCartItemsRequest::Items = NULL;
	this->ns1__ModifyShoppingCartItemsRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__ModifyShoppingCartItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ModifyShoppingCartItemsRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::tag);
	soap_embedded(soap, &this->ns1__ModifyShoppingCartItemsRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::devtag);
	soap_embedded(soap, &this->ns1__ModifyShoppingCartItemsRequest::CartId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::CartId);
	soap_embedded(soap, &this->ns1__ModifyShoppingCartItemsRequest::HMAC, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::HMAC);
	soap_serialize_PointerToItemQuantityArray(soap, &this->ns1__ModifyShoppingCartItemsRequest::Items);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ModifyShoppingCartItemsRequest::locale);
	/* transient soap skipped */
}

int ns1__ModifyShoppingCartItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ModifyShoppingCartItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ModifyShoppingCartItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ModifyShoppingCartItemsRequest(struct soap *soap, const char *tag, int id, const ns1__ModifyShoppingCartItemsRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__ModifyShoppingCartItemsRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__ModifyShoppingCartItemsRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "CartId", -1, &(a->ns1__ModifyShoppingCartItemsRequest::CartId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "HMAC", -1, &(a->ns1__ModifyShoppingCartItemsRequest::HMAC), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToItemQuantityArray(soap, "Items", -1, &(a->ns1__ModifyShoppingCartItemsRequest::Items), "ns1:ItemQuantity"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__ModifyShoppingCartItemsRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ModifyShoppingCartItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ModifyShoppingCartItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ModifyShoppingCartItemsRequest * SOAP_FMAC4 soap_get_ns1__ModifyShoppingCartItemsRequest(struct soap *soap, ns1__ModifyShoppingCartItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ModifyShoppingCartItemsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ModifyShoppingCartItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ModifyShoppingCartItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ModifyShoppingCartItemsRequest * SOAP_FMAC4 soap_in_ns1__ModifyShoppingCartItemsRequest(struct soap *soap, const char *tag, ns1__ModifyShoppingCartItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ModifyShoppingCartItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest, sizeof(ns1__ModifyShoppingCartItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ModifyShoppingCartItemsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_CartId1 = 1;
	size_t soap_flag_HMAC1 = 1;
	size_t soap_flag_Items1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__ModifyShoppingCartItemsRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__ModifyShoppingCartItemsRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_CartId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CartId", &(a->ns1__ModifyShoppingCartItemsRequest::CartId), "xsd:string"))
				{	soap_flag_CartId1--;
					continue;
				}
			if (soap_flag_HMAC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HMAC", &(a->ns1__ModifyShoppingCartItemsRequest::HMAC), "xsd:string"))
				{	soap_flag_HMAC1--;
					continue;
				}
			if (soap_flag_Items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToItemQuantityArray(soap, "Items", &(a->ns1__ModifyShoppingCartItemsRequest::Items), "ns1:ItemQuantity"))
				{	soap_flag_Items1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__ModifyShoppingCartItemsRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ModifyShoppingCartItemsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest, 0, sizeof(ns1__ModifyShoppingCartItemsRequest), 0, soap_copy_ns1__ModifyShoppingCartItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tag1 > 0 || soap_flag_devtag1 > 0 || soap_flag_CartId1 > 0 || soap_flag_HMAC1 > 0 || soap_flag_Items1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ModifyShoppingCartItemsRequest * SOAP_FMAC6 soap_new_ns1__ModifyShoppingCartItemsRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ModifyShoppingCartItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ModifyShoppingCartItemsRequest(struct soap *soap, ns1__ModifyShoppingCartItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ModifyShoppingCartItemsRequest * SOAP_FMAC4 soap_instantiate_ns1__ModifyShoppingCartItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ModifyShoppingCartItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ModifyShoppingCartItemsRequest;
		if (size)
			*size = sizeof(ns1__ModifyShoppingCartItemsRequest);
		((ns1__ModifyShoppingCartItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ModifyShoppingCartItemsRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ModifyShoppingCartItemsRequest);
		for (int i = 0; i < n; i++)
			((ns1__ModifyShoppingCartItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ModifyShoppingCartItemsRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ModifyShoppingCartItemsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ModifyShoppingCartItemsRequest %p -> %p\n", q, p));
	*(ns1__ModifyShoppingCartItemsRequest*)p = *(ns1__ModifyShoppingCartItemsRequest*)q;
}

void ns1__RemoveShoppingCartItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::tag);
	soap_default_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::devtag);
	soap_default_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::CartId);
	soap_default_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::HMAC);
	this->ns1__RemoveShoppingCartItemsRequest::Items = NULL;
	this->ns1__RemoveShoppingCartItemsRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__RemoveShoppingCartItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__RemoveShoppingCartItemsRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::tag);
	soap_embedded(soap, &this->ns1__RemoveShoppingCartItemsRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::devtag);
	soap_embedded(soap, &this->ns1__RemoveShoppingCartItemsRequest::CartId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::CartId);
	soap_embedded(soap, &this->ns1__RemoveShoppingCartItemsRequest::HMAC, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::HMAC);
	soap_serialize_PointerToItemIdArray(soap, &this->ns1__RemoveShoppingCartItemsRequest::Items);
	soap_serialize_PointerTostd__string(soap, &this->ns1__RemoveShoppingCartItemsRequest::locale);
	/* transient soap skipped */
}

int ns1__RemoveShoppingCartItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__RemoveShoppingCartItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RemoveShoppingCartItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemoveShoppingCartItemsRequest(struct soap *soap, const char *tag, int id, const ns1__RemoveShoppingCartItemsRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__RemoveShoppingCartItemsRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__RemoveShoppingCartItemsRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "CartId", -1, &(a->ns1__RemoveShoppingCartItemsRequest::CartId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "HMAC", -1, &(a->ns1__RemoveShoppingCartItemsRequest::HMAC), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToItemIdArray(soap, "Items", -1, &(a->ns1__RemoveShoppingCartItemsRequest::Items), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__RemoveShoppingCartItemsRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__RemoveShoppingCartItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RemoveShoppingCartItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RemoveShoppingCartItemsRequest * SOAP_FMAC4 soap_get_ns1__RemoveShoppingCartItemsRequest(struct soap *soap, ns1__RemoveShoppingCartItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemoveShoppingCartItemsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__RemoveShoppingCartItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RemoveShoppingCartItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RemoveShoppingCartItemsRequest * SOAP_FMAC4 soap_in_ns1__RemoveShoppingCartItemsRequest(struct soap *soap, const char *tag, ns1__RemoveShoppingCartItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RemoveShoppingCartItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest, sizeof(ns1__RemoveShoppingCartItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RemoveShoppingCartItemsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_CartId1 = 1;
	size_t soap_flag_HMAC1 = 1;
	size_t soap_flag_Items1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__RemoveShoppingCartItemsRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__RemoveShoppingCartItemsRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_CartId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CartId", &(a->ns1__RemoveShoppingCartItemsRequest::CartId), "xsd:string"))
				{	soap_flag_CartId1--;
					continue;
				}
			if (soap_flag_HMAC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HMAC", &(a->ns1__RemoveShoppingCartItemsRequest::HMAC), "xsd:string"))
				{	soap_flag_HMAC1--;
					continue;
				}
			if (soap_flag_Items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToItemIdArray(soap, "Items", &(a->ns1__RemoveShoppingCartItemsRequest::Items), "xsd:string"))
				{	soap_flag_Items1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__RemoveShoppingCartItemsRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RemoveShoppingCartItemsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest, 0, sizeof(ns1__RemoveShoppingCartItemsRequest), 0, soap_copy_ns1__RemoveShoppingCartItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tag1 > 0 || soap_flag_devtag1 > 0 || soap_flag_CartId1 > 0 || soap_flag_HMAC1 > 0 || soap_flag_Items1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RemoveShoppingCartItemsRequest * SOAP_FMAC6 soap_new_ns1__RemoveShoppingCartItemsRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__RemoveShoppingCartItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RemoveShoppingCartItemsRequest(struct soap *soap, ns1__RemoveShoppingCartItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__RemoveShoppingCartItemsRequest * SOAP_FMAC4 soap_instantiate_ns1__RemoveShoppingCartItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemoveShoppingCartItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RemoveShoppingCartItemsRequest;
		if (size)
			*size = sizeof(ns1__RemoveShoppingCartItemsRequest);
		((ns1__RemoveShoppingCartItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RemoveShoppingCartItemsRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RemoveShoppingCartItemsRequest);
		for (int i = 0; i < n; i++)
			((ns1__RemoveShoppingCartItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RemoveShoppingCartItemsRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RemoveShoppingCartItemsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RemoveShoppingCartItemsRequest %p -> %p\n", q, p));
	*(ns1__RemoveShoppingCartItemsRequest*)p = *(ns1__RemoveShoppingCartItemsRequest*)q;
}

void ns1__AddShoppingCartItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__AddShoppingCartItemsRequest::tag);
	soap_default_std__string(soap, &this->ns1__AddShoppingCartItemsRequest::devtag);
	this->ns1__AddShoppingCartItemsRequest::CartId = NULL;
	this->ns1__AddShoppingCartItemsRequest::HMAC = NULL;
	this->ns1__AddShoppingCartItemsRequest::Items = NULL;
	this->ns1__AddShoppingCartItemsRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__AddShoppingCartItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__AddShoppingCartItemsRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AddShoppingCartItemsRequest::tag);
	soap_embedded(soap, &this->ns1__AddShoppingCartItemsRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AddShoppingCartItemsRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AddShoppingCartItemsRequest::CartId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AddShoppingCartItemsRequest::HMAC);
	soap_serialize_PointerToAddItemArray(soap, &this->ns1__AddShoppingCartItemsRequest::Items);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AddShoppingCartItemsRequest::locale);
	/* transient soap skipped */
}

int ns1__AddShoppingCartItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AddShoppingCartItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AddShoppingCartItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AddShoppingCartItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddShoppingCartItemsRequest(struct soap *soap, const char *tag, int id, const ns1__AddShoppingCartItemsRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddShoppingCartItemsRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__AddShoppingCartItemsRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__AddShoppingCartItemsRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CartId", -1, &(a->ns1__AddShoppingCartItemsRequest::CartId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "HMAC", -1, &(a->ns1__AddShoppingCartItemsRequest::HMAC), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToAddItemArray(soap, "Items", -1, &(a->ns1__AddShoppingCartItemsRequest::Items), "ns1:AddItem"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__AddShoppingCartItemsRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AddShoppingCartItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AddShoppingCartItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AddShoppingCartItemsRequest * SOAP_FMAC4 soap_get_ns1__AddShoppingCartItemsRequest(struct soap *soap, ns1__AddShoppingCartItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddShoppingCartItemsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__AddShoppingCartItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AddShoppingCartItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AddShoppingCartItemsRequest * SOAP_FMAC4 soap_in_ns1__AddShoppingCartItemsRequest(struct soap *soap, const char *tag, ns1__AddShoppingCartItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AddShoppingCartItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddShoppingCartItemsRequest, sizeof(ns1__AddShoppingCartItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AddShoppingCartItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AddShoppingCartItemsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_CartId1 = 1;
	size_t soap_flag_HMAC1 = 1;
	size_t soap_flag_Items1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__AddShoppingCartItemsRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__AddShoppingCartItemsRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_CartId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CartId", &(a->ns1__AddShoppingCartItemsRequest::CartId), "xsd:string"))
				{	soap_flag_CartId1--;
					continue;
				}
			if (soap_flag_HMAC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "HMAC", &(a->ns1__AddShoppingCartItemsRequest::HMAC), "xsd:string"))
				{	soap_flag_HMAC1--;
					continue;
				}
			if (soap_flag_Items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToAddItemArray(soap, "Items", &(a->ns1__AddShoppingCartItemsRequest::Items), "ns1:AddItem"))
				{	soap_flag_Items1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__AddShoppingCartItemsRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AddShoppingCartItemsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddShoppingCartItemsRequest, 0, sizeof(ns1__AddShoppingCartItemsRequest), 0, soap_copy_ns1__AddShoppingCartItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tag1 > 0 || soap_flag_devtag1 > 0 || soap_flag_Items1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AddShoppingCartItemsRequest * SOAP_FMAC6 soap_new_ns1__AddShoppingCartItemsRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__AddShoppingCartItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AddShoppingCartItemsRequest(struct soap *soap, ns1__AddShoppingCartItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AddShoppingCartItemsRequest * SOAP_FMAC4 soap_instantiate_ns1__AddShoppingCartItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddShoppingCartItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AddShoppingCartItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AddShoppingCartItemsRequest;
		if (size)
			*size = sizeof(ns1__AddShoppingCartItemsRequest);
		((ns1__AddShoppingCartItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AddShoppingCartItemsRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AddShoppingCartItemsRequest);
		for (int i = 0; i < n; i++)
			((ns1__AddShoppingCartItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AddShoppingCartItemsRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AddShoppingCartItemsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AddShoppingCartItemsRequest %p -> %p\n", q, p));
	*(ns1__AddShoppingCartItemsRequest*)p = *(ns1__AddShoppingCartItemsRequest*)q;
}

void ns1__ClearShoppingCartRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ClearShoppingCartRequest::tag);
	soap_default_std__string(soap, &this->ns1__ClearShoppingCartRequest::devtag);
	soap_default_std__string(soap, &this->ns1__ClearShoppingCartRequest::CartId);
	soap_default_std__string(soap, &this->ns1__ClearShoppingCartRequest::HMAC);
	this->ns1__ClearShoppingCartRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__ClearShoppingCartRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ClearShoppingCartRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ClearShoppingCartRequest::tag);
	soap_embedded(soap, &this->ns1__ClearShoppingCartRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ClearShoppingCartRequest::devtag);
	soap_embedded(soap, &this->ns1__ClearShoppingCartRequest::CartId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ClearShoppingCartRequest::CartId);
	soap_embedded(soap, &this->ns1__ClearShoppingCartRequest::HMAC, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ClearShoppingCartRequest::HMAC);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ClearShoppingCartRequest::locale);
	/* transient soap skipped */
}

int ns1__ClearShoppingCartRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ClearShoppingCartRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ClearShoppingCartRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ClearShoppingCartRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearShoppingCartRequest(struct soap *soap, const char *tag, int id, const ns1__ClearShoppingCartRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearShoppingCartRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__ClearShoppingCartRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__ClearShoppingCartRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "CartId", -1, &(a->ns1__ClearShoppingCartRequest::CartId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "HMAC", -1, &(a->ns1__ClearShoppingCartRequest::HMAC), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__ClearShoppingCartRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ClearShoppingCartRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ClearShoppingCartRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ClearShoppingCartRequest * SOAP_FMAC4 soap_get_ns1__ClearShoppingCartRequest(struct soap *soap, ns1__ClearShoppingCartRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearShoppingCartRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ClearShoppingCartRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ClearShoppingCartRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ClearShoppingCartRequest * SOAP_FMAC4 soap_in_ns1__ClearShoppingCartRequest(struct soap *soap, const char *tag, ns1__ClearShoppingCartRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ClearShoppingCartRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearShoppingCartRequest, sizeof(ns1__ClearShoppingCartRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ClearShoppingCartRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ClearShoppingCartRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_CartId1 = 1;
	size_t soap_flag_HMAC1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__ClearShoppingCartRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__ClearShoppingCartRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_CartId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CartId", &(a->ns1__ClearShoppingCartRequest::CartId), "xsd:string"))
				{	soap_flag_CartId1--;
					continue;
				}
			if (soap_flag_HMAC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HMAC", &(a->ns1__ClearShoppingCartRequest::HMAC), "xsd:string"))
				{	soap_flag_HMAC1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__ClearShoppingCartRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ClearShoppingCartRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearShoppingCartRequest, 0, sizeof(ns1__ClearShoppingCartRequest), 0, soap_copy_ns1__ClearShoppingCartRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tag1 > 0 || soap_flag_devtag1 > 0 || soap_flag_CartId1 > 0 || soap_flag_HMAC1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ClearShoppingCartRequest * SOAP_FMAC6 soap_new_ns1__ClearShoppingCartRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ClearShoppingCartRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ClearShoppingCartRequest(struct soap *soap, ns1__ClearShoppingCartRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ClearShoppingCartRequest * SOAP_FMAC4 soap_instantiate_ns1__ClearShoppingCartRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearShoppingCartRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ClearShoppingCartRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ClearShoppingCartRequest;
		if (size)
			*size = sizeof(ns1__ClearShoppingCartRequest);
		((ns1__ClearShoppingCartRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ClearShoppingCartRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ClearShoppingCartRequest);
		for (int i = 0; i < n; i++)
			((ns1__ClearShoppingCartRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ClearShoppingCartRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ClearShoppingCartRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ClearShoppingCartRequest %p -> %p\n", q, p));
	*(ns1__ClearShoppingCartRequest*)p = *(ns1__ClearShoppingCartRequest*)q;
}

void ns1__GetShoppingCartRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__GetShoppingCartRequest::tag);
	soap_default_std__string(soap, &this->ns1__GetShoppingCartRequest::devtag);
	soap_default_std__string(soap, &this->ns1__GetShoppingCartRequest::CartId);
	soap_default_std__string(soap, &this->ns1__GetShoppingCartRequest::HMAC);
	this->ns1__GetShoppingCartRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__GetShoppingCartRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__GetShoppingCartRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GetShoppingCartRequest::tag);
	soap_embedded(soap, &this->ns1__GetShoppingCartRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GetShoppingCartRequest::devtag);
	soap_embedded(soap, &this->ns1__GetShoppingCartRequest::CartId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GetShoppingCartRequest::CartId);
	soap_embedded(soap, &this->ns1__GetShoppingCartRequest::HMAC, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GetShoppingCartRequest::HMAC);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetShoppingCartRequest::locale);
	/* transient soap skipped */
}

int ns1__GetShoppingCartRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GetShoppingCartRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__GetShoppingCartRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetShoppingCartRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetShoppingCartRequest(struct soap *soap, const char *tag, int id, const ns1__GetShoppingCartRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetShoppingCartRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__GetShoppingCartRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__GetShoppingCartRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "CartId", -1, &(a->ns1__GetShoppingCartRequest::CartId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "HMAC", -1, &(a->ns1__GetShoppingCartRequest::HMAC), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__GetShoppingCartRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__GetShoppingCartRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetShoppingCartRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetShoppingCartRequest * SOAP_FMAC4 soap_get_ns1__GetShoppingCartRequest(struct soap *soap, ns1__GetShoppingCartRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetShoppingCartRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__GetShoppingCartRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GetShoppingCartRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetShoppingCartRequest * SOAP_FMAC4 soap_in_ns1__GetShoppingCartRequest(struct soap *soap, const char *tag, ns1__GetShoppingCartRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetShoppingCartRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetShoppingCartRequest, sizeof(ns1__GetShoppingCartRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GetShoppingCartRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GetShoppingCartRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_CartId1 = 1;
	size_t soap_flag_HMAC1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__GetShoppingCartRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__GetShoppingCartRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_CartId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CartId", &(a->ns1__GetShoppingCartRequest::CartId), "xsd:string"))
				{	soap_flag_CartId1--;
					continue;
				}
			if (soap_flag_HMAC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HMAC", &(a->ns1__GetShoppingCartRequest::HMAC), "xsd:string"))
				{	soap_flag_HMAC1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__GetShoppingCartRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetShoppingCartRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetShoppingCartRequest, 0, sizeof(ns1__GetShoppingCartRequest), 0, soap_copy_ns1__GetShoppingCartRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tag1 > 0 || soap_flag_devtag1 > 0 || soap_flag_CartId1 > 0 || soap_flag_HMAC1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__GetShoppingCartRequest * SOAP_FMAC6 soap_new_ns1__GetShoppingCartRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__GetShoppingCartRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GetShoppingCartRequest(struct soap *soap, ns1__GetShoppingCartRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__GetShoppingCartRequest * SOAP_FMAC4 soap_instantiate_ns1__GetShoppingCartRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetShoppingCartRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetShoppingCartRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__GetShoppingCartRequest;
		if (size)
			*size = sizeof(ns1__GetShoppingCartRequest);
		((ns1__GetShoppingCartRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__GetShoppingCartRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GetShoppingCartRequest);
		for (int i = 0; i < n; i++)
			((ns1__GetShoppingCartRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GetShoppingCartRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetShoppingCartRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GetShoppingCartRequest %p -> %p\n", q, p));
	*(ns1__GetShoppingCartRequest*)p = *(ns1__GetShoppingCartRequest*)q;
}

void ns1__ShoppingCart::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ShoppingCart::CartId);
	soap_default_std__string(soap, &this->ns1__ShoppingCart::HMAC);
	soap_default_std__string(soap, &this->ns1__ShoppingCart::PurchaseUrl);
	this->ns1__ShoppingCart::Items = NULL;
	/* transient soap skipped */
}

void ns1__ShoppingCart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ShoppingCart::CartId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ShoppingCart::CartId);
	soap_embedded(soap, &this->ns1__ShoppingCart::HMAC, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ShoppingCart::HMAC);
	soap_embedded(soap, &this->ns1__ShoppingCart::PurchaseUrl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ShoppingCart::PurchaseUrl);
	soap_serialize_PointerToItemArray(soap, &this->ns1__ShoppingCart::Items);
	/* transient soap skipped */
}

int ns1__ShoppingCart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ShoppingCart);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ShoppingCart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ShoppingCart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ShoppingCart(struct soap *soap, const char *tag, int id, const ns1__ShoppingCart *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ShoppingCart), type))
		return soap->error;
	if (soap_out_std__string(soap, "CartId", -1, &(a->ns1__ShoppingCart::CartId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "HMAC", -1, &(a->ns1__ShoppingCart::HMAC), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "PurchaseUrl", -1, &(a->ns1__ShoppingCart::PurchaseUrl), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToItemArray(soap, "Items", -1, &(a->ns1__ShoppingCart::Items), "ns1:Item"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ShoppingCart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ShoppingCart(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ShoppingCart * SOAP_FMAC4 soap_get_ns1__ShoppingCart(struct soap *soap, ns1__ShoppingCart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ShoppingCart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ShoppingCart(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ShoppingCart * SOAP_FMAC4 soap_in_ns1__ShoppingCart(struct soap *soap, const char *tag, ns1__ShoppingCart *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ShoppingCart *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ShoppingCart, sizeof(ns1__ShoppingCart), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ShoppingCart)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ShoppingCart *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CartId1 = 1;
	size_t soap_flag_HMAC1 = 1;
	size_t soap_flag_PurchaseUrl1 = 1;
	size_t soap_flag_Items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CartId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CartId", &(a->ns1__ShoppingCart::CartId), "xsd:string"))
				{	soap_flag_CartId1--;
					continue;
				}
			if (soap_flag_HMAC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HMAC", &(a->ns1__ShoppingCart::HMAC), "xsd:string"))
				{	soap_flag_HMAC1--;
					continue;
				}
			if (soap_flag_PurchaseUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PurchaseUrl", &(a->ns1__ShoppingCart::PurchaseUrl), "xsd:string"))
				{	soap_flag_PurchaseUrl1--;
					continue;
				}
			if (soap_flag_Items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToItemArray(soap, "Items", &(a->ns1__ShoppingCart::Items), "ns1:Item"))
				{	soap_flag_Items1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ShoppingCart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ShoppingCart, 0, sizeof(ns1__ShoppingCart), 0, soap_copy_ns1__ShoppingCart);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CartId1 > 0 || soap_flag_HMAC1 > 0 || soap_flag_PurchaseUrl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ShoppingCart * SOAP_FMAC6 soap_new_ns1__ShoppingCart(struct soap *soap, int n)
{	return soap_instantiate_ns1__ShoppingCart(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ShoppingCart(struct soap *soap, ns1__ShoppingCart *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ShoppingCart * SOAP_FMAC4 soap_instantiate_ns1__ShoppingCart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ShoppingCart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ShoppingCart, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ShoppingCart;
		if (size)
			*size = sizeof(ns1__ShoppingCart);
		((ns1__ShoppingCart*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ShoppingCart[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ShoppingCart);
		for (int i = 0; i < n; i++)
			((ns1__ShoppingCart*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ShoppingCart*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ShoppingCart(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ShoppingCart %p -> %p\n", q, p));
	*(ns1__ShoppingCart*)p = *(ns1__ShoppingCart*)q;
}

void ns1__AddItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AddItem::Asin = NULL;
	this->ns1__AddItem::ExchangeId = NULL;
	soap_default_std__string(soap, &this->ns1__AddItem::Quantity);
	/* transient soap skipped */
}

void ns1__AddItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__AddItem::Asin);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AddItem::ExchangeId);
	soap_embedded(soap, &this->ns1__AddItem::Quantity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AddItem::Quantity);
	/* transient soap skipped */
}

int ns1__AddItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AddItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AddItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AddItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddItem(struct soap *soap, const char *tag, int id, const ns1__AddItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddItem), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Asin", -1, &(a->ns1__AddItem::Asin), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeId", -1, &(a->ns1__AddItem::ExchangeId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "Quantity", -1, &(a->ns1__AddItem::Quantity), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AddItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AddItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AddItem * SOAP_FMAC4 soap_get_ns1__AddItem(struct soap *soap, ns1__AddItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__AddItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AddItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AddItem * SOAP_FMAC4 soap_in_ns1__AddItem(struct soap *soap, const char *tag, ns1__AddItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AddItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddItem, sizeof(ns1__AddItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AddItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AddItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Asin1 = 1;
	size_t soap_flag_ExchangeId1 = 1;
	size_t soap_flag_Quantity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Asin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Asin", &(a->ns1__AddItem::Asin), "xsd:string"))
				{	soap_flag_Asin1--;
					continue;
				}
			if (soap_flag_ExchangeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeId", &(a->ns1__AddItem::ExchangeId), "xsd:string"))
				{	soap_flag_ExchangeId1--;
					continue;
				}
			if (soap_flag_Quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Quantity", &(a->ns1__AddItem::Quantity), "xsd:string"))
				{	soap_flag_Quantity1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AddItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddItem, 0, sizeof(ns1__AddItem), 0, soap_copy_ns1__AddItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Quantity1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AddItem * SOAP_FMAC6 soap_new_ns1__AddItem(struct soap *soap, int n)
{	return soap_instantiate_ns1__AddItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AddItem(struct soap *soap, ns1__AddItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AddItem * SOAP_FMAC4 soap_instantiate_ns1__AddItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AddItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AddItem;
		if (size)
			*size = sizeof(ns1__AddItem);
		((ns1__AddItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AddItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AddItem);
		for (int i = 0; i < n; i++)
			((ns1__AddItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AddItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AddItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AddItem %p -> %p\n", q, p));
	*(ns1__AddItem*)p = *(ns1__AddItem*)q;
}

void AddItemArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void AddItemArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_AddItemArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AddItem(soap, this->__ptr + i);
		}
}

int AddItemArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_AddItemArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int AddItemArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_AddItemArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_AddItemArray(struct soap *soap, const char *tag, int id, const AddItemArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AddItem", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_AddItemArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AddItem(soap, "item", -1, &a->__ptr[i], "ns1:AddItem");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *AddItemArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_AddItemArray(soap, this, tag, type);
}

SOAP_FMAC3 AddItemArray * SOAP_FMAC4 soap_get_AddItemArray(struct soap *soap, AddItemArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_AddItemArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *AddItemArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_AddItemArray(soap, tag, this, type);
}

SOAP_FMAC3 AddItemArray * SOAP_FMAC4 soap_in_AddItemArray(struct soap *soap, const char *tag, AddItemArray *a, const char *type)
{	int i, j;
	ns1__AddItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (AddItemArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_AddItemArray, sizeof(AddItemArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AddItem **)soap_malloc(soap, sizeof(ns1__AddItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AddItem(soap, NULL, a->__ptr + i, "ns1:AddItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AddItem **)soap_push_block(soap, NULL, sizeof(ns1__AddItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AddItem(soap, NULL, p, "ns1:AddItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__AddItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (AddItemArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_AddItemArray, 0, sizeof(AddItemArray), 0, soap_copy_AddItemArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 AddItemArray * SOAP_FMAC6 soap_new_AddItemArray(struct soap *soap, int n)
{	return soap_instantiate_AddItemArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_AddItemArray(struct soap *soap, AddItemArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 AddItemArray * SOAP_FMAC4 soap_instantiate_AddItemArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_AddItemArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_AddItemArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new AddItemArray;
		if (size)
			*size = sizeof(AddItemArray);
		((AddItemArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new AddItemArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(AddItemArray);
		for (int i = 0; i < n; i++)
			((AddItemArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (AddItemArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_AddItemArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying AddItemArray %p -> %p\n", q, p));
	*(AddItemArray*)p = *(AddItemArray*)q;
}

void ns1__ItemQuantity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ItemQuantity::ItemId);
	soap_default_std__string(soap, &this->ns1__ItemQuantity::Quantity);
	/* transient soap skipped */
}

void ns1__ItemQuantity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ItemQuantity::ItemId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ItemQuantity::ItemId);
	soap_embedded(soap, &this->ns1__ItemQuantity::Quantity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ItemQuantity::Quantity);
	/* transient soap skipped */
}

int ns1__ItemQuantity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ItemQuantity);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ItemQuantity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemQuantity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemQuantity(struct soap *soap, const char *tag, int id, const ns1__ItemQuantity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemQuantity), type))
		return soap->error;
	if (soap_out_std__string(soap, "ItemId", -1, &(a->ns1__ItemQuantity::ItemId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "Quantity", -1, &(a->ns1__ItemQuantity::Quantity), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ItemQuantity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemQuantity(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemQuantity * SOAP_FMAC4 soap_get_ns1__ItemQuantity(struct soap *soap, ns1__ItemQuantity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemQuantity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ItemQuantity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemQuantity(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemQuantity * SOAP_FMAC4 soap_in_ns1__ItemQuantity(struct soap *soap, const char *tag, ns1__ItemQuantity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ItemQuantity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemQuantity, sizeof(ns1__ItemQuantity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ItemQuantity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ItemQuantity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ItemId1 = 1;
	size_t soap_flag_Quantity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ItemId", &(a->ns1__ItemQuantity::ItemId), "xsd:string"))
				{	soap_flag_ItemId1--;
					continue;
				}
			if (soap_flag_Quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Quantity", &(a->ns1__ItemQuantity::Quantity), "xsd:string"))
				{	soap_flag_Quantity1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ItemQuantity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ItemQuantity, 0, sizeof(ns1__ItemQuantity), 0, soap_copy_ns1__ItemQuantity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ItemId1 > 0 || soap_flag_Quantity1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemQuantity * SOAP_FMAC6 soap_new_ns1__ItemQuantity(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemQuantity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemQuantity(struct soap *soap, ns1__ItemQuantity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ItemQuantity * SOAP_FMAC4 soap_instantiate_ns1__ItemQuantity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemQuantity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemQuantity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemQuantity;
		if (size)
			*size = sizeof(ns1__ItemQuantity);
		((ns1__ItemQuantity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemQuantity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ItemQuantity);
		for (int i = 0; i < n; i++)
			((ns1__ItemQuantity*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ItemQuantity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ItemQuantity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ItemQuantity %p -> %p\n", q, p));
	*(ns1__ItemQuantity*)p = *(ns1__ItemQuantity*)q;
}

void ItemQuantityArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ItemQuantityArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ItemQuantityArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ItemQuantity(soap, this->__ptr + i);
		}
}

int ItemQuantityArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ItemQuantityArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ItemQuantityArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ItemQuantityArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ItemQuantityArray(struct soap *soap, const char *tag, int id, const ItemQuantityArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ItemQuantity", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ItemQuantityArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ItemQuantity(soap, "item", -1, &a->__ptr[i], "ns1:ItemQuantity");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ItemQuantityArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ItemQuantityArray(soap, this, tag, type);
}

SOAP_FMAC3 ItemQuantityArray * SOAP_FMAC4 soap_get_ItemQuantityArray(struct soap *soap, ItemQuantityArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ItemQuantityArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ItemQuantityArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ItemQuantityArray(soap, tag, this, type);
}

SOAP_FMAC3 ItemQuantityArray * SOAP_FMAC4 soap_in_ItemQuantityArray(struct soap *soap, const char *tag, ItemQuantityArray *a, const char *type)
{	int i, j;
	ns1__ItemQuantity **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ItemQuantityArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ItemQuantityArray, sizeof(ItemQuantityArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ItemQuantity **)soap_malloc(soap, sizeof(ns1__ItemQuantity *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ItemQuantity(soap, NULL, a->__ptr + i, "ns1:ItemQuantity"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ItemQuantity **)soap_push_block(soap, NULL, sizeof(ns1__ItemQuantity *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ItemQuantity(soap, NULL, p, "ns1:ItemQuantity"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__ItemQuantity **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ItemQuantityArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ItemQuantityArray, 0, sizeof(ItemQuantityArray), 0, soap_copy_ItemQuantityArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ItemQuantityArray * SOAP_FMAC6 soap_new_ItemQuantityArray(struct soap *soap, int n)
{	return soap_instantiate_ItemQuantityArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ItemQuantityArray(struct soap *soap, ItemQuantityArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ItemQuantityArray * SOAP_FMAC4 soap_instantiate_ItemQuantityArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ItemQuantityArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ItemQuantityArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ItemQuantityArray;
		if (size)
			*size = sizeof(ItemQuantityArray);
		((ItemQuantityArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ItemQuantityArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ItemQuantityArray);
		for (int i = 0; i < n; i++)
			((ItemQuantityArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ItemQuantityArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ItemQuantityArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ItemQuantityArray %p -> %p\n", q, p));
	*(ItemQuantityArray*)p = *(ItemQuantityArray*)q;
}

void ns1__Item::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Item::ItemId);
	soap_default_std__string(soap, &this->ns1__Item::ProductName);
	soap_default_std__string(soap, &this->ns1__Item::Catalog);
	this->ns1__Item::Asin = NULL;
	this->ns1__Item::ExchangeId = NULL;
	soap_default_std__string(soap, &this->ns1__Item::Quantity);
	this->ns1__Item::ListPrice = NULL;
	soap_default_std__string(soap, &this->ns1__Item::OurPrice);
	/* transient soap skipped */
}

void ns1__Item::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Item::ItemId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Item::ItemId);
	soap_embedded(soap, &this->ns1__Item::ProductName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Item::ProductName);
	soap_embedded(soap, &this->ns1__Item::Catalog, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Item::Catalog);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Item::Asin);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Item::ExchangeId);
	soap_embedded(soap, &this->ns1__Item::Quantity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Item::Quantity);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Item::ListPrice);
	soap_embedded(soap, &this->ns1__Item::OurPrice, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Item::OurPrice);
	/* transient soap skipped */
}

int ns1__Item::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Item);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Item::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Item(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Item(struct soap *soap, const char *tag, int id, const ns1__Item *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Item), type))
		return soap->error;
	if (soap_out_std__string(soap, "ItemId", -1, &(a->ns1__Item::ItemId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "ProductName", -1, &(a->ns1__Item::ProductName), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "Catalog", -1, &(a->ns1__Item::Catalog), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Asin", -1, &(a->ns1__Item::Asin), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeId", -1, &(a->ns1__Item::ExchangeId), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "Quantity", -1, &(a->ns1__Item::Quantity), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ListPrice", -1, &(a->ns1__Item::ListPrice), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "OurPrice", -1, &(a->ns1__Item::OurPrice), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Item::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Item(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Item * SOAP_FMAC4 soap_get_ns1__Item(struct soap *soap, ns1__Item *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Item::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Item(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Item * SOAP_FMAC4 soap_in_ns1__Item(struct soap *soap, const char *tag, ns1__Item *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Item *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Item, sizeof(ns1__Item), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Item)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Item *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ItemId1 = 1;
	size_t soap_flag_ProductName1 = 1;
	size_t soap_flag_Catalog1 = 1;
	size_t soap_flag_Asin1 = 1;
	size_t soap_flag_ExchangeId1 = 1;
	size_t soap_flag_Quantity1 = 1;
	size_t soap_flag_ListPrice1 = 1;
	size_t soap_flag_OurPrice1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ItemId", &(a->ns1__Item::ItemId), "xsd:string"))
				{	soap_flag_ItemId1--;
					continue;
				}
			if (soap_flag_ProductName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ProductName", &(a->ns1__Item::ProductName), "xsd:string"))
				{	soap_flag_ProductName1--;
					continue;
				}
			if (soap_flag_Catalog1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Catalog", &(a->ns1__Item::Catalog), "xsd:string"))
				{	soap_flag_Catalog1--;
					continue;
				}
			if (soap_flag_Asin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Asin", &(a->ns1__Item::Asin), "xsd:string"))
				{	soap_flag_Asin1--;
					continue;
				}
			if (soap_flag_ExchangeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeId", &(a->ns1__Item::ExchangeId), "xsd:string"))
				{	soap_flag_ExchangeId1--;
					continue;
				}
			if (soap_flag_Quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Quantity", &(a->ns1__Item::Quantity), "xsd:string"))
				{	soap_flag_Quantity1--;
					continue;
				}
			if (soap_flag_ListPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ListPrice", &(a->ns1__Item::ListPrice), "xsd:string"))
				{	soap_flag_ListPrice1--;
					continue;
				}
			if (soap_flag_OurPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "OurPrice", &(a->ns1__Item::OurPrice), "xsd:string"))
				{	soap_flag_OurPrice1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Item *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Item, 0, sizeof(ns1__Item), 0, soap_copy_ns1__Item);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ItemId1 > 0 || soap_flag_ProductName1 > 0 || soap_flag_Catalog1 > 0 || soap_flag_Quantity1 > 0 || soap_flag_OurPrice1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Item * SOAP_FMAC6 soap_new_ns1__Item(struct soap *soap, int n)
{	return soap_instantiate_ns1__Item(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Item(struct soap *soap, ns1__Item *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Item * SOAP_FMAC4 soap_instantiate_ns1__Item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Item, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Item;
		if (size)
			*size = sizeof(ns1__Item);
		((ns1__Item*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Item[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Item);
		for (int i = 0; i < n; i++)
			((ns1__Item*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Item*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Item(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Item %p -> %p\n", q, p));
	*(ns1__Item*)p = *(ns1__Item*)q;
}

void ItemArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ItemArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ItemArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__Item(soap, this->__ptr + i);
		}
}

int ItemArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ItemArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ItemArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ItemArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ItemArray(struct soap *soap, const char *tag, int id, const ItemArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:Item", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ItemArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Item(soap, "item", -1, &a->__ptr[i], "ns1:Item");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ItemArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ItemArray(soap, this, tag, type);
}

SOAP_FMAC3 ItemArray * SOAP_FMAC4 soap_get_ItemArray(struct soap *soap, ItemArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ItemArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ItemArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ItemArray(soap, tag, this, type);
}

SOAP_FMAC3 ItemArray * SOAP_FMAC4 soap_in_ItemArray(struct soap *soap, const char *tag, ItemArray *a, const char *type)
{	int i, j;
	ns1__Item **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ItemArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ItemArray, sizeof(ItemArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__Item **)soap_malloc(soap, sizeof(ns1__Item *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Item(soap, NULL, a->__ptr + i, "ns1:Item"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Item **)soap_push_block(soap, NULL, sizeof(ns1__Item *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Item(soap, NULL, p, "ns1:Item"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__Item **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ItemArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ItemArray, 0, sizeof(ItemArray), 0, soap_copy_ItemArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ItemArray * SOAP_FMAC6 soap_new_ItemArray(struct soap *soap, int n)
{	return soap_instantiate_ItemArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ItemArray(struct soap *soap, ItemArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ItemArray * SOAP_FMAC4 soap_instantiate_ItemArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ItemArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ItemArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ItemArray;
		if (size)
			*size = sizeof(ItemArray);
		((ItemArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ItemArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ItemArray);
		for (int i = 0; i < n; i++)
			((ItemArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ItemArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ItemArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ItemArray %p -> %p\n", q, p));
	*(ItemArray*)p = *(ItemArray*)q;
}

void ItemIdArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ItemIdArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ItemIdArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int ItemIdArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ItemIdArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ItemIdArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ItemIdArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ItemIdArray(struct soap *soap, const char *tag, int id, const ItemIdArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ItemIdArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ItemIdArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ItemIdArray(soap, this, tag, type);
}

SOAP_FMAC3 ItemIdArray * SOAP_FMAC4 soap_get_ItemIdArray(struct soap *soap, ItemIdArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ItemIdArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ItemIdArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ItemIdArray(soap, tag, this, type);
}

SOAP_FMAC3 ItemIdArray * SOAP_FMAC4 soap_in_ItemIdArray(struct soap *soap, const char *tag, ItemIdArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ItemIdArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ItemIdArray, sizeof(ItemIdArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ItemIdArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ItemIdArray, 0, sizeof(ItemIdArray), 0, soap_copy_ItemIdArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ItemIdArray * SOAP_FMAC6 soap_new_ItemIdArray(struct soap *soap, int n)
{	return soap_instantiate_ItemIdArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ItemIdArray(struct soap *soap, ItemIdArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ItemIdArray * SOAP_FMAC4 soap_instantiate_ItemIdArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ItemIdArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ItemIdArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ItemIdArray;
		if (size)
			*size = sizeof(ItemIdArray);
		((ItemIdArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ItemIdArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ItemIdArray);
		for (int i = 0; i < n; i++)
			((ItemIdArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ItemIdArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ItemIdArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ItemIdArray %p -> %p\n", q, p));
	*(ItemIdArray*)p = *(ItemIdArray*)q;
}

void ns1__SimilarityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__SimilarityRequest::asin);
	soap_default_std__string(soap, &this->ns1__SimilarityRequest::tag);
	soap_default_std__string(soap, &this->ns1__SimilarityRequest::type);
	soap_default_std__string(soap, &this->ns1__SimilarityRequest::devtag);
	this->ns1__SimilarityRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__SimilarityRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__SimilarityRequest::asin, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SimilarityRequest::asin);
	soap_embedded(soap, &this->ns1__SimilarityRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SimilarityRequest::tag);
	soap_embedded(soap, &this->ns1__SimilarityRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SimilarityRequest::type);
	soap_embedded(soap, &this->ns1__SimilarityRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SimilarityRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SimilarityRequest::locale);
	/* transient soap skipped */
}

int ns1__SimilarityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SimilarityRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SimilarityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SimilarityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SimilarityRequest(struct soap *soap, const char *tag, int id, const ns1__SimilarityRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SimilarityRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "asin", -1, &(a->ns1__SimilarityRequest::asin), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__SimilarityRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__SimilarityRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__SimilarityRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__SimilarityRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SimilarityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SimilarityRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SimilarityRequest * SOAP_FMAC4 soap_get_ns1__SimilarityRequest(struct soap *soap, ns1__SimilarityRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SimilarityRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SimilarityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SimilarityRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SimilarityRequest * SOAP_FMAC4 soap_in_ns1__SimilarityRequest(struct soap *soap, const char *tag, ns1__SimilarityRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SimilarityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SimilarityRequest, sizeof(ns1__SimilarityRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SimilarityRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SimilarityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_asin1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_asin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "asin", &(a->ns1__SimilarityRequest::asin), "xsd:string"))
				{	soap_flag_asin1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__SimilarityRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__SimilarityRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__SimilarityRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__SimilarityRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SimilarityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SimilarityRequest, 0, sizeof(ns1__SimilarityRequest), 0, soap_copy_ns1__SimilarityRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_asin1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SimilarityRequest * SOAP_FMAC6 soap_new_ns1__SimilarityRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__SimilarityRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SimilarityRequest(struct soap *soap, ns1__SimilarityRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SimilarityRequest * SOAP_FMAC4 soap_instantiate_ns1__SimilarityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SimilarityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SimilarityRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SimilarityRequest;
		if (size)
			*size = sizeof(ns1__SimilarityRequest);
		((ns1__SimilarityRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SimilarityRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SimilarityRequest);
		for (int i = 0; i < n; i++)
			((ns1__SimilarityRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SimilarityRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SimilarityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SimilarityRequest %p -> %p\n", q, p));
	*(ns1__SimilarityRequest*)p = *(ns1__SimilarityRequest*)q;
}

void ns1__SellerRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__SellerRequest::seller_USCOREid);
	soap_default_std__string(soap, &this->ns1__SellerRequest::tag);
	soap_default_std__string(soap, &this->ns1__SellerRequest::type);
	soap_default_std__string(soap, &this->ns1__SellerRequest::devtag);
	soap_default_std__string(soap, &this->ns1__SellerRequest::offerstatus);
	soap_default_std__string(soap, &this->ns1__SellerRequest::page);
	this->ns1__SellerRequest::seller_USCOREbrowse_USCOREid = NULL;
	this->ns1__SellerRequest::keyword = NULL;
	this->ns1__SellerRequest::locale = NULL;
	this->ns1__SellerRequest::index = NULL;
	/* transient soap skipped */
}

void ns1__SellerRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__SellerRequest::seller_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerRequest::seller_USCOREid);
	soap_embedded(soap, &this->ns1__SellerRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerRequest::tag);
	soap_embedded(soap, &this->ns1__SellerRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerRequest::type);
	soap_embedded(soap, &this->ns1__SellerRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerRequest::devtag);
	soap_embedded(soap, &this->ns1__SellerRequest::offerstatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerRequest::offerstatus);
	soap_embedded(soap, &this->ns1__SellerRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerRequest::page);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerRequest::seller_USCOREbrowse_USCOREid);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerRequest::keyword);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerRequest::locale);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerRequest::index);
	/* transient soap skipped */
}

int ns1__SellerRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellerRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SellerRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellerRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerRequest(struct soap *soap, const char *tag, int id, const ns1__SellerRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "seller_id", -1, &(a->ns1__SellerRequest::seller_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__SellerRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__SellerRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__SellerRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "offerstatus", -1, &(a->ns1__SellerRequest::offerstatus), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__SellerRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "seller_browse_id", -1, &(a->ns1__SellerRequest::seller_USCOREbrowse_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "keyword", -1, &(a->ns1__SellerRequest::keyword), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__SellerRequest::locale), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "index", -1, &(a->ns1__SellerRequest::index), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellerRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellerRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellerRequest * SOAP_FMAC4 soap_get_ns1__SellerRequest(struct soap *soap, ns1__SellerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SellerRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellerRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellerRequest * SOAP_FMAC4 soap_in_ns1__SellerRequest(struct soap *soap, const char *tag, ns1__SellerRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellerRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerRequest, sizeof(ns1__SellerRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellerRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellerRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_seller_USCOREid1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_offerstatus1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_seller_USCOREbrowse_USCOREid1 = 1;
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_locale1 = 1;
	size_t soap_flag_index1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_seller_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "seller_id", &(a->ns1__SellerRequest::seller_USCOREid), "xsd:string"))
				{	soap_flag_seller_USCOREid1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__SellerRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__SellerRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__SellerRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_offerstatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "offerstatus", &(a->ns1__SellerRequest::offerstatus), "xsd:string"))
				{	soap_flag_offerstatus1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__SellerRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_seller_USCOREbrowse_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "seller_browse_id", &(a->ns1__SellerRequest::seller_USCOREbrowse_USCOREid), "xsd:string"))
				{	soap_flag_seller_USCOREbrowse_USCOREid1--;
					continue;
				}
			if (soap_flag_keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "keyword", &(a->ns1__SellerRequest::keyword), "xsd:string"))
				{	soap_flag_keyword1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__SellerRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			if (soap_flag_index1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "index", &(a->ns1__SellerRequest::index), "xsd:string"))
				{	soap_flag_index1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerRequest, 0, sizeof(ns1__SellerRequest), 0, soap_copy_ns1__SellerRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_seller_USCOREid1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0 || soap_flag_offerstatus1 > 0 || soap_flag_page1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SellerRequest * SOAP_FMAC6 soap_new_ns1__SellerRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerRequest(struct soap *soap, ns1__SellerRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SellerRequest * SOAP_FMAC4 soap_instantiate_ns1__SellerRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SellerRequest;
		if (size)
			*size = sizeof(ns1__SellerRequest);
		((ns1__SellerRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SellerRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellerRequest);
		for (int i = 0; i < n; i++)
			((ns1__SellerRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellerRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellerRequest %p -> %p\n", q, p));
	*(ns1__SellerRequest*)p = *(ns1__SellerRequest*)q;
}

void ns1__SellerProfileRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__SellerProfileRequest::seller_USCOREid);
	soap_default_std__string(soap, &this->ns1__SellerProfileRequest::tag);
	soap_default_std__string(soap, &this->ns1__SellerProfileRequest::type);
	soap_default_std__string(soap, &this->ns1__SellerProfileRequest::devtag);
	soap_default_std__string(soap, &this->ns1__SellerProfileRequest::page);
	this->ns1__SellerProfileRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__SellerProfileRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__SellerProfileRequest::seller_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerProfileRequest::seller_USCOREid);
	soap_embedded(soap, &this->ns1__SellerProfileRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerProfileRequest::tag);
	soap_embedded(soap, &this->ns1__SellerProfileRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerProfileRequest::type);
	soap_embedded(soap, &this->ns1__SellerProfileRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerProfileRequest::devtag);
	soap_embedded(soap, &this->ns1__SellerProfileRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SellerProfileRequest::page);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileRequest::locale);
	/* transient soap skipped */
}

int ns1__SellerProfileRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellerProfileRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SellerProfileRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellerProfileRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerProfileRequest(struct soap *soap, const char *tag, int id, const ns1__SellerProfileRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerProfileRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "seller_id", -1, &(a->ns1__SellerProfileRequest::seller_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__SellerProfileRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__SellerProfileRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__SellerProfileRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__SellerProfileRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__SellerProfileRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellerProfileRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellerProfileRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellerProfileRequest * SOAP_FMAC4 soap_get_ns1__SellerProfileRequest(struct soap *soap, ns1__SellerProfileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SellerProfileRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellerProfileRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellerProfileRequest * SOAP_FMAC4 soap_in_ns1__SellerProfileRequest(struct soap *soap, const char *tag, ns1__SellerProfileRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellerProfileRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerProfileRequest, sizeof(ns1__SellerProfileRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellerProfileRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellerProfileRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_seller_USCOREid1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_seller_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "seller_id", &(a->ns1__SellerProfileRequest::seller_USCOREid), "xsd:string"))
				{	soap_flag_seller_USCOREid1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__SellerProfileRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__SellerProfileRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__SellerProfileRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__SellerProfileRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__SellerProfileRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellerProfileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerProfileRequest, 0, sizeof(ns1__SellerProfileRequest), 0, soap_copy_ns1__SellerProfileRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_seller_USCOREid1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0 || soap_flag_page1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SellerProfileRequest * SOAP_FMAC6 soap_new_ns1__SellerProfileRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerProfileRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerProfileRequest(struct soap *soap, ns1__SellerProfileRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SellerProfileRequest * SOAP_FMAC4 soap_instantiate_ns1__SellerProfileRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerProfileRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerProfileRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SellerProfileRequest;
		if (size)
			*size = sizeof(ns1__SellerProfileRequest);
		((ns1__SellerProfileRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SellerProfileRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellerProfileRequest);
		for (int i = 0; i < n; i++)
			((ns1__SellerProfileRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellerProfileRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerProfileRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellerProfileRequest %p -> %p\n", q, p));
	*(ns1__SellerProfileRequest*)p = *(ns1__SellerProfileRequest*)q;
}

void ns1__MarketplaceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__MarketplaceRequest::marketplace_USCOREsearch);
	soap_default_std__string(soap, &this->ns1__MarketplaceRequest::tag);
	soap_default_std__string(soap, &this->ns1__MarketplaceRequest::type);
	soap_default_std__string(soap, &this->ns1__MarketplaceRequest::devtag);
	soap_default_std__string(soap, &this->ns1__MarketplaceRequest::page);
	this->ns1__MarketplaceRequest::keyword = NULL;
	this->ns1__MarketplaceRequest::keyword_USCOREsearch = NULL;
	this->ns1__MarketplaceRequest::browse_USCOREid = NULL;
	this->ns1__MarketplaceRequest::zipcode = NULL;
	this->ns1__MarketplaceRequest::area_USCOREid = NULL;
	this->ns1__MarketplaceRequest::geo = NULL;
	this->ns1__MarketplaceRequest::sort = NULL;
	this->ns1__MarketplaceRequest::listing_USCOREid = NULL;
	this->ns1__MarketplaceRequest::locale = NULL;
	this->ns1__MarketplaceRequest::index = NULL;
	/* transient soap skipped */
}

void ns1__MarketplaceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__MarketplaceRequest::marketplace_USCOREsearch, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MarketplaceRequest::marketplace_USCOREsearch);
	soap_embedded(soap, &this->ns1__MarketplaceRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MarketplaceRequest::tag);
	soap_embedded(soap, &this->ns1__MarketplaceRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MarketplaceRequest::type);
	soap_embedded(soap, &this->ns1__MarketplaceRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MarketplaceRequest::devtag);
	soap_embedded(soap, &this->ns1__MarketplaceRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MarketplaceRequest::page);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::keyword);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::keyword_USCOREsearch);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::browse_USCOREid);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::zipcode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::area_USCOREid);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::geo);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::listing_USCOREid);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::locale);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceRequest::index);
	/* transient soap skipped */
}

int ns1__MarketplaceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MarketplaceRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MarketplaceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MarketplaceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketplaceRequest(struct soap *soap, const char *tag, int id, const ns1__MarketplaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketplaceRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "marketplace_search", -1, &(a->ns1__MarketplaceRequest::marketplace_USCOREsearch), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__MarketplaceRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__MarketplaceRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__MarketplaceRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__MarketplaceRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "keyword", -1, &(a->ns1__MarketplaceRequest::keyword), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "keyword_search", -1, &(a->ns1__MarketplaceRequest::keyword_USCOREsearch), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "browse_id", -1, &(a->ns1__MarketplaceRequest::browse_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "zipcode", -1, &(a->ns1__MarketplaceRequest::zipcode), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "area_id", -1, &(a->ns1__MarketplaceRequest::area_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "geo", -1, &(a->ns1__MarketplaceRequest::geo), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__MarketplaceRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "listing_id", -1, &(a->ns1__MarketplaceRequest::listing_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__MarketplaceRequest::locale), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "index", -1, &(a->ns1__MarketplaceRequest::index), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__MarketplaceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MarketplaceRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MarketplaceRequest * SOAP_FMAC4 soap_get_ns1__MarketplaceRequest(struct soap *soap, ns1__MarketplaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketplaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__MarketplaceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MarketplaceRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MarketplaceRequest * SOAP_FMAC4 soap_in_ns1__MarketplaceRequest(struct soap *soap, const char *tag, ns1__MarketplaceRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MarketplaceRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketplaceRequest, sizeof(ns1__MarketplaceRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MarketplaceRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MarketplaceRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_marketplace_USCOREsearch1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_keyword_USCOREsearch1 = 1;
	size_t soap_flag_browse_USCOREid1 = 1;
	size_t soap_flag_zipcode1 = 1;
	size_t soap_flag_area_USCOREid1 = 1;
	size_t soap_flag_geo1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_listing_USCOREid1 = 1;
	size_t soap_flag_locale1 = 1;
	size_t soap_flag_index1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_marketplace_USCOREsearch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "marketplace_search", &(a->ns1__MarketplaceRequest::marketplace_USCOREsearch), "xsd:string"))
				{	soap_flag_marketplace_USCOREsearch1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__MarketplaceRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__MarketplaceRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__MarketplaceRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__MarketplaceRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "keyword", &(a->ns1__MarketplaceRequest::keyword), "xsd:string"))
				{	soap_flag_keyword1--;
					continue;
				}
			if (soap_flag_keyword_USCOREsearch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "keyword_search", &(a->ns1__MarketplaceRequest::keyword_USCOREsearch), "xsd:string"))
				{	soap_flag_keyword_USCOREsearch1--;
					continue;
				}
			if (soap_flag_browse_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "browse_id", &(a->ns1__MarketplaceRequest::browse_USCOREid), "xsd:string"))
				{	soap_flag_browse_USCOREid1--;
					continue;
				}
			if (soap_flag_zipcode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "zipcode", &(a->ns1__MarketplaceRequest::zipcode), "xsd:string"))
				{	soap_flag_zipcode1--;
					continue;
				}
			if (soap_flag_area_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "area_id", &(a->ns1__MarketplaceRequest::area_USCOREid), "xsd:string"))
				{	soap_flag_area_USCOREid1--;
					continue;
				}
			if (soap_flag_geo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "geo", &(a->ns1__MarketplaceRequest::geo), "xsd:string"))
				{	soap_flag_geo1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__MarketplaceRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_listing_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "listing_id", &(a->ns1__MarketplaceRequest::listing_USCOREid), "xsd:string"))
				{	soap_flag_listing_USCOREid1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__MarketplaceRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			if (soap_flag_index1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "index", &(a->ns1__MarketplaceRequest::index), "xsd:string"))
				{	soap_flag_index1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MarketplaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketplaceRequest, 0, sizeof(ns1__MarketplaceRequest), 0, soap_copy_ns1__MarketplaceRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_marketplace_USCOREsearch1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0 || soap_flag_page1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MarketplaceRequest * SOAP_FMAC6 soap_new_ns1__MarketplaceRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__MarketplaceRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MarketplaceRequest(struct soap *soap, ns1__MarketplaceRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MarketplaceRequest * SOAP_FMAC4 soap_instantiate_ns1__MarketplaceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MarketplaceRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MarketplaceRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MarketplaceRequest;
		if (size)
			*size = sizeof(ns1__MarketplaceRequest);
		((ns1__MarketplaceRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MarketplaceRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MarketplaceRequest);
		for (int i = 0; i < n; i++)
			((ns1__MarketplaceRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MarketplaceRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MarketplaceRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MarketplaceRequest %p -> %p\n", q, p));
	*(ns1__MarketplaceRequest*)p = *(ns1__MarketplaceRequest*)q;
}

void ns1__WishlistRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__WishlistRequest::wishlist_USCOREid);
	soap_default_std__string(soap, &this->ns1__WishlistRequest::page);
	soap_default_std__string(soap, &this->ns1__WishlistRequest::tag);
	soap_default_std__string(soap, &this->ns1__WishlistRequest::type);
	soap_default_std__string(soap, &this->ns1__WishlistRequest::devtag);
	this->ns1__WishlistRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__WishlistRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__WishlistRequest::wishlist_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WishlistRequest::wishlist_USCOREid);
	soap_embedded(soap, &this->ns1__WishlistRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WishlistRequest::page);
	soap_embedded(soap, &this->ns1__WishlistRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WishlistRequest::tag);
	soap_embedded(soap, &this->ns1__WishlistRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WishlistRequest::type);
	soap_embedded(soap, &this->ns1__WishlistRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WishlistRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__WishlistRequest::locale);
	/* transient soap skipped */
}

int ns1__WishlistRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__WishlistRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__WishlistRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WishlistRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WishlistRequest(struct soap *soap, const char *tag, int id, const ns1__WishlistRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WishlistRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "wishlist_id", -1, &(a->ns1__WishlistRequest::wishlist_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__WishlistRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__WishlistRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__WishlistRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__WishlistRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__WishlistRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__WishlistRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WishlistRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WishlistRequest * SOAP_FMAC4 soap_get_ns1__WishlistRequest(struct soap *soap, ns1__WishlistRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WishlistRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__WishlistRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__WishlistRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WishlistRequest * SOAP_FMAC4 soap_in_ns1__WishlistRequest(struct soap *soap, const char *tag, ns1__WishlistRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WishlistRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WishlistRequest, sizeof(ns1__WishlistRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__WishlistRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__WishlistRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_wishlist_USCOREid1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wishlist_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "wishlist_id", &(a->ns1__WishlistRequest::wishlist_USCOREid), "xsd:string"))
				{	soap_flag_wishlist_USCOREid1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__WishlistRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__WishlistRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__WishlistRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__WishlistRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__WishlistRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__WishlistRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WishlistRequest, 0, sizeof(ns1__WishlistRequest), 0, soap_copy_ns1__WishlistRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wishlist_USCOREid1 > 0 || soap_flag_page1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__WishlistRequest * SOAP_FMAC6 soap_new_ns1__WishlistRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__WishlistRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__WishlistRequest(struct soap *soap, ns1__WishlistRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__WishlistRequest * SOAP_FMAC4 soap_instantiate_ns1__WishlistRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WishlistRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__WishlistRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__WishlistRequest;
		if (size)
			*size = sizeof(ns1__WishlistRequest);
		((ns1__WishlistRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__WishlistRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__WishlistRequest);
		for (int i = 0; i < n; i++)
			((ns1__WishlistRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__WishlistRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__WishlistRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__WishlistRequest %p -> %p\n", q, p));
	*(ns1__WishlistRequest*)p = *(ns1__WishlistRequest*)q;
}

void ns1__ListManiaRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ListManiaRequest::lm_USCOREid);
	soap_default_std__string(soap, &this->ns1__ListManiaRequest::page);
	soap_default_std__string(soap, &this->ns1__ListManiaRequest::tag);
	soap_default_std__string(soap, &this->ns1__ListManiaRequest::type);
	soap_default_std__string(soap, &this->ns1__ListManiaRequest::devtag);
	this->ns1__ListManiaRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__ListManiaRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ListManiaRequest::lm_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListManiaRequest::lm_USCOREid);
	soap_embedded(soap, &this->ns1__ListManiaRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListManiaRequest::page);
	soap_embedded(soap, &this->ns1__ListManiaRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListManiaRequest::tag);
	soap_embedded(soap, &this->ns1__ListManiaRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListManiaRequest::type);
	soap_embedded(soap, &this->ns1__ListManiaRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListManiaRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListManiaRequest::locale);
	/* transient soap skipped */
}

int ns1__ListManiaRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListManiaRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ListManiaRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListManiaRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListManiaRequest(struct soap *soap, const char *tag, int id, const ns1__ListManiaRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListManiaRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "lm_id", -1, &(a->ns1__ListManiaRequest::lm_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__ListManiaRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__ListManiaRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__ListManiaRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__ListManiaRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__ListManiaRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListManiaRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListManiaRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListManiaRequest * SOAP_FMAC4 soap_get_ns1__ListManiaRequest(struct soap *soap, ns1__ListManiaRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListManiaRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ListManiaRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListManiaRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListManiaRequest * SOAP_FMAC4 soap_in_ns1__ListManiaRequest(struct soap *soap, const char *tag, ns1__ListManiaRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListManiaRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListManiaRequest, sizeof(ns1__ListManiaRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListManiaRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListManiaRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lm_USCOREid1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lm_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "lm_id", &(a->ns1__ListManiaRequest::lm_USCOREid), "xsd:string"))
				{	soap_flag_lm_USCOREid1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__ListManiaRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__ListManiaRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__ListManiaRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__ListManiaRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__ListManiaRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListManiaRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListManiaRequest, 0, sizeof(ns1__ListManiaRequest), 0, soap_copy_ns1__ListManiaRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lm_USCOREid1 > 0 || soap_flag_page1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ListManiaRequest * SOAP_FMAC6 soap_new_ns1__ListManiaRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ListManiaRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ListManiaRequest(struct soap *soap, ns1__ListManiaRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ListManiaRequest * SOAP_FMAC4 soap_instantiate_ns1__ListManiaRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListManiaRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListManiaRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ListManiaRequest;
		if (size)
			*size = sizeof(ns1__ListManiaRequest);
		((ns1__ListManiaRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ListManiaRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListManiaRequest);
		for (int i = 0; i < n; i++)
			((ns1__ListManiaRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListManiaRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListManiaRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListManiaRequest %p -> %p\n", q, p));
	*(ns1__ListManiaRequest*)p = *(ns1__ListManiaRequest*)q;
}

void ns1__ManufacturerRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ManufacturerRequest::manufacturer);
	soap_default_std__string(soap, &this->ns1__ManufacturerRequest::page);
	soap_default_std__string(soap, &this->ns1__ManufacturerRequest::mode);
	soap_default_std__string(soap, &this->ns1__ManufacturerRequest::tag);
	soap_default_std__string(soap, &this->ns1__ManufacturerRequest::type);
	soap_default_std__string(soap, &this->ns1__ManufacturerRequest::devtag);
	this->ns1__ManufacturerRequest::sort = NULL;
	this->ns1__ManufacturerRequest::variations = NULL;
	this->ns1__ManufacturerRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__ManufacturerRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ManufacturerRequest::manufacturer, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ManufacturerRequest::manufacturer);
	soap_embedded(soap, &this->ns1__ManufacturerRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ManufacturerRequest::page);
	soap_embedded(soap, &this->ns1__ManufacturerRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ManufacturerRequest::mode);
	soap_embedded(soap, &this->ns1__ManufacturerRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ManufacturerRequest::tag);
	soap_embedded(soap, &this->ns1__ManufacturerRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ManufacturerRequest::type);
	soap_embedded(soap, &this->ns1__ManufacturerRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ManufacturerRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ManufacturerRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ManufacturerRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ManufacturerRequest::locale);
	/* transient soap skipped */
}

int ns1__ManufacturerRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ManufacturerRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ManufacturerRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ManufacturerRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ManufacturerRequest(struct soap *soap, const char *tag, int id, const ns1__ManufacturerRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ManufacturerRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "manufacturer", -1, &(a->ns1__ManufacturerRequest::manufacturer), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__ManufacturerRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__ManufacturerRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__ManufacturerRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__ManufacturerRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__ManufacturerRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__ManufacturerRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__ManufacturerRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__ManufacturerRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ManufacturerRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ManufacturerRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ManufacturerRequest * SOAP_FMAC4 soap_get_ns1__ManufacturerRequest(struct soap *soap, ns1__ManufacturerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ManufacturerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ManufacturerRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ManufacturerRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ManufacturerRequest * SOAP_FMAC4 soap_in_ns1__ManufacturerRequest(struct soap *soap, const char *tag, ns1__ManufacturerRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ManufacturerRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ManufacturerRequest, sizeof(ns1__ManufacturerRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ManufacturerRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ManufacturerRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_manufacturer1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_manufacturer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "manufacturer", &(a->ns1__ManufacturerRequest::manufacturer), "xsd:string"))
				{	soap_flag_manufacturer1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__ManufacturerRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__ManufacturerRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__ManufacturerRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__ManufacturerRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__ManufacturerRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__ManufacturerRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__ManufacturerRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__ManufacturerRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ManufacturerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ManufacturerRequest, 0, sizeof(ns1__ManufacturerRequest), 0, soap_copy_ns1__ManufacturerRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_manufacturer1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ManufacturerRequest * SOAP_FMAC6 soap_new_ns1__ManufacturerRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ManufacturerRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ManufacturerRequest(struct soap *soap, ns1__ManufacturerRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ManufacturerRequest * SOAP_FMAC4 soap_instantiate_ns1__ManufacturerRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ManufacturerRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ManufacturerRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ManufacturerRequest;
		if (size)
			*size = sizeof(ns1__ManufacturerRequest);
		((ns1__ManufacturerRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ManufacturerRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ManufacturerRequest);
		for (int i = 0; i < n; i++)
			((ns1__ManufacturerRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ManufacturerRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ManufacturerRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ManufacturerRequest %p -> %p\n", q, p));
	*(ns1__ManufacturerRequest*)p = *(ns1__ManufacturerRequest*)q;
}

void ns1__ExchangeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ExchangeRequest::exchange_USCOREid);
	soap_default_std__string(soap, &this->ns1__ExchangeRequest::tag);
	soap_default_std__string(soap, &this->ns1__ExchangeRequest::type);
	soap_default_std__string(soap, &this->ns1__ExchangeRequest::devtag);
	this->ns1__ExchangeRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__ExchangeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ExchangeRequest::exchange_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ExchangeRequest::exchange_USCOREid);
	soap_embedded(soap, &this->ns1__ExchangeRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ExchangeRequest::tag);
	soap_embedded(soap, &this->ns1__ExchangeRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ExchangeRequest::type);
	soap_embedded(soap, &this->ns1__ExchangeRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ExchangeRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ExchangeRequest::locale);
	/* transient soap skipped */
}

int ns1__ExchangeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ExchangeRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ExchangeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ExchangeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExchangeRequest(struct soap *soap, const char *tag, int id, const ns1__ExchangeRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExchangeRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "exchange_id", -1, &(a->ns1__ExchangeRequest::exchange_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__ExchangeRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__ExchangeRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__ExchangeRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__ExchangeRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ExchangeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ExchangeRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ExchangeRequest * SOAP_FMAC4 soap_get_ns1__ExchangeRequest(struct soap *soap, ns1__ExchangeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExchangeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ExchangeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ExchangeRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ExchangeRequest * SOAP_FMAC4 soap_in_ns1__ExchangeRequest(struct soap *soap, const char *tag, ns1__ExchangeRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ExchangeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExchangeRequest, sizeof(ns1__ExchangeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ExchangeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ExchangeRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_exchange_USCOREid1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_exchange_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "exchange_id", &(a->ns1__ExchangeRequest::exchange_USCOREid), "xsd:string"))
				{	soap_flag_exchange_USCOREid1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__ExchangeRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__ExchangeRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__ExchangeRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__ExchangeRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ExchangeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExchangeRequest, 0, sizeof(ns1__ExchangeRequest), 0, soap_copy_ns1__ExchangeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_exchange_USCOREid1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ExchangeRequest * SOAP_FMAC6 soap_new_ns1__ExchangeRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ExchangeRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ExchangeRequest(struct soap *soap, ns1__ExchangeRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ExchangeRequest * SOAP_FMAC4 soap_instantiate_ns1__ExchangeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExchangeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ExchangeRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ExchangeRequest;
		if (size)
			*size = sizeof(ns1__ExchangeRequest);
		((ns1__ExchangeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ExchangeRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ExchangeRequest);
		for (int i = 0; i < n; i++)
			((ns1__ExchangeRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ExchangeRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ExchangeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ExchangeRequest %p -> %p\n", q, p));
	*(ns1__ExchangeRequest*)p = *(ns1__ExchangeRequest*)q;
}

void ns1__DirectorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DirectorRequest::director);
	soap_default_std__string(soap, &this->ns1__DirectorRequest::page);
	soap_default_std__string(soap, &this->ns1__DirectorRequest::mode);
	soap_default_std__string(soap, &this->ns1__DirectorRequest::tag);
	soap_default_std__string(soap, &this->ns1__DirectorRequest::type);
	soap_default_std__string(soap, &this->ns1__DirectorRequest::devtag);
	this->ns1__DirectorRequest::sort = NULL;
	this->ns1__DirectorRequest::variations = NULL;
	this->ns1__DirectorRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__DirectorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__DirectorRequest::director, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DirectorRequest::director);
	soap_embedded(soap, &this->ns1__DirectorRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DirectorRequest::page);
	soap_embedded(soap, &this->ns1__DirectorRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DirectorRequest::mode);
	soap_embedded(soap, &this->ns1__DirectorRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DirectorRequest::tag);
	soap_embedded(soap, &this->ns1__DirectorRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DirectorRequest::type);
	soap_embedded(soap, &this->ns1__DirectorRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DirectorRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__DirectorRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__DirectorRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__DirectorRequest::locale);
	/* transient soap skipped */
}

int ns1__DirectorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DirectorRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__DirectorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DirectorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DirectorRequest(struct soap *soap, const char *tag, int id, const ns1__DirectorRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DirectorRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "director", -1, &(a->ns1__DirectorRequest::director), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__DirectorRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__DirectorRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__DirectorRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__DirectorRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__DirectorRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__DirectorRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__DirectorRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__DirectorRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DirectorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DirectorRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DirectorRequest * SOAP_FMAC4 soap_get_ns1__DirectorRequest(struct soap *soap, ns1__DirectorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DirectorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__DirectorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DirectorRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DirectorRequest * SOAP_FMAC4 soap_in_ns1__DirectorRequest(struct soap *soap, const char *tag, ns1__DirectorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DirectorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DirectorRequest, sizeof(ns1__DirectorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DirectorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DirectorRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_director1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_director1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "director", &(a->ns1__DirectorRequest::director), "xsd:string"))
				{	soap_flag_director1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__DirectorRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__DirectorRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__DirectorRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__DirectorRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__DirectorRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__DirectorRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__DirectorRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__DirectorRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DirectorRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DirectorRequest, 0, sizeof(ns1__DirectorRequest), 0, soap_copy_ns1__DirectorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_director1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__DirectorRequest * SOAP_FMAC6 soap_new_ns1__DirectorRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__DirectorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DirectorRequest(struct soap *soap, ns1__DirectorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__DirectorRequest * SOAP_FMAC4 soap_instantiate_ns1__DirectorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DirectorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DirectorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DirectorRequest;
		if (size)
			*size = sizeof(ns1__DirectorRequest);
		((ns1__DirectorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DirectorRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DirectorRequest);
		for (int i = 0; i < n; i++)
			((ns1__DirectorRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DirectorRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DirectorRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DirectorRequest %p -> %p\n", q, p));
	*(ns1__DirectorRequest*)p = *(ns1__DirectorRequest*)q;
}

void ns1__ActorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ActorRequest::actor);
	soap_default_std__string(soap, &this->ns1__ActorRequest::page);
	soap_default_std__string(soap, &this->ns1__ActorRequest::mode);
	soap_default_std__string(soap, &this->ns1__ActorRequest::tag);
	soap_default_std__string(soap, &this->ns1__ActorRequest::type);
	soap_default_std__string(soap, &this->ns1__ActorRequest::devtag);
	this->ns1__ActorRequest::sort = NULL;
	this->ns1__ActorRequest::variations = NULL;
	this->ns1__ActorRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__ActorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ActorRequest::actor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ActorRequest::actor);
	soap_embedded(soap, &this->ns1__ActorRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ActorRequest::page);
	soap_embedded(soap, &this->ns1__ActorRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ActorRequest::mode);
	soap_embedded(soap, &this->ns1__ActorRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ActorRequest::tag);
	soap_embedded(soap, &this->ns1__ActorRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ActorRequest::type);
	soap_embedded(soap, &this->ns1__ActorRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ActorRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActorRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActorRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActorRequest::locale);
	/* transient soap skipped */
}

int ns1__ActorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ActorRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ActorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ActorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActorRequest(struct soap *soap, const char *tag, int id, const ns1__ActorRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ActorRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "actor", -1, &(a->ns1__ActorRequest::actor), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__ActorRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__ActorRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__ActorRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__ActorRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__ActorRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__ActorRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__ActorRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__ActorRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ActorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ActorRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ActorRequest * SOAP_FMAC4 soap_get_ns1__ActorRequest(struct soap *soap, ns1__ActorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ActorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ActorRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ActorRequest * SOAP_FMAC4 soap_in_ns1__ActorRequest(struct soap *soap, const char *tag, ns1__ActorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ActorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActorRequest, sizeof(ns1__ActorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ActorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ActorRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actor1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_actor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "actor", &(a->ns1__ActorRequest::actor), "xsd:string"))
				{	soap_flag_actor1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__ActorRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__ActorRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__ActorRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__ActorRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__ActorRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__ActorRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__ActorRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__ActorRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ActorRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActorRequest, 0, sizeof(ns1__ActorRequest), 0, soap_copy_ns1__ActorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_actor1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ActorRequest * SOAP_FMAC6 soap_new_ns1__ActorRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ActorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ActorRequest(struct soap *soap, ns1__ActorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ActorRequest * SOAP_FMAC4 soap_instantiate_ns1__ActorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ActorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ActorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ActorRequest;
		if (size)
			*size = sizeof(ns1__ActorRequest);
		((ns1__ActorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ActorRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ActorRequest);
		for (int i = 0; i < n; i++)
			((ns1__ActorRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ActorRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ActorRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ActorRequest %p -> %p\n", q, p));
	*(ns1__ActorRequest*)p = *(ns1__ActorRequest*)q;
}

void ns1__AuthorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__AuthorRequest::author);
	soap_default_std__string(soap, &this->ns1__AuthorRequest::page);
	soap_default_std__string(soap, &this->ns1__AuthorRequest::mode);
	soap_default_std__string(soap, &this->ns1__AuthorRequest::tag);
	soap_default_std__string(soap, &this->ns1__AuthorRequest::type);
	soap_default_std__string(soap, &this->ns1__AuthorRequest::devtag);
	this->ns1__AuthorRequest::sort = NULL;
	this->ns1__AuthorRequest::variations = NULL;
	this->ns1__AuthorRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__AuthorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__AuthorRequest::author, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AuthorRequest::author);
	soap_embedded(soap, &this->ns1__AuthorRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AuthorRequest::page);
	soap_embedded(soap, &this->ns1__AuthorRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AuthorRequest::mode);
	soap_embedded(soap, &this->ns1__AuthorRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AuthorRequest::tag);
	soap_embedded(soap, &this->ns1__AuthorRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AuthorRequest::type);
	soap_embedded(soap, &this->ns1__AuthorRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AuthorRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AuthorRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AuthorRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AuthorRequest::locale);
	/* transient soap skipped */
}

int ns1__AuthorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AuthorRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AuthorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AuthorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuthorRequest(struct soap *soap, const char *tag, int id, const ns1__AuthorRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuthorRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "author", -1, &(a->ns1__AuthorRequest::author), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__AuthorRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__AuthorRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__AuthorRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__AuthorRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__AuthorRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__AuthorRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__AuthorRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__AuthorRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AuthorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AuthorRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AuthorRequest * SOAP_FMAC4 soap_get_ns1__AuthorRequest(struct soap *soap, ns1__AuthorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuthorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__AuthorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AuthorRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AuthorRequest * SOAP_FMAC4 soap_in_ns1__AuthorRequest(struct soap *soap, const char *tag, ns1__AuthorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AuthorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuthorRequest, sizeof(ns1__AuthorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AuthorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AuthorRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_author1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "author", &(a->ns1__AuthorRequest::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__AuthorRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__AuthorRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__AuthorRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__AuthorRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__AuthorRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__AuthorRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__AuthorRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__AuthorRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AuthorRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuthorRequest, 0, sizeof(ns1__AuthorRequest), 0, soap_copy_ns1__AuthorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_author1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AuthorRequest * SOAP_FMAC6 soap_new_ns1__AuthorRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__AuthorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AuthorRequest(struct soap *soap, ns1__AuthorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AuthorRequest * SOAP_FMAC4 soap_instantiate_ns1__AuthorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AuthorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AuthorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AuthorRequest;
		if (size)
			*size = sizeof(ns1__AuthorRequest);
		((ns1__AuthorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AuthorRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AuthorRequest);
		for (int i = 0; i < n; i++)
			((ns1__AuthorRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AuthorRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AuthorRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AuthorRequest %p -> %p\n", q, p));
	*(ns1__AuthorRequest*)p = *(ns1__AuthorRequest*)q;
}

void ns1__ArtistRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ArtistRequest::artist);
	soap_default_std__string(soap, &this->ns1__ArtistRequest::page);
	soap_default_std__string(soap, &this->ns1__ArtistRequest::mode);
	soap_default_std__string(soap, &this->ns1__ArtistRequest::tag);
	soap_default_std__string(soap, &this->ns1__ArtistRequest::type);
	soap_default_std__string(soap, &this->ns1__ArtistRequest::devtag);
	this->ns1__ArtistRequest::sort = NULL;
	this->ns1__ArtistRequest::variations = NULL;
	this->ns1__ArtistRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__ArtistRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ArtistRequest::artist, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ArtistRequest::artist);
	soap_embedded(soap, &this->ns1__ArtistRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ArtistRequest::page);
	soap_embedded(soap, &this->ns1__ArtistRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ArtistRequest::mode);
	soap_embedded(soap, &this->ns1__ArtistRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ArtistRequest::tag);
	soap_embedded(soap, &this->ns1__ArtistRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ArtistRequest::type);
	soap_embedded(soap, &this->ns1__ArtistRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ArtistRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ArtistRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ArtistRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ArtistRequest::locale);
	/* transient soap skipped */
}

int ns1__ArtistRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArtistRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArtistRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArtistRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArtistRequest(struct soap *soap, const char *tag, int id, const ns1__ArtistRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArtistRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "artist", -1, &(a->ns1__ArtistRequest::artist), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__ArtistRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__ArtistRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__ArtistRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__ArtistRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__ArtistRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__ArtistRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__ArtistRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__ArtistRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArtistRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArtistRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArtistRequest * SOAP_FMAC4 soap_get_ns1__ArtistRequest(struct soap *soap, ns1__ArtistRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArtistRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArtistRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArtistRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArtistRequest * SOAP_FMAC4 soap_in_ns1__ArtistRequest(struct soap *soap, const char *tag, ns1__ArtistRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArtistRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArtistRequest, sizeof(ns1__ArtistRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArtistRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArtistRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_artist1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_artist1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "artist", &(a->ns1__ArtistRequest::artist), "xsd:string"))
				{	soap_flag_artist1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__ArtistRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__ArtistRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__ArtistRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__ArtistRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__ArtistRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__ArtistRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__ArtistRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__ArtistRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArtistRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArtistRequest, 0, sizeof(ns1__ArtistRequest), 0, soap_copy_ns1__ArtistRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_artist1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArtistRequest * SOAP_FMAC6 soap_new_ns1__ArtistRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArtistRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArtistRequest(struct soap *soap, ns1__ArtistRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArtistRequest * SOAP_FMAC4 soap_instantiate_ns1__ArtistRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArtistRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArtistRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArtistRequest;
		if (size)
			*size = sizeof(ns1__ArtistRequest);
		((ns1__ArtistRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArtistRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArtistRequest);
		for (int i = 0; i < n; i++)
			((ns1__ArtistRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArtistRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArtistRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArtistRequest %p -> %p\n", q, p));
	*(ns1__ArtistRequest*)p = *(ns1__ArtistRequest*)q;
}

void ns1__UpcRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__UpcRequest::upc);
	soap_default_std__string(soap, &this->ns1__UpcRequest::mode);
	soap_default_std__string(soap, &this->ns1__UpcRequest::tag);
	soap_default_std__string(soap, &this->ns1__UpcRequest::type);
	soap_default_std__string(soap, &this->ns1__UpcRequest::devtag);
	this->ns1__UpcRequest::sort = NULL;
	this->ns1__UpcRequest::variations = NULL;
	this->ns1__UpcRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__UpcRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__UpcRequest::upc, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__UpcRequest::upc);
	soap_embedded(soap, &this->ns1__UpcRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__UpcRequest::mode);
	soap_embedded(soap, &this->ns1__UpcRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__UpcRequest::tag);
	soap_embedded(soap, &this->ns1__UpcRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__UpcRequest::type);
	soap_embedded(soap, &this->ns1__UpcRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__UpcRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__UpcRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__UpcRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__UpcRequest::locale);
	/* transient soap skipped */
}

int ns1__UpcRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UpcRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__UpcRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UpcRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpcRequest(struct soap *soap, const char *tag, int id, const ns1__UpcRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpcRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "upc", -1, &(a->ns1__UpcRequest::upc), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__UpcRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__UpcRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__UpcRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__UpcRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__UpcRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__UpcRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__UpcRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UpcRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UpcRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UpcRequest * SOAP_FMAC4 soap_get_ns1__UpcRequest(struct soap *soap, ns1__UpcRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpcRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__UpcRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UpcRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UpcRequest * SOAP_FMAC4 soap_in_ns1__UpcRequest(struct soap *soap, const char *tag, ns1__UpcRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UpcRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpcRequest, sizeof(ns1__UpcRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UpcRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UpcRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_upc1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_upc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upc", &(a->ns1__UpcRequest::upc), "xsd:string"))
				{	soap_flag_upc1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__UpcRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__UpcRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__UpcRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__UpcRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__UpcRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__UpcRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__UpcRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UpcRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpcRequest, 0, sizeof(ns1__UpcRequest), 0, soap_copy_ns1__UpcRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_upc1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__UpcRequest * SOAP_FMAC6 soap_new_ns1__UpcRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__UpcRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UpcRequest(struct soap *soap, ns1__UpcRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__UpcRequest * SOAP_FMAC4 soap_instantiate_ns1__UpcRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpcRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UpcRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UpcRequest;
		if (size)
			*size = sizeof(ns1__UpcRequest);
		((ns1__UpcRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UpcRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UpcRequest);
		for (int i = 0; i < n; i++)
			((ns1__UpcRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UpcRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UpcRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UpcRequest %p -> %p\n", q, p));
	*(ns1__UpcRequest*)p = *(ns1__UpcRequest*)q;
}

void ns1__BlendedRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BlendedRequest::blended);
	soap_default_std__string(soap, &this->ns1__BlendedRequest::tag);
	soap_default_std__string(soap, &this->ns1__BlendedRequest::type);
	soap_default_std__string(soap, &this->ns1__BlendedRequest::devtag);
	this->ns1__BlendedRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__BlendedRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BlendedRequest::blended, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BlendedRequest::blended);
	soap_embedded(soap, &this->ns1__BlendedRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BlendedRequest::tag);
	soap_embedded(soap, &this->ns1__BlendedRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BlendedRequest::type);
	soap_embedded(soap, &this->ns1__BlendedRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BlendedRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BlendedRequest::locale);
	/* transient soap skipped */
}

int ns1__BlendedRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BlendedRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__BlendedRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BlendedRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BlendedRequest(struct soap *soap, const char *tag, int id, const ns1__BlendedRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BlendedRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "blended", -1, &(a->ns1__BlendedRequest::blended), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__BlendedRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__BlendedRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__BlendedRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__BlendedRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__BlendedRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BlendedRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BlendedRequest * SOAP_FMAC4 soap_get_ns1__BlendedRequest(struct soap *soap, ns1__BlendedRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BlendedRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__BlendedRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BlendedRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BlendedRequest * SOAP_FMAC4 soap_in_ns1__BlendedRequest(struct soap *soap, const char *tag, ns1__BlendedRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BlendedRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BlendedRequest, sizeof(ns1__BlendedRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BlendedRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BlendedRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blended1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blended1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "blended", &(a->ns1__BlendedRequest::blended), "xsd:string"))
				{	soap_flag_blended1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__BlendedRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__BlendedRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__BlendedRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__BlendedRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BlendedRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BlendedRequest, 0, sizeof(ns1__BlendedRequest), 0, soap_copy_ns1__BlendedRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blended1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__BlendedRequest * SOAP_FMAC6 soap_new_ns1__BlendedRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__BlendedRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BlendedRequest(struct soap *soap, ns1__BlendedRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__BlendedRequest * SOAP_FMAC4 soap_instantiate_ns1__BlendedRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BlendedRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BlendedRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__BlendedRequest;
		if (size)
			*size = sizeof(ns1__BlendedRequest);
		((ns1__BlendedRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__BlendedRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BlendedRequest);
		for (int i = 0; i < n; i++)
			((ns1__BlendedRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BlendedRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BlendedRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BlendedRequest %p -> %p\n", q, p));
	*(ns1__BlendedRequest*)p = *(ns1__BlendedRequest*)q;
}

void ns1__AsinRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__AsinRequest::asin);
	soap_default_std__string(soap, &this->ns1__AsinRequest::tag);
	soap_default_std__string(soap, &this->ns1__AsinRequest::type);
	soap_default_std__string(soap, &this->ns1__AsinRequest::devtag);
	this->ns1__AsinRequest::offer = NULL;
	this->ns1__AsinRequest::offerpage = NULL;
	this->ns1__AsinRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__AsinRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__AsinRequest::asin, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AsinRequest::asin);
	soap_embedded(soap, &this->ns1__AsinRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AsinRequest::tag);
	soap_embedded(soap, &this->ns1__AsinRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AsinRequest::type);
	soap_embedded(soap, &this->ns1__AsinRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AsinRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AsinRequest::offer);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AsinRequest::offerpage);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AsinRequest::locale);
	/* transient soap skipped */
}

int ns1__AsinRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AsinRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AsinRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AsinRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AsinRequest(struct soap *soap, const char *tag, int id, const ns1__AsinRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AsinRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "asin", -1, &(a->ns1__AsinRequest::asin), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__AsinRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__AsinRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__AsinRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "offer", -1, &(a->ns1__AsinRequest::offer), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "offerpage", -1, &(a->ns1__AsinRequest::offerpage), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__AsinRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AsinRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AsinRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AsinRequest * SOAP_FMAC4 soap_get_ns1__AsinRequest(struct soap *soap, ns1__AsinRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AsinRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__AsinRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AsinRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AsinRequest * SOAP_FMAC4 soap_in_ns1__AsinRequest(struct soap *soap, const char *tag, ns1__AsinRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AsinRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AsinRequest, sizeof(ns1__AsinRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AsinRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AsinRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_asin1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_offer1 = 1;
	size_t soap_flag_offerpage1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_asin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "asin", &(a->ns1__AsinRequest::asin), "xsd:string"))
				{	soap_flag_asin1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__AsinRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__AsinRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__AsinRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_offer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "offer", &(a->ns1__AsinRequest::offer), "xsd:string"))
				{	soap_flag_offer1--;
					continue;
				}
			if (soap_flag_offerpage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "offerpage", &(a->ns1__AsinRequest::offerpage), "xsd:string"))
				{	soap_flag_offerpage1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__AsinRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AsinRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AsinRequest, 0, sizeof(ns1__AsinRequest), 0, soap_copy_ns1__AsinRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_asin1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AsinRequest * SOAP_FMAC6 soap_new_ns1__AsinRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__AsinRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AsinRequest(struct soap *soap, ns1__AsinRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AsinRequest * SOAP_FMAC4 soap_instantiate_ns1__AsinRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AsinRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AsinRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AsinRequest;
		if (size)
			*size = sizeof(ns1__AsinRequest);
		((ns1__AsinRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AsinRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AsinRequest);
		for (int i = 0; i < n; i++)
			((ns1__AsinRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AsinRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AsinRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AsinRequest %p -> %p\n", q, p));
	*(ns1__AsinRequest*)p = *(ns1__AsinRequest*)q;
}

void ns1__BrowseNodeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BrowseNodeRequest::browse_USCOREnode);
	soap_default_std__string(soap, &this->ns1__BrowseNodeRequest::page);
	soap_default_std__string(soap, &this->ns1__BrowseNodeRequest::mode);
	soap_default_std__string(soap, &this->ns1__BrowseNodeRequest::tag);
	soap_default_std__string(soap, &this->ns1__BrowseNodeRequest::type);
	soap_default_std__string(soap, &this->ns1__BrowseNodeRequest::devtag);
	this->ns1__BrowseNodeRequest::sort = NULL;
	this->ns1__BrowseNodeRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__BrowseNodeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BrowseNodeRequest::browse_USCOREnode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BrowseNodeRequest::browse_USCOREnode);
	soap_embedded(soap, &this->ns1__BrowseNodeRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BrowseNodeRequest::page);
	soap_embedded(soap, &this->ns1__BrowseNodeRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BrowseNodeRequest::mode);
	soap_embedded(soap, &this->ns1__BrowseNodeRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BrowseNodeRequest::tag);
	soap_embedded(soap, &this->ns1__BrowseNodeRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BrowseNodeRequest::type);
	soap_embedded(soap, &this->ns1__BrowseNodeRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BrowseNodeRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BrowseNodeRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BrowseNodeRequest::locale);
	/* transient soap skipped */
}

int ns1__BrowseNodeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BrowseNodeRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__BrowseNodeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BrowseNodeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BrowseNodeRequest(struct soap *soap, const char *tag, int id, const ns1__BrowseNodeRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BrowseNodeRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "browse_node", -1, &(a->ns1__BrowseNodeRequest::browse_USCOREnode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__BrowseNodeRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__BrowseNodeRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__BrowseNodeRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__BrowseNodeRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__BrowseNodeRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__BrowseNodeRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__BrowseNodeRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__BrowseNodeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BrowseNodeRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BrowseNodeRequest * SOAP_FMAC4 soap_get_ns1__BrowseNodeRequest(struct soap *soap, ns1__BrowseNodeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BrowseNodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__BrowseNodeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BrowseNodeRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BrowseNodeRequest * SOAP_FMAC4 soap_in_ns1__BrowseNodeRequest(struct soap *soap, const char *tag, ns1__BrowseNodeRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BrowseNodeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BrowseNodeRequest, sizeof(ns1__BrowseNodeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BrowseNodeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BrowseNodeRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_browse_USCOREnode1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_browse_USCOREnode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "browse_node", &(a->ns1__BrowseNodeRequest::browse_USCOREnode), "xsd:string"))
				{	soap_flag_browse_USCOREnode1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__BrowseNodeRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__BrowseNodeRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__BrowseNodeRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__BrowseNodeRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__BrowseNodeRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__BrowseNodeRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__BrowseNodeRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BrowseNodeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BrowseNodeRequest, 0, sizeof(ns1__BrowseNodeRequest), 0, soap_copy_ns1__BrowseNodeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_browse_USCOREnode1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__BrowseNodeRequest * SOAP_FMAC6 soap_new_ns1__BrowseNodeRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__BrowseNodeRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BrowseNodeRequest(struct soap *soap, ns1__BrowseNodeRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__BrowseNodeRequest * SOAP_FMAC4 soap_instantiate_ns1__BrowseNodeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BrowseNodeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BrowseNodeRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__BrowseNodeRequest;
		if (size)
			*size = sizeof(ns1__BrowseNodeRequest);
		((ns1__BrowseNodeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__BrowseNodeRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BrowseNodeRequest);
		for (int i = 0; i < n; i++)
			((ns1__BrowseNodeRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BrowseNodeRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BrowseNodeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BrowseNodeRequest %p -> %p\n", q, p));
	*(ns1__BrowseNodeRequest*)p = *(ns1__BrowseNodeRequest*)q;
}

void ns1__PowerRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__PowerRequest::power);
	soap_default_std__string(soap, &this->ns1__PowerRequest::page);
	soap_default_std__string(soap, &this->ns1__PowerRequest::mode);
	soap_default_std__string(soap, &this->ns1__PowerRequest::tag);
	soap_default_std__string(soap, &this->ns1__PowerRequest::type);
	soap_default_std__string(soap, &this->ns1__PowerRequest::devtag);
	this->ns1__PowerRequest::sort = NULL;
	this->ns1__PowerRequest::variations = NULL;
	this->ns1__PowerRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__PowerRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__PowerRequest::power, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PowerRequest::power);
	soap_embedded(soap, &this->ns1__PowerRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PowerRequest::page);
	soap_embedded(soap, &this->ns1__PowerRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PowerRequest::mode);
	soap_embedded(soap, &this->ns1__PowerRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PowerRequest::tag);
	soap_embedded(soap, &this->ns1__PowerRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PowerRequest::type);
	soap_embedded(soap, &this->ns1__PowerRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PowerRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__PowerRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__PowerRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__PowerRequest::locale);
	/* transient soap skipped */
}

int ns1__PowerRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PowerRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PowerRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PowerRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PowerRequest(struct soap *soap, const char *tag, int id, const ns1__PowerRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PowerRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "power", -1, &(a->ns1__PowerRequest::power), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__PowerRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__PowerRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__PowerRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__PowerRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__PowerRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__PowerRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__PowerRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__PowerRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PowerRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PowerRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PowerRequest * SOAP_FMAC4 soap_get_ns1__PowerRequest(struct soap *soap, ns1__PowerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PowerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__PowerRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PowerRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PowerRequest * SOAP_FMAC4 soap_in_ns1__PowerRequest(struct soap *soap, const char *tag, ns1__PowerRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PowerRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PowerRequest, sizeof(ns1__PowerRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PowerRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PowerRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_power1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_power1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "power", &(a->ns1__PowerRequest::power), "xsd:string"))
				{	soap_flag_power1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__PowerRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__PowerRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__PowerRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__PowerRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__PowerRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__PowerRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__PowerRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__PowerRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PowerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PowerRequest, 0, sizeof(ns1__PowerRequest), 0, soap_copy_ns1__PowerRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_power1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PowerRequest * SOAP_FMAC6 soap_new_ns1__PowerRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__PowerRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PowerRequest(struct soap *soap, ns1__PowerRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__PowerRequest * SOAP_FMAC4 soap_instantiate_ns1__PowerRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PowerRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PowerRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PowerRequest;
		if (size)
			*size = sizeof(ns1__PowerRequest);
		((ns1__PowerRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PowerRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PowerRequest);
		for (int i = 0; i < n; i++)
			((ns1__PowerRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PowerRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PowerRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PowerRequest %p -> %p\n", q, p));
	*(ns1__PowerRequest*)p = *(ns1__PowerRequest*)q;
}

void ns1__KeywordRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__KeywordRequest::keyword);
	soap_default_std__string(soap, &this->ns1__KeywordRequest::page);
	soap_default_std__string(soap, &this->ns1__KeywordRequest::mode);
	soap_default_std__string(soap, &this->ns1__KeywordRequest::tag);
	soap_default_std__string(soap, &this->ns1__KeywordRequest::type);
	soap_default_std__string(soap, &this->ns1__KeywordRequest::devtag);
	this->ns1__KeywordRequest::sort = NULL;
	this->ns1__KeywordRequest::variations = NULL;
	this->ns1__KeywordRequest::locale = NULL;
	/* transient soap skipped */
}

void ns1__KeywordRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__KeywordRequest::keyword, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__KeywordRequest::keyword);
	soap_embedded(soap, &this->ns1__KeywordRequest::page, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__KeywordRequest::page);
	soap_embedded(soap, &this->ns1__KeywordRequest::mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__KeywordRequest::mode);
	soap_embedded(soap, &this->ns1__KeywordRequest::tag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__KeywordRequest::tag);
	soap_embedded(soap, &this->ns1__KeywordRequest::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__KeywordRequest::type);
	soap_embedded(soap, &this->ns1__KeywordRequest::devtag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__KeywordRequest::devtag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__KeywordRequest::sort);
	soap_serialize_PointerTostd__string(soap, &this->ns1__KeywordRequest::variations);
	soap_serialize_PointerTostd__string(soap, &this->ns1__KeywordRequest::locale);
	/* transient soap skipped */
}

int ns1__KeywordRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__KeywordRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__KeywordRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__KeywordRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__KeywordRequest(struct soap *soap, const char *tag, int id, const ns1__KeywordRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__KeywordRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "keyword", -1, &(a->ns1__KeywordRequest::keyword), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "page", -1, &(a->ns1__KeywordRequest::page), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &(a->ns1__KeywordRequest::mode), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "tag", -1, &(a->ns1__KeywordRequest::tag), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &(a->ns1__KeywordRequest::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "devtag", -1, &(a->ns1__KeywordRequest::devtag), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sort", -1, &(a->ns1__KeywordRequest::sort), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "variations", -1, &(a->ns1__KeywordRequest::variations), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "locale", -1, &(a->ns1__KeywordRequest::locale), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__KeywordRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__KeywordRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__KeywordRequest * SOAP_FMAC4 soap_get_ns1__KeywordRequest(struct soap *soap, ns1__KeywordRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__KeywordRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__KeywordRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__KeywordRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__KeywordRequest * SOAP_FMAC4 soap_in_ns1__KeywordRequest(struct soap *soap, const char *tag, ns1__KeywordRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__KeywordRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__KeywordRequest, sizeof(ns1__KeywordRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__KeywordRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__KeywordRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_devtag1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_variations1 = 1;
	size_t soap_flag_locale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "keyword", &(a->ns1__KeywordRequest::keyword), "xsd:string"))
				{	soap_flag_keyword1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "page", &(a->ns1__KeywordRequest::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mode", &(a->ns1__KeywordRequest::mode), "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tag", &(a->ns1__KeywordRequest::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(a->ns1__KeywordRequest::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_devtag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "devtag", &(a->ns1__KeywordRequest::devtag), "xsd:string"))
				{	soap_flag_devtag1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sort", &(a->ns1__KeywordRequest::sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			if (soap_flag_variations1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "variations", &(a->ns1__KeywordRequest::variations), "xsd:string"))
				{	soap_flag_variations1--;
					continue;
				}
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "locale", &(a->ns1__KeywordRequest::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__KeywordRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__KeywordRequest, 0, sizeof(ns1__KeywordRequest), 0, soap_copy_ns1__KeywordRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_keyword1 > 0 || soap_flag_page1 > 0 || soap_flag_mode1 > 0 || soap_flag_tag1 > 0 || soap_flag_type1 > 0 || soap_flag_devtag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__KeywordRequest * SOAP_FMAC6 soap_new_ns1__KeywordRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__KeywordRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__KeywordRequest(struct soap *soap, ns1__KeywordRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__KeywordRequest * SOAP_FMAC4 soap_instantiate_ns1__KeywordRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__KeywordRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__KeywordRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__KeywordRequest;
		if (size)
			*size = sizeof(ns1__KeywordRequest);
		((ns1__KeywordRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__KeywordRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__KeywordRequest);
		for (int i = 0; i < n; i++)
			((ns1__KeywordRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__KeywordRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__KeywordRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__KeywordRequest %p -> %p\n", q, p));
	*(ns1__KeywordRequest*)p = *(ns1__KeywordRequest*)q;
}

void ns1__ThirdPartyProductDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ThirdPartyProductDetails::OfferingType = NULL;
	this->ns1__ThirdPartyProductDetails::SellerId = NULL;
	this->ns1__ThirdPartyProductDetails::SellerNickname = NULL;
	this->ns1__ThirdPartyProductDetails::ExchangeId = NULL;
	this->ns1__ThirdPartyProductDetails::OfferingPrice = NULL;
	this->ns1__ThirdPartyProductDetails::Condition = NULL;
	this->ns1__ThirdPartyProductDetails::ConditionType = NULL;
	this->ns1__ThirdPartyProductDetails::ExchangeAvailability = NULL;
	this->ns1__ThirdPartyProductDetails::SellerCountry = NULL;
	this->ns1__ThirdPartyProductDetails::SellerState = NULL;
	this->ns1__ThirdPartyProductDetails::ShipComments = NULL;
	this->ns1__ThirdPartyProductDetails::SellerRating = NULL;
	/* transient soap skipped */
}

void ns1__ThirdPartyProductDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::OfferingType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::SellerId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::SellerNickname);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::ExchangeId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::OfferingPrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::Condition);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::ConditionType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::ExchangeAvailability);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::SellerCountry);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::SellerState);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::ShipComments);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ThirdPartyProductDetails::SellerRating);
	/* transient soap skipped */
}

int ns1__ThirdPartyProductDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ThirdPartyProductDetails);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ThirdPartyProductDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ThirdPartyProductDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ThirdPartyProductDetails(struct soap *soap, const char *tag, int id, const ns1__ThirdPartyProductDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ThirdPartyProductDetails), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "OfferingType", -1, &(a->ns1__ThirdPartyProductDetails::OfferingType), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SellerId", -1, &(a->ns1__ThirdPartyProductDetails::SellerId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SellerNickname", -1, &(a->ns1__ThirdPartyProductDetails::SellerNickname), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeId", -1, &(a->ns1__ThirdPartyProductDetails::ExchangeId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "OfferingPrice", -1, &(a->ns1__ThirdPartyProductDetails::OfferingPrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Condition", -1, &(a->ns1__ThirdPartyProductDetails::Condition), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ConditionType", -1, &(a->ns1__ThirdPartyProductDetails::ConditionType), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeAvailability", -1, &(a->ns1__ThirdPartyProductDetails::ExchangeAvailability), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SellerCountry", -1, &(a->ns1__ThirdPartyProductDetails::SellerCountry), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SellerState", -1, &(a->ns1__ThirdPartyProductDetails::SellerState), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ShipComments", -1, &(a->ns1__ThirdPartyProductDetails::ShipComments), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SellerRating", -1, &(a->ns1__ThirdPartyProductDetails::SellerRating), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ThirdPartyProductDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ThirdPartyProductDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ThirdPartyProductDetails * SOAP_FMAC4 soap_get_ns1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ThirdPartyProductDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ThirdPartyProductDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ThirdPartyProductDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ThirdPartyProductDetails * SOAP_FMAC4 soap_in_ns1__ThirdPartyProductDetails(struct soap *soap, const char *tag, ns1__ThirdPartyProductDetails *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ThirdPartyProductDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ThirdPartyProductDetails, sizeof(ns1__ThirdPartyProductDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ThirdPartyProductDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ThirdPartyProductDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OfferingType1 = 1;
	size_t soap_flag_SellerId1 = 1;
	size_t soap_flag_SellerNickname1 = 1;
	size_t soap_flag_ExchangeId1 = 1;
	size_t soap_flag_OfferingPrice1 = 1;
	size_t soap_flag_Condition1 = 1;
	size_t soap_flag_ConditionType1 = 1;
	size_t soap_flag_ExchangeAvailability1 = 1;
	size_t soap_flag_SellerCountry1 = 1;
	size_t soap_flag_SellerState1 = 1;
	size_t soap_flag_ShipComments1 = 1;
	size_t soap_flag_SellerRating1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OfferingType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "OfferingType", &(a->ns1__ThirdPartyProductDetails::OfferingType), "xsd:string"))
				{	soap_flag_OfferingType1--;
					continue;
				}
			if (soap_flag_SellerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SellerId", &(a->ns1__ThirdPartyProductDetails::SellerId), "xsd:string"))
				{	soap_flag_SellerId1--;
					continue;
				}
			if (soap_flag_SellerNickname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SellerNickname", &(a->ns1__ThirdPartyProductDetails::SellerNickname), "xsd:string"))
				{	soap_flag_SellerNickname1--;
					continue;
				}
			if (soap_flag_ExchangeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeId", &(a->ns1__ThirdPartyProductDetails::ExchangeId), "xsd:string"))
				{	soap_flag_ExchangeId1--;
					continue;
				}
			if (soap_flag_OfferingPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "OfferingPrice", &(a->ns1__ThirdPartyProductDetails::OfferingPrice), "xsd:string"))
				{	soap_flag_OfferingPrice1--;
					continue;
				}
			if (soap_flag_Condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Condition", &(a->ns1__ThirdPartyProductDetails::Condition), "xsd:string"))
				{	soap_flag_Condition1--;
					continue;
				}
			if (soap_flag_ConditionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ConditionType", &(a->ns1__ThirdPartyProductDetails::ConditionType), "xsd:string"))
				{	soap_flag_ConditionType1--;
					continue;
				}
			if (soap_flag_ExchangeAvailability1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeAvailability", &(a->ns1__ThirdPartyProductDetails::ExchangeAvailability), "xsd:string"))
				{	soap_flag_ExchangeAvailability1--;
					continue;
				}
			if (soap_flag_SellerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SellerCountry", &(a->ns1__ThirdPartyProductDetails::SellerCountry), "xsd:string"))
				{	soap_flag_SellerCountry1--;
					continue;
				}
			if (soap_flag_SellerState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SellerState", &(a->ns1__ThirdPartyProductDetails::SellerState), "xsd:string"))
				{	soap_flag_SellerState1--;
					continue;
				}
			if (soap_flag_ShipComments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ShipComments", &(a->ns1__ThirdPartyProductDetails::ShipComments), "xsd:string"))
				{	soap_flag_ShipComments1--;
					continue;
				}
			if (soap_flag_SellerRating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SellerRating", &(a->ns1__ThirdPartyProductDetails::SellerRating), "xsd:string"))
				{	soap_flag_SellerRating1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ThirdPartyProductDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ThirdPartyProductDetails, 0, sizeof(ns1__ThirdPartyProductDetails), 0, soap_copy_ns1__ThirdPartyProductDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ThirdPartyProductDetails * SOAP_FMAC6 soap_new_ns1__ThirdPartyProductDetails(struct soap *soap, int n)
{	return soap_instantiate_ns1__ThirdPartyProductDetails(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ThirdPartyProductDetails * SOAP_FMAC4 soap_instantiate_ns1__ThirdPartyProductDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ThirdPartyProductDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ThirdPartyProductDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ThirdPartyProductDetails;
		if (size)
			*size = sizeof(ns1__ThirdPartyProductDetails);
		((ns1__ThirdPartyProductDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ThirdPartyProductDetails[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ThirdPartyProductDetails);
		for (int i = 0; i < n; i++)
			((ns1__ThirdPartyProductDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ThirdPartyProductDetails*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ThirdPartyProductDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ThirdPartyProductDetails %p -> %p\n", q, p));
	*(ns1__ThirdPartyProductDetails*)p = *(ns1__ThirdPartyProductDetails*)q;
}

void ThirdPartyProductDetailsArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ThirdPartyProductDetailsArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ThirdPartyProductDetailsArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ThirdPartyProductDetails(soap, this->__ptr + i);
		}
}

int ThirdPartyProductDetailsArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ThirdPartyProductDetailsArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ThirdPartyProductDetailsArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ThirdPartyProductDetailsArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ThirdPartyProductDetailsArray(struct soap *soap, const char *tag, int id, const ThirdPartyProductDetailsArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ThirdPartyProductDetails", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ThirdPartyProductDetailsArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ThirdPartyProductDetails(soap, "item", -1, &a->__ptr[i], "ns1:ThirdPartyProductDetails");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ThirdPartyProductDetailsArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ThirdPartyProductDetailsArray(soap, this, tag, type);
}

SOAP_FMAC3 ThirdPartyProductDetailsArray * SOAP_FMAC4 soap_get_ThirdPartyProductDetailsArray(struct soap *soap, ThirdPartyProductDetailsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ThirdPartyProductDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ThirdPartyProductDetailsArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ThirdPartyProductDetailsArray(soap, tag, this, type);
}

SOAP_FMAC3 ThirdPartyProductDetailsArray * SOAP_FMAC4 soap_in_ThirdPartyProductDetailsArray(struct soap *soap, const char *tag, ThirdPartyProductDetailsArray *a, const char *type)
{	int i, j;
	ns1__ThirdPartyProductDetails **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ThirdPartyProductDetailsArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ThirdPartyProductDetailsArray, sizeof(ThirdPartyProductDetailsArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ThirdPartyProductDetails **)soap_malloc(soap, sizeof(ns1__ThirdPartyProductDetails *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ThirdPartyProductDetails(soap, NULL, a->__ptr + i, "ns1:ThirdPartyProductDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ThirdPartyProductDetails **)soap_push_block(soap, NULL, sizeof(ns1__ThirdPartyProductDetails *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ThirdPartyProductDetails(soap, NULL, p, "ns1:ThirdPartyProductDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__ThirdPartyProductDetails **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ThirdPartyProductDetailsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ThirdPartyProductDetailsArray, 0, sizeof(ThirdPartyProductDetailsArray), 0, soap_copy_ThirdPartyProductDetailsArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ThirdPartyProductDetailsArray * SOAP_FMAC6 soap_new_ThirdPartyProductDetailsArray(struct soap *soap, int n)
{	return soap_instantiate_ThirdPartyProductDetailsArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ThirdPartyProductDetailsArray(struct soap *soap, ThirdPartyProductDetailsArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ThirdPartyProductDetailsArray * SOAP_FMAC4 soap_instantiate_ThirdPartyProductDetailsArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ThirdPartyProductDetailsArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ThirdPartyProductDetailsArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ThirdPartyProductDetailsArray;
		if (size)
			*size = sizeof(ThirdPartyProductDetailsArray);
		((ThirdPartyProductDetailsArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ThirdPartyProductDetailsArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ThirdPartyProductDetailsArray);
		for (int i = 0; i < n; i++)
			((ThirdPartyProductDetailsArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ThirdPartyProductDetailsArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ThirdPartyProductDetailsArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ThirdPartyProductDetailsArray %p -> %p\n", q, p));
	*(ThirdPartyProductDetailsArray*)p = *(ThirdPartyProductDetailsArray*)q;
}

void ns1__ThirdPartyProductInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ThirdPartyProductInfo::ThirdPartyProductDetails = NULL;
	/* transient soap skipped */
}

void ns1__ThirdPartyProductInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToThirdPartyProductDetailsArray(soap, &this->ns1__ThirdPartyProductInfo::ThirdPartyProductDetails);
	/* transient soap skipped */
}

int ns1__ThirdPartyProductInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ThirdPartyProductInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ThirdPartyProductInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ThirdPartyProductInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ThirdPartyProductInfo(struct soap *soap, const char *tag, int id, const ns1__ThirdPartyProductInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ThirdPartyProductInfo), type))
		return soap->error;
	if (soap_out_PointerToThirdPartyProductDetailsArray(soap, "ThirdPartyProductDetails", -1, &(a->ns1__ThirdPartyProductInfo::ThirdPartyProductDetails), "ns1:ThirdPartyProductDetails"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ThirdPartyProductInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ThirdPartyProductInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ThirdPartyProductInfo * SOAP_FMAC4 soap_get_ns1__ThirdPartyProductInfo(struct soap *soap, ns1__ThirdPartyProductInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ThirdPartyProductInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ThirdPartyProductInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ThirdPartyProductInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ThirdPartyProductInfo * SOAP_FMAC4 soap_in_ns1__ThirdPartyProductInfo(struct soap *soap, const char *tag, ns1__ThirdPartyProductInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ThirdPartyProductInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ThirdPartyProductInfo, sizeof(ns1__ThirdPartyProductInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ThirdPartyProductInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ThirdPartyProductInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ThirdPartyProductDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ThirdPartyProductDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToThirdPartyProductDetailsArray(soap, "ThirdPartyProductDetails", &(a->ns1__ThirdPartyProductInfo::ThirdPartyProductDetails), "ns1:ThirdPartyProductDetails"))
				{	soap_flag_ThirdPartyProductDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ThirdPartyProductInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ThirdPartyProductInfo, 0, sizeof(ns1__ThirdPartyProductInfo), 0, soap_copy_ns1__ThirdPartyProductInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ThirdPartyProductDetails1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ThirdPartyProductInfo * SOAP_FMAC6 soap_new_ns1__ThirdPartyProductInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__ThirdPartyProductInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ThirdPartyProductInfo(struct soap *soap, ns1__ThirdPartyProductInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ThirdPartyProductInfo * SOAP_FMAC4 soap_instantiate_ns1__ThirdPartyProductInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ThirdPartyProductInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ThirdPartyProductInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ThirdPartyProductInfo;
		if (size)
			*size = sizeof(ns1__ThirdPartyProductInfo);
		((ns1__ThirdPartyProductInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ThirdPartyProductInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ThirdPartyProductInfo);
		for (int i = 0; i < n; i++)
			((ns1__ThirdPartyProductInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ThirdPartyProductInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ThirdPartyProductInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ThirdPartyProductInfo %p -> %p\n", q, p));
	*(ns1__ThirdPartyProductInfo*)p = *(ns1__ThirdPartyProductInfo*)q;
}

void ns1__Feedback::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Feedback::FeedbackRating = NULL;
	this->ns1__Feedback::FeedbackComments = NULL;
	this->ns1__Feedback::FeedbackDate = NULL;
	this->ns1__Feedback::FeedbackRater = NULL;
	/* transient soap skipped */
}

void ns1__Feedback::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Feedback::FeedbackRating);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Feedback::FeedbackComments);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Feedback::FeedbackDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Feedback::FeedbackRater);
	/* transient soap skipped */
}

int ns1__Feedback::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Feedback);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Feedback::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Feedback(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Feedback(struct soap *soap, const char *tag, int id, const ns1__Feedback *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Feedback), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "FeedbackRating", -1, &(a->ns1__Feedback::FeedbackRating), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "FeedbackComments", -1, &(a->ns1__Feedback::FeedbackComments), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "FeedbackDate", -1, &(a->ns1__Feedback::FeedbackDate), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "FeedbackRater", -1, &(a->ns1__Feedback::FeedbackRater), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Feedback::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Feedback(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Feedback * SOAP_FMAC4 soap_get_ns1__Feedback(struct soap *soap, ns1__Feedback *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Feedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Feedback::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Feedback(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Feedback * SOAP_FMAC4 soap_in_ns1__Feedback(struct soap *soap, const char *tag, ns1__Feedback *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Feedback *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Feedback, sizeof(ns1__Feedback), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Feedback)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Feedback *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FeedbackRating1 = 1;
	size_t soap_flag_FeedbackComments1 = 1;
	size_t soap_flag_FeedbackDate1 = 1;
	size_t soap_flag_FeedbackRater1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeedbackRating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "FeedbackRating", &(a->ns1__Feedback::FeedbackRating), "xsd:string"))
				{	soap_flag_FeedbackRating1--;
					continue;
				}
			if (soap_flag_FeedbackComments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "FeedbackComments", &(a->ns1__Feedback::FeedbackComments), "xsd:string"))
				{	soap_flag_FeedbackComments1--;
					continue;
				}
			if (soap_flag_FeedbackDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "FeedbackDate", &(a->ns1__Feedback::FeedbackDate), "xsd:string"))
				{	soap_flag_FeedbackDate1--;
					continue;
				}
			if (soap_flag_FeedbackRater1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "FeedbackRater", &(a->ns1__Feedback::FeedbackRater), "xsd:string"))
				{	soap_flag_FeedbackRater1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Feedback *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Feedback, 0, sizeof(ns1__Feedback), 0, soap_copy_ns1__Feedback);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Feedback * SOAP_FMAC6 soap_new_ns1__Feedback(struct soap *soap, int n)
{	return soap_instantiate_ns1__Feedback(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Feedback(struct soap *soap, ns1__Feedback *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Feedback * SOAP_FMAC4 soap_instantiate_ns1__Feedback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Feedback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Feedback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Feedback;
		if (size)
			*size = sizeof(ns1__Feedback);
		((ns1__Feedback*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Feedback[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Feedback);
		for (int i = 0; i < n; i++)
			((ns1__Feedback*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Feedback*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Feedback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Feedback %p -> %p\n", q, p));
	*(ns1__Feedback*)p = *(ns1__Feedback*)q;
}

void FeedbackArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void FeedbackArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_FeedbackArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__Feedback(soap, this->__ptr + i);
		}
}

int FeedbackArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_FeedbackArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int FeedbackArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_FeedbackArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FeedbackArray(struct soap *soap, const char *tag, int id, const FeedbackArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:Feedback", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_FeedbackArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Feedback(soap, "item", -1, &a->__ptr[i], "ns1:Feedback");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *FeedbackArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_FeedbackArray(soap, this, tag, type);
}

SOAP_FMAC3 FeedbackArray * SOAP_FMAC4 soap_get_FeedbackArray(struct soap *soap, FeedbackArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_FeedbackArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *FeedbackArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_FeedbackArray(soap, tag, this, type);
}

SOAP_FMAC3 FeedbackArray * SOAP_FMAC4 soap_in_FeedbackArray(struct soap *soap, const char *tag, FeedbackArray *a, const char *type)
{	int i, j;
	ns1__Feedback **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (FeedbackArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FeedbackArray, sizeof(FeedbackArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__Feedback **)soap_malloc(soap, sizeof(ns1__Feedback *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Feedback(soap, NULL, a->__ptr + i, "ns1:Feedback"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Feedback **)soap_push_block(soap, NULL, sizeof(ns1__Feedback *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Feedback(soap, NULL, p, "ns1:Feedback"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__Feedback **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (FeedbackArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FeedbackArray, 0, sizeof(FeedbackArray), 0, soap_copy_FeedbackArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 FeedbackArray * SOAP_FMAC6 soap_new_FeedbackArray(struct soap *soap, int n)
{	return soap_instantiate_FeedbackArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_FeedbackArray(struct soap *soap, FeedbackArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 FeedbackArray * SOAP_FMAC4 soap_instantiate_FeedbackArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_FeedbackArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FeedbackArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new FeedbackArray;
		if (size)
			*size = sizeof(FeedbackArray);
		((FeedbackArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new FeedbackArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(FeedbackArray);
		for (int i = 0; i < n; i++)
			((FeedbackArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (FeedbackArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_FeedbackArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying FeedbackArray %p -> %p\n", q, p));
	*(FeedbackArray*)p = *(FeedbackArray*)q;
}

void ns1__SellerFeedback::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SellerFeedback::Feedback = NULL;
	/* transient soap skipped */
}

void ns1__SellerFeedback::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToFeedbackArray(soap, &this->ns1__SellerFeedback::Feedback);
	/* transient soap skipped */
}

int ns1__SellerFeedback::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellerFeedback);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SellerFeedback::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellerFeedback(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerFeedback(struct soap *soap, const char *tag, int id, const ns1__SellerFeedback *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerFeedback), type))
		return soap->error;
	if (soap_out_PointerToFeedbackArray(soap, "Feedback", -1, &(a->ns1__SellerFeedback::Feedback), "ns1:Feedback"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellerFeedback::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellerFeedback(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellerFeedback * SOAP_FMAC4 soap_get_ns1__SellerFeedback(struct soap *soap, ns1__SellerFeedback *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerFeedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SellerFeedback::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellerFeedback(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellerFeedback * SOAP_FMAC4 soap_in_ns1__SellerFeedback(struct soap *soap, const char *tag, ns1__SellerFeedback *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellerFeedback *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerFeedback, sizeof(ns1__SellerFeedback), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellerFeedback)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellerFeedback *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Feedback1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Feedback1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToFeedbackArray(soap, "Feedback", &(a->ns1__SellerFeedback::Feedback), "ns1:Feedback"))
				{	soap_flag_Feedback1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellerFeedback *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerFeedback, 0, sizeof(ns1__SellerFeedback), 0, soap_copy_ns1__SellerFeedback);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Feedback1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SellerFeedback * SOAP_FMAC6 soap_new_ns1__SellerFeedback(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerFeedback(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerFeedback(struct soap *soap, ns1__SellerFeedback *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SellerFeedback * SOAP_FMAC4 soap_instantiate_ns1__SellerFeedback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerFeedback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerFeedback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SellerFeedback;
		if (size)
			*size = sizeof(ns1__SellerFeedback);
		((ns1__SellerFeedback*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SellerFeedback[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellerFeedback);
		for (int i = 0; i < n; i++)
			((ns1__SellerFeedback*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellerFeedback*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerFeedback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellerFeedback %p -> %p\n", q, p));
	*(ns1__SellerFeedback*)p = *(ns1__SellerFeedback*)q;
}

void ns1__ListingProductDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ListingProductDetails::ExchangeId = NULL;
	this->ns1__ListingProductDetails::ListingId = NULL;
	this->ns1__ListingProductDetails::ExchangeTitle = NULL;
	this->ns1__ListingProductDetails::ExchangePrice = NULL;
	this->ns1__ListingProductDetails::ExchangeAsin = NULL;
	this->ns1__ListingProductDetails::ExchangeEndDate = NULL;
	this->ns1__ListingProductDetails::ExchangeTinyImage = NULL;
	this->ns1__ListingProductDetails::ExchangeSellerId = NULL;
	this->ns1__ListingProductDetails::ExchangeSellerNickname = NULL;
	this->ns1__ListingProductDetails::ExchangeStartDate = NULL;
	this->ns1__ListingProductDetails::ExchangeStatus = NULL;
	this->ns1__ListingProductDetails::ExchangeQuantity = NULL;
	this->ns1__ListingProductDetails::ExchangeQuantityAllocated = NULL;
	this->ns1__ListingProductDetails::ExchangeFeaturedCategory = NULL;
	this->ns1__ListingProductDetails::ExchangeCondition = NULL;
	this->ns1__ListingProductDetails::ExchangeConditionType = NULL;
	this->ns1__ListingProductDetails::ExchangeAvailability = NULL;
	this->ns1__ListingProductDetails::ExchangeOfferingType = NULL;
	this->ns1__ListingProductDetails::ExchangeSellerState = NULL;
	this->ns1__ListingProductDetails::ExchangeSellerCountry = NULL;
	this->ns1__ListingProductDetails::ExchangeSellerRating = NULL;
	/* transient soap skipped */
}

void ns1__ListingProductDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ListingId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeTitle);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangePrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeAsin);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeEndDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeTinyImage);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeSellerId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeSellerNickname);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeStartDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeStatus);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeQuantity);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeQuantityAllocated);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeFeaturedCategory);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeCondition);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeConditionType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeAvailability);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeOfferingType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeSellerState);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeSellerCountry);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListingProductDetails::ExchangeSellerRating);
	/* transient soap skipped */
}

int ns1__ListingProductDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListingProductDetails);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ListingProductDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListingProductDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListingProductDetails(struct soap *soap, const char *tag, int id, const ns1__ListingProductDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListingProductDetails), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeId", -1, &(a->ns1__ListingProductDetails::ExchangeId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ListingId", -1, &(a->ns1__ListingProductDetails::ListingId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeTitle", -1, &(a->ns1__ListingProductDetails::ExchangeTitle), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangePrice", -1, &(a->ns1__ListingProductDetails::ExchangePrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeAsin", -1, &(a->ns1__ListingProductDetails::ExchangeAsin), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeEndDate", -1, &(a->ns1__ListingProductDetails::ExchangeEndDate), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeTinyImage", -1, &(a->ns1__ListingProductDetails::ExchangeTinyImage), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeSellerId", -1, &(a->ns1__ListingProductDetails::ExchangeSellerId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeSellerNickname", -1, &(a->ns1__ListingProductDetails::ExchangeSellerNickname), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeStartDate", -1, &(a->ns1__ListingProductDetails::ExchangeStartDate), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeStatus", -1, &(a->ns1__ListingProductDetails::ExchangeStatus), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeQuantity", -1, &(a->ns1__ListingProductDetails::ExchangeQuantity), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeQuantityAllocated", -1, &(a->ns1__ListingProductDetails::ExchangeQuantityAllocated), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeFeaturedCategory", -1, &(a->ns1__ListingProductDetails::ExchangeFeaturedCategory), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeCondition", -1, &(a->ns1__ListingProductDetails::ExchangeCondition), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeConditionType", -1, &(a->ns1__ListingProductDetails::ExchangeConditionType), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeAvailability", -1, &(a->ns1__ListingProductDetails::ExchangeAvailability), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeOfferingType", -1, &(a->ns1__ListingProductDetails::ExchangeOfferingType), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeSellerState", -1, &(a->ns1__ListingProductDetails::ExchangeSellerState), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeSellerCountry", -1, &(a->ns1__ListingProductDetails::ExchangeSellerCountry), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ExchangeSellerRating", -1, &(a->ns1__ListingProductDetails::ExchangeSellerRating), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListingProductDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListingProductDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListingProductDetails * SOAP_FMAC4 soap_get_ns1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListingProductDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ListingProductDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListingProductDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListingProductDetails * SOAP_FMAC4 soap_in_ns1__ListingProductDetails(struct soap *soap, const char *tag, ns1__ListingProductDetails *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListingProductDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListingProductDetails, sizeof(ns1__ListingProductDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListingProductDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListingProductDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ExchangeId1 = 1;
	size_t soap_flag_ListingId1 = 1;
	size_t soap_flag_ExchangeTitle1 = 1;
	size_t soap_flag_ExchangePrice1 = 1;
	size_t soap_flag_ExchangeAsin1 = 1;
	size_t soap_flag_ExchangeEndDate1 = 1;
	size_t soap_flag_ExchangeTinyImage1 = 1;
	size_t soap_flag_ExchangeSellerId1 = 1;
	size_t soap_flag_ExchangeSellerNickname1 = 1;
	size_t soap_flag_ExchangeStartDate1 = 1;
	size_t soap_flag_ExchangeStatus1 = 1;
	size_t soap_flag_ExchangeQuantity1 = 1;
	size_t soap_flag_ExchangeQuantityAllocated1 = 1;
	size_t soap_flag_ExchangeFeaturedCategory1 = 1;
	size_t soap_flag_ExchangeCondition1 = 1;
	size_t soap_flag_ExchangeConditionType1 = 1;
	size_t soap_flag_ExchangeAvailability1 = 1;
	size_t soap_flag_ExchangeOfferingType1 = 1;
	size_t soap_flag_ExchangeSellerState1 = 1;
	size_t soap_flag_ExchangeSellerCountry1 = 1;
	size_t soap_flag_ExchangeSellerRating1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeId", &(a->ns1__ListingProductDetails::ExchangeId), "xsd:string"))
				{	soap_flag_ExchangeId1--;
					continue;
				}
			if (soap_flag_ListingId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ListingId", &(a->ns1__ListingProductDetails::ListingId), "xsd:string"))
				{	soap_flag_ListingId1--;
					continue;
				}
			if (soap_flag_ExchangeTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeTitle", &(a->ns1__ListingProductDetails::ExchangeTitle), "xsd:string"))
				{	soap_flag_ExchangeTitle1--;
					continue;
				}
			if (soap_flag_ExchangePrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangePrice", &(a->ns1__ListingProductDetails::ExchangePrice), "xsd:string"))
				{	soap_flag_ExchangePrice1--;
					continue;
				}
			if (soap_flag_ExchangeAsin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeAsin", &(a->ns1__ListingProductDetails::ExchangeAsin), "xsd:string"))
				{	soap_flag_ExchangeAsin1--;
					continue;
				}
			if (soap_flag_ExchangeEndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeEndDate", &(a->ns1__ListingProductDetails::ExchangeEndDate), "xsd:string"))
				{	soap_flag_ExchangeEndDate1--;
					continue;
				}
			if (soap_flag_ExchangeTinyImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeTinyImage", &(a->ns1__ListingProductDetails::ExchangeTinyImage), "xsd:string"))
				{	soap_flag_ExchangeTinyImage1--;
					continue;
				}
			if (soap_flag_ExchangeSellerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeSellerId", &(a->ns1__ListingProductDetails::ExchangeSellerId), "xsd:string"))
				{	soap_flag_ExchangeSellerId1--;
					continue;
				}
			if (soap_flag_ExchangeSellerNickname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeSellerNickname", &(a->ns1__ListingProductDetails::ExchangeSellerNickname), "xsd:string"))
				{	soap_flag_ExchangeSellerNickname1--;
					continue;
				}
			if (soap_flag_ExchangeStartDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeStartDate", &(a->ns1__ListingProductDetails::ExchangeStartDate), "xsd:string"))
				{	soap_flag_ExchangeStartDate1--;
					continue;
				}
			if (soap_flag_ExchangeStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeStatus", &(a->ns1__ListingProductDetails::ExchangeStatus), "xsd:string"))
				{	soap_flag_ExchangeStatus1--;
					continue;
				}
			if (soap_flag_ExchangeQuantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeQuantity", &(a->ns1__ListingProductDetails::ExchangeQuantity), "xsd:string"))
				{	soap_flag_ExchangeQuantity1--;
					continue;
				}
			if (soap_flag_ExchangeQuantityAllocated1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeQuantityAllocated", &(a->ns1__ListingProductDetails::ExchangeQuantityAllocated), "xsd:string"))
				{	soap_flag_ExchangeQuantityAllocated1--;
					continue;
				}
			if (soap_flag_ExchangeFeaturedCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeFeaturedCategory", &(a->ns1__ListingProductDetails::ExchangeFeaturedCategory), "xsd:string"))
				{	soap_flag_ExchangeFeaturedCategory1--;
					continue;
				}
			if (soap_flag_ExchangeCondition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeCondition", &(a->ns1__ListingProductDetails::ExchangeCondition), "xsd:string"))
				{	soap_flag_ExchangeCondition1--;
					continue;
				}
			if (soap_flag_ExchangeConditionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeConditionType", &(a->ns1__ListingProductDetails::ExchangeConditionType), "xsd:string"))
				{	soap_flag_ExchangeConditionType1--;
					continue;
				}
			if (soap_flag_ExchangeAvailability1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeAvailability", &(a->ns1__ListingProductDetails::ExchangeAvailability), "xsd:string"))
				{	soap_flag_ExchangeAvailability1--;
					continue;
				}
			if (soap_flag_ExchangeOfferingType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeOfferingType", &(a->ns1__ListingProductDetails::ExchangeOfferingType), "xsd:string"))
				{	soap_flag_ExchangeOfferingType1--;
					continue;
				}
			if (soap_flag_ExchangeSellerState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeSellerState", &(a->ns1__ListingProductDetails::ExchangeSellerState), "xsd:string"))
				{	soap_flag_ExchangeSellerState1--;
					continue;
				}
			if (soap_flag_ExchangeSellerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeSellerCountry", &(a->ns1__ListingProductDetails::ExchangeSellerCountry), "xsd:string"))
				{	soap_flag_ExchangeSellerCountry1--;
					continue;
				}
			if (soap_flag_ExchangeSellerRating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ExchangeSellerRating", &(a->ns1__ListingProductDetails::ExchangeSellerRating), "xsd:string"))
				{	soap_flag_ExchangeSellerRating1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListingProductDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListingProductDetails, 0, sizeof(ns1__ListingProductDetails), 0, soap_copy_ns1__ListingProductDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ListingProductDetails * SOAP_FMAC6 soap_new_ns1__ListingProductDetails(struct soap *soap, int n)
{	return soap_instantiate_ns1__ListingProductDetails(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ListingProductDetails * SOAP_FMAC4 soap_instantiate_ns1__ListingProductDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListingProductDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListingProductDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ListingProductDetails;
		if (size)
			*size = sizeof(ns1__ListingProductDetails);
		((ns1__ListingProductDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ListingProductDetails[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListingProductDetails);
		for (int i = 0; i < n; i++)
			((ns1__ListingProductDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListingProductDetails*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListingProductDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListingProductDetails %p -> %p\n", q, p));
	*(ns1__ListingProductDetails*)p = *(ns1__ListingProductDetails*)q;
}

void ListingProductDetailsArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ListingProductDetailsArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ListingProductDetailsArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ListingProductDetails(soap, this->__ptr + i);
		}
}

int ListingProductDetailsArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ListingProductDetailsArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ListingProductDetailsArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ListingProductDetailsArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ListingProductDetailsArray(struct soap *soap, const char *tag, int id, const ListingProductDetailsArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ListingProductDetails", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ListingProductDetailsArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ListingProductDetails(soap, "item", -1, &a->__ptr[i], "ns1:ListingProductDetails");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ListingProductDetailsArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ListingProductDetailsArray(soap, this, tag, type);
}

SOAP_FMAC3 ListingProductDetailsArray * SOAP_FMAC4 soap_get_ListingProductDetailsArray(struct soap *soap, ListingProductDetailsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ListingProductDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ListingProductDetailsArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ListingProductDetailsArray(soap, tag, this, type);
}

SOAP_FMAC3 ListingProductDetailsArray * SOAP_FMAC4 soap_in_ListingProductDetailsArray(struct soap *soap, const char *tag, ListingProductDetailsArray *a, const char *type)
{	int i, j;
	ns1__ListingProductDetails **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ListingProductDetailsArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ListingProductDetailsArray, sizeof(ListingProductDetailsArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ListingProductDetails **)soap_malloc(soap, sizeof(ns1__ListingProductDetails *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ListingProductDetails(soap, NULL, a->__ptr + i, "ns1:ListingProductDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ListingProductDetails **)soap_push_block(soap, NULL, sizeof(ns1__ListingProductDetails *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ListingProductDetails(soap, NULL, p, "ns1:ListingProductDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__ListingProductDetails **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ListingProductDetailsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ListingProductDetailsArray, 0, sizeof(ListingProductDetailsArray), 0, soap_copy_ListingProductDetailsArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ListingProductDetailsArray * SOAP_FMAC6 soap_new_ListingProductDetailsArray(struct soap *soap, int n)
{	return soap_instantiate_ListingProductDetailsArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ListingProductDetailsArray(struct soap *soap, ListingProductDetailsArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ListingProductDetailsArray * SOAP_FMAC4 soap_instantiate_ListingProductDetailsArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ListingProductDetailsArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ListingProductDetailsArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ListingProductDetailsArray;
		if (size)
			*size = sizeof(ListingProductDetailsArray);
		((ListingProductDetailsArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ListingProductDetailsArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ListingProductDetailsArray);
		for (int i = 0; i < n; i++)
			((ListingProductDetailsArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ListingProductDetailsArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ListingProductDetailsArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ListingProductDetailsArray %p -> %p\n", q, p));
	*(ListingProductDetailsArray*)p = *(ListingProductDetailsArray*)q;
}

void ns1__ListingProductInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ListingProductInfo::ListingProductDetails = NULL;
	/* transient soap skipped */
}

void ns1__ListingProductInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToListingProductDetailsArray(soap, &this->ns1__ListingProductInfo::ListingProductDetails);
	/* transient soap skipped */
}

int ns1__ListingProductInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListingProductInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ListingProductInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListingProductInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListingProductInfo(struct soap *soap, const char *tag, int id, const ns1__ListingProductInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListingProductInfo), type))
		return soap->error;
	if (soap_out_PointerToListingProductDetailsArray(soap, "ListingProductDetails", -1, &(a->ns1__ListingProductInfo::ListingProductDetails), "ns1:ListingProductDetails"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListingProductInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListingProductInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListingProductInfo * SOAP_FMAC4 soap_get_ns1__ListingProductInfo(struct soap *soap, ns1__ListingProductInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListingProductInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ListingProductInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListingProductInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListingProductInfo * SOAP_FMAC4 soap_in_ns1__ListingProductInfo(struct soap *soap, const char *tag, ns1__ListingProductInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListingProductInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListingProductInfo, sizeof(ns1__ListingProductInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListingProductInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListingProductInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ListingProductDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListingProductDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToListingProductDetailsArray(soap, "ListingProductDetails", &(a->ns1__ListingProductInfo::ListingProductDetails), "ns1:ListingProductDetails"))
				{	soap_flag_ListingProductDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListingProductInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListingProductInfo, 0, sizeof(ns1__ListingProductInfo), 0, soap_copy_ns1__ListingProductInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ListingProductDetails1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ListingProductInfo * SOAP_FMAC6 soap_new_ns1__ListingProductInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__ListingProductInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ListingProductInfo(struct soap *soap, ns1__ListingProductInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ListingProductInfo * SOAP_FMAC4 soap_instantiate_ns1__ListingProductInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListingProductInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListingProductInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ListingProductInfo;
		if (size)
			*size = sizeof(ns1__ListingProductInfo);
		((ns1__ListingProductInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ListingProductInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListingProductInfo);
		for (int i = 0; i < n; i++)
			((ns1__ListingProductInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListingProductInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListingProductInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListingProductInfo %p -> %p\n", q, p));
	*(ns1__ListingProductInfo*)p = *(ns1__ListingProductInfo*)q;
}

void SellerSearchDetailsArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void SellerSearchDetailsArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_SellerSearchDetailsArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__SellerSearchDetails(soap, this->__ptr + i);
		}
}

int SellerSearchDetailsArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_SellerSearchDetailsArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int SellerSearchDetailsArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_SellerSearchDetailsArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SellerSearchDetailsArray(struct soap *soap, const char *tag, int id, const SellerSearchDetailsArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:SellerSearchDetails", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_SellerSearchDetailsArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__SellerSearchDetails(soap, "item", -1, &a->__ptr[i], "ns1:SellerSearchDetails");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *SellerSearchDetailsArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SellerSearchDetailsArray(soap, this, tag, type);
}

SOAP_FMAC3 SellerSearchDetailsArray * SOAP_FMAC4 soap_get_SellerSearchDetailsArray(struct soap *soap, SellerSearchDetailsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_SellerSearchDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *SellerSearchDetailsArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_SellerSearchDetailsArray(soap, tag, this, type);
}

SOAP_FMAC3 SellerSearchDetailsArray * SOAP_FMAC4 soap_in_SellerSearchDetailsArray(struct soap *soap, const char *tag, SellerSearchDetailsArray *a, const char *type)
{	int i, j;
	ns1__SellerSearchDetails **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (SellerSearchDetailsArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SellerSearchDetailsArray, sizeof(SellerSearchDetailsArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__SellerSearchDetails **)soap_malloc(soap, sizeof(ns1__SellerSearchDetails *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__SellerSearchDetails(soap, NULL, a->__ptr + i, "ns1:SellerSearchDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__SellerSearchDetails **)soap_push_block(soap, NULL, sizeof(ns1__SellerSearchDetails *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__SellerSearchDetails(soap, NULL, p, "ns1:SellerSearchDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__SellerSearchDetails **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SellerSearchDetailsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SellerSearchDetailsArray, 0, sizeof(SellerSearchDetailsArray), 0, soap_copy_SellerSearchDetailsArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 SellerSearchDetailsArray * SOAP_FMAC6 soap_new_SellerSearchDetailsArray(struct soap *soap, int n)
{	return soap_instantiate_SellerSearchDetailsArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SellerSearchDetailsArray(struct soap *soap, SellerSearchDetailsArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 SellerSearchDetailsArray * SOAP_FMAC4 soap_instantiate_SellerSearchDetailsArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SellerSearchDetailsArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SellerSearchDetailsArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new SellerSearchDetailsArray;
		if (size)
			*size = sizeof(SellerSearchDetailsArray);
		((SellerSearchDetailsArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new SellerSearchDetailsArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(SellerSearchDetailsArray);
		for (int i = 0; i < n; i++)
			((SellerSearchDetailsArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (SellerSearchDetailsArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SellerSearchDetailsArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying SellerSearchDetailsArray %p -> %p\n", q, p));
	*(SellerSearchDetailsArray*)p = *(SellerSearchDetailsArray*)q;
}

void ns1__SellerSearchDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SellerSearchDetails::SellerNickname = NULL;
	this->ns1__SellerSearchDetails::StoreId = NULL;
	this->ns1__SellerSearchDetails::StoreName = NULL;
	this->ns1__SellerSearchDetails::NumberOfOpenListings = NULL;
	this->ns1__SellerSearchDetails::ListingProductInfo = NULL;
	/* transient soap skipped */
}

void ns1__SellerSearchDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerSearchDetails::SellerNickname);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerSearchDetails::StoreId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerSearchDetails::StoreName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerSearchDetails::NumberOfOpenListings);
	soap_serialize_PointerTons1__ListingProductInfo(soap, &this->ns1__SellerSearchDetails::ListingProductInfo);
	/* transient soap skipped */
}

int ns1__SellerSearchDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellerSearchDetails);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SellerSearchDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellerSearchDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerSearchDetails(struct soap *soap, const char *tag, int id, const ns1__SellerSearchDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerSearchDetails), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SellerNickname", -1, &(a->ns1__SellerSearchDetails::SellerNickname), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "StoreId", -1, &(a->ns1__SellerSearchDetails::StoreId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "StoreName", -1, &(a->ns1__SellerSearchDetails::StoreName), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfOpenListings", -1, &(a->ns1__SellerSearchDetails::NumberOfOpenListings), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__ListingProductInfo(soap, "ListingProductInfo", -1, &(a->ns1__SellerSearchDetails::ListingProductInfo), "ns1:ListingProductInfo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellerSearchDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellerSearchDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellerSearchDetails * SOAP_FMAC4 soap_get_ns1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SellerSearchDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellerSearchDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellerSearchDetails * SOAP_FMAC4 soap_in_ns1__SellerSearchDetails(struct soap *soap, const char *tag, ns1__SellerSearchDetails *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellerSearchDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerSearchDetails, sizeof(ns1__SellerSearchDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellerSearchDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellerSearchDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SellerNickname1 = 1;
	size_t soap_flag_StoreId1 = 1;
	size_t soap_flag_StoreName1 = 1;
	size_t soap_flag_NumberOfOpenListings1 = 1;
	size_t soap_flag_ListingProductInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellerNickname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SellerNickname", &(a->ns1__SellerSearchDetails::SellerNickname), "xsd:string"))
				{	soap_flag_SellerNickname1--;
					continue;
				}
			if (soap_flag_StoreId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "StoreId", &(a->ns1__SellerSearchDetails::StoreId), "xsd:string"))
				{	soap_flag_StoreId1--;
					continue;
				}
			if (soap_flag_StoreName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "StoreName", &(a->ns1__SellerSearchDetails::StoreName), "xsd:string"))
				{	soap_flag_StoreName1--;
					continue;
				}
			if (soap_flag_NumberOfOpenListings1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfOpenListings", &(a->ns1__SellerSearchDetails::NumberOfOpenListings), "xsd:string"))
				{	soap_flag_NumberOfOpenListings1--;
					continue;
				}
			if (soap_flag_ListingProductInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ListingProductInfo(soap, "ListingProductInfo", &(a->ns1__SellerSearchDetails::ListingProductInfo), "ns1:ListingProductInfo"))
				{	soap_flag_ListingProductInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellerSearchDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerSearchDetails, 0, sizeof(ns1__SellerSearchDetails), 0, soap_copy_ns1__SellerSearchDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SellerSearchDetails * SOAP_FMAC6 soap_new_ns1__SellerSearchDetails(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerSearchDetails(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SellerSearchDetails * SOAP_FMAC4 soap_instantiate_ns1__SellerSearchDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerSearchDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerSearchDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SellerSearchDetails;
		if (size)
			*size = sizeof(ns1__SellerSearchDetails);
		((ns1__SellerSearchDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SellerSearchDetails[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellerSearchDetails);
		for (int i = 0; i < n; i++)
			((ns1__SellerSearchDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellerSearchDetails*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerSearchDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellerSearchDetails %p -> %p\n", q, p));
	*(ns1__SellerSearchDetails*)p = *(ns1__SellerSearchDetails*)q;
}

void SellerProfileDetailsArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void SellerProfileDetailsArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_SellerProfileDetailsArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__SellerProfileDetails(soap, this->__ptr + i);
		}
}

int SellerProfileDetailsArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_SellerProfileDetailsArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int SellerProfileDetailsArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_SellerProfileDetailsArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SellerProfileDetailsArray(struct soap *soap, const char *tag, int id, const SellerProfileDetailsArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:SellerProfileDetails", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_SellerProfileDetailsArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__SellerProfileDetails(soap, "item", -1, &a->__ptr[i], "ns1:SellerProfileDetails");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *SellerProfileDetailsArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SellerProfileDetailsArray(soap, this, tag, type);
}

SOAP_FMAC3 SellerProfileDetailsArray * SOAP_FMAC4 soap_get_SellerProfileDetailsArray(struct soap *soap, SellerProfileDetailsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_SellerProfileDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *SellerProfileDetailsArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_SellerProfileDetailsArray(soap, tag, this, type);
}

SOAP_FMAC3 SellerProfileDetailsArray * SOAP_FMAC4 soap_in_SellerProfileDetailsArray(struct soap *soap, const char *tag, SellerProfileDetailsArray *a, const char *type)
{	int i, j;
	ns1__SellerProfileDetails **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (SellerProfileDetailsArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SellerProfileDetailsArray, sizeof(SellerProfileDetailsArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__SellerProfileDetails **)soap_malloc(soap, sizeof(ns1__SellerProfileDetails *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__SellerProfileDetails(soap, NULL, a->__ptr + i, "ns1:SellerProfileDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__SellerProfileDetails **)soap_push_block(soap, NULL, sizeof(ns1__SellerProfileDetails *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__SellerProfileDetails(soap, NULL, p, "ns1:SellerProfileDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__SellerProfileDetails **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SellerProfileDetailsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SellerProfileDetailsArray, 0, sizeof(SellerProfileDetailsArray), 0, soap_copy_SellerProfileDetailsArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 SellerProfileDetailsArray * SOAP_FMAC6 soap_new_SellerProfileDetailsArray(struct soap *soap, int n)
{	return soap_instantiate_SellerProfileDetailsArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SellerProfileDetailsArray(struct soap *soap, SellerProfileDetailsArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 SellerProfileDetailsArray * SOAP_FMAC4 soap_instantiate_SellerProfileDetailsArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SellerProfileDetailsArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SellerProfileDetailsArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new SellerProfileDetailsArray;
		if (size)
			*size = sizeof(SellerProfileDetailsArray);
		((SellerProfileDetailsArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new SellerProfileDetailsArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(SellerProfileDetailsArray);
		for (int i = 0; i < n; i++)
			((SellerProfileDetailsArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (SellerProfileDetailsArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SellerProfileDetailsArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying SellerProfileDetailsArray %p -> %p\n", q, p));
	*(SellerProfileDetailsArray*)p = *(SellerProfileDetailsArray*)q;
}

void ns1__SellerProfileDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SellerProfileDetails::SellerNickname = NULL;
	this->ns1__SellerProfileDetails::OverallFeedbackRating = NULL;
	this->ns1__SellerProfileDetails::NumberOfFeedback = NULL;
	this->ns1__SellerProfileDetails::NumberOfCanceledBids = NULL;
	this->ns1__SellerProfileDetails::NumberOfCanceledAuctions = NULL;
	this->ns1__SellerProfileDetails::StoreId = NULL;
	this->ns1__SellerProfileDetails::StoreName = NULL;
	this->ns1__SellerProfileDetails::SellerFeedback = NULL;
	/* transient soap skipped */
}

void ns1__SellerProfileDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileDetails::SellerNickname);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileDetails::OverallFeedbackRating);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileDetails::NumberOfFeedback);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileDetails::NumberOfCanceledBids);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileDetails::NumberOfCanceledAuctions);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileDetails::StoreId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SellerProfileDetails::StoreName);
	soap_serialize_PointerTons1__SellerFeedback(soap, &this->ns1__SellerProfileDetails::SellerFeedback);
	/* transient soap skipped */
}

int ns1__SellerProfileDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellerProfileDetails);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SellerProfileDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellerProfileDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerProfileDetails(struct soap *soap, const char *tag, int id, const ns1__SellerProfileDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerProfileDetails), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SellerNickname", -1, &(a->ns1__SellerProfileDetails::SellerNickname), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "OverallFeedbackRating", -1, &(a->ns1__SellerProfileDetails::OverallFeedbackRating), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfFeedback", -1, &(a->ns1__SellerProfileDetails::NumberOfFeedback), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfCanceledBids", -1, &(a->ns1__SellerProfileDetails::NumberOfCanceledBids), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfCanceledAuctions", -1, &(a->ns1__SellerProfileDetails::NumberOfCanceledAuctions), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "StoreId", -1, &(a->ns1__SellerProfileDetails::StoreId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "StoreName", -1, &(a->ns1__SellerProfileDetails::StoreName), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__SellerFeedback(soap, "SellerFeedback", -1, &(a->ns1__SellerProfileDetails::SellerFeedback), "ns1:SellerFeedback"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellerProfileDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellerProfileDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellerProfileDetails * SOAP_FMAC4 soap_get_ns1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerProfileDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SellerProfileDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellerProfileDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellerProfileDetails * SOAP_FMAC4 soap_in_ns1__SellerProfileDetails(struct soap *soap, const char *tag, ns1__SellerProfileDetails *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellerProfileDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerProfileDetails, sizeof(ns1__SellerProfileDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellerProfileDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellerProfileDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SellerNickname1 = 1;
	size_t soap_flag_OverallFeedbackRating1 = 1;
	size_t soap_flag_NumberOfFeedback1 = 1;
	size_t soap_flag_NumberOfCanceledBids1 = 1;
	size_t soap_flag_NumberOfCanceledAuctions1 = 1;
	size_t soap_flag_StoreId1 = 1;
	size_t soap_flag_StoreName1 = 1;
	size_t soap_flag_SellerFeedback1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellerNickname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SellerNickname", &(a->ns1__SellerProfileDetails::SellerNickname), "xsd:string"))
				{	soap_flag_SellerNickname1--;
					continue;
				}
			if (soap_flag_OverallFeedbackRating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "OverallFeedbackRating", &(a->ns1__SellerProfileDetails::OverallFeedbackRating), "xsd:string"))
				{	soap_flag_OverallFeedbackRating1--;
					continue;
				}
			if (soap_flag_NumberOfFeedback1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfFeedback", &(a->ns1__SellerProfileDetails::NumberOfFeedback), "xsd:string"))
				{	soap_flag_NumberOfFeedback1--;
					continue;
				}
			if (soap_flag_NumberOfCanceledBids1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfCanceledBids", &(a->ns1__SellerProfileDetails::NumberOfCanceledBids), "xsd:string"))
				{	soap_flag_NumberOfCanceledBids1--;
					continue;
				}
			if (soap_flag_NumberOfCanceledAuctions1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfCanceledAuctions", &(a->ns1__SellerProfileDetails::NumberOfCanceledAuctions), "xsd:string"))
				{	soap_flag_NumberOfCanceledAuctions1--;
					continue;
				}
			if (soap_flag_StoreId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "StoreId", &(a->ns1__SellerProfileDetails::StoreId), "xsd:string"))
				{	soap_flag_StoreId1--;
					continue;
				}
			if (soap_flag_StoreName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "StoreName", &(a->ns1__SellerProfileDetails::StoreName), "xsd:string"))
				{	soap_flag_StoreName1--;
					continue;
				}
			if (soap_flag_SellerFeedback1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SellerFeedback(soap, "SellerFeedback", &(a->ns1__SellerProfileDetails::SellerFeedback), "ns1:SellerFeedback"))
				{	soap_flag_SellerFeedback1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellerProfileDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerProfileDetails, 0, sizeof(ns1__SellerProfileDetails), 0, soap_copy_ns1__SellerProfileDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SellerProfileDetails * SOAP_FMAC6 soap_new_ns1__SellerProfileDetails(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerProfileDetails(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SellerProfileDetails * SOAP_FMAC4 soap_instantiate_ns1__SellerProfileDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerProfileDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerProfileDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SellerProfileDetails;
		if (size)
			*size = sizeof(ns1__SellerProfileDetails);
		((ns1__SellerProfileDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SellerProfileDetails[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellerProfileDetails);
		for (int i = 0; i < n; i++)
			((ns1__SellerProfileDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellerProfileDetails*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerProfileDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellerProfileDetails %p -> %p\n", q, p));
	*(ns1__SellerProfileDetails*)p = *(ns1__SellerProfileDetails*)q;
}

void MarketplaceSearchDetailsArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void MarketplaceSearchDetailsArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_MarketplaceSearchDetailsArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MarketplaceSearchDetails(soap, this->__ptr + i);
		}
}

int MarketplaceSearchDetailsArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_MarketplaceSearchDetailsArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MarketplaceSearchDetailsArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_MarketplaceSearchDetailsArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MarketplaceSearchDetailsArray(struct soap *soap, const char *tag, int id, const MarketplaceSearchDetailsArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MarketplaceSearchDetails", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_MarketplaceSearchDetailsArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MarketplaceSearchDetails(soap, "item", -1, &a->__ptr[i], "ns1:MarketplaceSearchDetails");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *MarketplaceSearchDetailsArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MarketplaceSearchDetailsArray(soap, this, tag, type);
}

SOAP_FMAC3 MarketplaceSearchDetailsArray * SOAP_FMAC4 soap_get_MarketplaceSearchDetailsArray(struct soap *soap, MarketplaceSearchDetailsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_MarketplaceSearchDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MarketplaceSearchDetailsArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MarketplaceSearchDetailsArray(soap, tag, this, type);
}

SOAP_FMAC3 MarketplaceSearchDetailsArray * SOAP_FMAC4 soap_in_MarketplaceSearchDetailsArray(struct soap *soap, const char *tag, MarketplaceSearchDetailsArray *a, const char *type)
{	int i, j;
	ns1__MarketplaceSearchDetails **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (MarketplaceSearchDetailsArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MarketplaceSearchDetailsArray, sizeof(MarketplaceSearchDetailsArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MarketplaceSearchDetails **)soap_malloc(soap, sizeof(ns1__MarketplaceSearchDetails *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MarketplaceSearchDetails(soap, NULL, a->__ptr + i, "ns1:MarketplaceSearchDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MarketplaceSearchDetails **)soap_push_block(soap, NULL, sizeof(ns1__MarketplaceSearchDetails *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MarketplaceSearchDetails(soap, NULL, p, "ns1:MarketplaceSearchDetails"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__MarketplaceSearchDetails **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MarketplaceSearchDetailsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MarketplaceSearchDetailsArray, 0, sizeof(MarketplaceSearchDetailsArray), 0, soap_copy_MarketplaceSearchDetailsArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MarketplaceSearchDetailsArray * SOAP_FMAC6 soap_new_MarketplaceSearchDetailsArray(struct soap *soap, int n)
{	return soap_instantiate_MarketplaceSearchDetailsArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MarketplaceSearchDetailsArray(struct soap *soap, MarketplaceSearchDetailsArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MarketplaceSearchDetailsArray * SOAP_FMAC4 soap_instantiate_MarketplaceSearchDetailsArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MarketplaceSearchDetailsArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MarketplaceSearchDetailsArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MarketplaceSearchDetailsArray;
		if (size)
			*size = sizeof(MarketplaceSearchDetailsArray);
		((MarketplaceSearchDetailsArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MarketplaceSearchDetailsArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MarketplaceSearchDetailsArray);
		for (int i = 0; i < n; i++)
			((MarketplaceSearchDetailsArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MarketplaceSearchDetailsArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MarketplaceSearchDetailsArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MarketplaceSearchDetailsArray %p -> %p\n", q, p));
	*(MarketplaceSearchDetailsArray*)p = *(MarketplaceSearchDetailsArray*)q;
}

void ns1__MarketplaceSearchDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__MarketplaceSearchDetails::NumberOfOpenListings = NULL;
	this->ns1__MarketplaceSearchDetails::ListingProductInfo = NULL;
	/* transient soap skipped */
}

void ns1__MarketplaceSearchDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__MarketplaceSearchDetails::NumberOfOpenListings);
	soap_serialize_PointerTons1__ListingProductInfo(soap, &this->ns1__MarketplaceSearchDetails::ListingProductInfo);
	/* transient soap skipped */
}

int ns1__MarketplaceSearchDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MarketplaceSearchDetails);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MarketplaceSearchDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MarketplaceSearchDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketplaceSearchDetails(struct soap *soap, const char *tag, int id, const ns1__MarketplaceSearchDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketplaceSearchDetails), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfOpenListings", -1, &(a->ns1__MarketplaceSearchDetails::NumberOfOpenListings), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__ListingProductInfo(soap, "ListingProductInfo", -1, &(a->ns1__MarketplaceSearchDetails::ListingProductInfo), "ns1:ListingProductInfo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__MarketplaceSearchDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MarketplaceSearchDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MarketplaceSearchDetails * SOAP_FMAC4 soap_get_ns1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketplaceSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__MarketplaceSearchDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MarketplaceSearchDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MarketplaceSearchDetails * SOAP_FMAC4 soap_in_ns1__MarketplaceSearchDetails(struct soap *soap, const char *tag, ns1__MarketplaceSearchDetails *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MarketplaceSearchDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketplaceSearchDetails, sizeof(ns1__MarketplaceSearchDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MarketplaceSearchDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MarketplaceSearchDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NumberOfOpenListings1 = 1;
	size_t soap_flag_ListingProductInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NumberOfOpenListings1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfOpenListings", &(a->ns1__MarketplaceSearchDetails::NumberOfOpenListings), "xsd:string"))
				{	soap_flag_NumberOfOpenListings1--;
					continue;
				}
			if (soap_flag_ListingProductInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ListingProductInfo(soap, "ListingProductInfo", &(a->ns1__MarketplaceSearchDetails::ListingProductInfo), "ns1:ListingProductInfo"))
				{	soap_flag_ListingProductInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MarketplaceSearchDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketplaceSearchDetails, 0, sizeof(ns1__MarketplaceSearchDetails), 0, soap_copy_ns1__MarketplaceSearchDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MarketplaceSearchDetails * SOAP_FMAC6 soap_new_ns1__MarketplaceSearchDetails(struct soap *soap, int n)
{	return soap_instantiate_ns1__MarketplaceSearchDetails(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MarketplaceSearchDetails * SOAP_FMAC4 soap_instantiate_ns1__MarketplaceSearchDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MarketplaceSearchDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MarketplaceSearchDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MarketplaceSearchDetails;
		if (size)
			*size = sizeof(ns1__MarketplaceSearchDetails);
		((ns1__MarketplaceSearchDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MarketplaceSearchDetails[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MarketplaceSearchDetails);
		for (int i = 0; i < n; i++)
			((ns1__MarketplaceSearchDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MarketplaceSearchDetails*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MarketplaceSearchDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MarketplaceSearchDetails %p -> %p\n", q, p));
	*(ns1__MarketplaceSearchDetails*)p = *(ns1__MarketplaceSearchDetails*)q;
}

void ns1__SellerSearch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SellerSearch::SellerSearchDetails = NULL;
	/* transient soap skipped */
}

void ns1__SellerSearch::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToSellerSearchDetailsArray(soap, &this->ns1__SellerSearch::SellerSearchDetails);
	/* transient soap skipped */
}

int ns1__SellerSearch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellerSearch);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SellerSearch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellerSearch(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerSearch(struct soap *soap, const char *tag, int id, const ns1__SellerSearch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerSearch), type))
		return soap->error;
	if (soap_out_PointerToSellerSearchDetailsArray(soap, "SellerSearchDetails", -1, &(a->ns1__SellerSearch::SellerSearchDetails), "ns1:SellerSearchDetails"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellerSearch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellerSearch(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellerSearch * SOAP_FMAC4 soap_get_ns1__SellerSearch(struct soap *soap, ns1__SellerSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SellerSearch::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellerSearch(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellerSearch * SOAP_FMAC4 soap_in_ns1__SellerSearch(struct soap *soap, const char *tag, ns1__SellerSearch *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellerSearch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerSearch, sizeof(ns1__SellerSearch), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellerSearch)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellerSearch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SellerSearchDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellerSearchDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSellerSearchDetailsArray(soap, "SellerSearchDetails", &(a->ns1__SellerSearch::SellerSearchDetails), "ns1:SellerSearchDetails"))
				{	soap_flag_SellerSearchDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellerSearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerSearch, 0, sizeof(ns1__SellerSearch), 0, soap_copy_ns1__SellerSearch);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SellerSearchDetails1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SellerSearch * SOAP_FMAC6 soap_new_ns1__SellerSearch(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerSearch(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerSearch(struct soap *soap, ns1__SellerSearch *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SellerSearch * SOAP_FMAC4 soap_instantiate_ns1__SellerSearch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerSearch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerSearch, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SellerSearch;
		if (size)
			*size = sizeof(ns1__SellerSearch);
		((ns1__SellerSearch*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SellerSearch[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellerSearch);
		for (int i = 0; i < n; i++)
			((ns1__SellerSearch*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellerSearch*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerSearch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellerSearch %p -> %p\n", q, p));
	*(ns1__SellerSearch*)p = *(ns1__SellerSearch*)q;
}

void ns1__SellerProfile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SellerProfile::SellerProfileDetails = NULL;
	/* transient soap skipped */
}

void ns1__SellerProfile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToSellerProfileDetailsArray(soap, &this->ns1__SellerProfile::SellerProfileDetails);
	/* transient soap skipped */
}

int ns1__SellerProfile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellerProfile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SellerProfile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellerProfile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerProfile(struct soap *soap, const char *tag, int id, const ns1__SellerProfile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerProfile), type))
		return soap->error;
	if (soap_out_PointerToSellerProfileDetailsArray(soap, "SellerProfileDetails", -1, &(a->ns1__SellerProfile::SellerProfileDetails), "ns1:SellerProfileDetails"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellerProfile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellerProfile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellerProfile * SOAP_FMAC4 soap_get_ns1__SellerProfile(struct soap *soap, ns1__SellerProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SellerProfile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellerProfile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellerProfile * SOAP_FMAC4 soap_in_ns1__SellerProfile(struct soap *soap, const char *tag, ns1__SellerProfile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellerProfile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerProfile, sizeof(ns1__SellerProfile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellerProfile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellerProfile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SellerProfileDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellerProfileDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSellerProfileDetailsArray(soap, "SellerProfileDetails", &(a->ns1__SellerProfile::SellerProfileDetails), "ns1:SellerProfileDetails"))
				{	soap_flag_SellerProfileDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellerProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerProfile, 0, sizeof(ns1__SellerProfile), 0, soap_copy_ns1__SellerProfile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SellerProfileDetails1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SellerProfile * SOAP_FMAC6 soap_new_ns1__SellerProfile(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerProfile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerProfile(struct soap *soap, ns1__SellerProfile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SellerProfile * SOAP_FMAC4 soap_instantiate_ns1__SellerProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerProfile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerProfile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SellerProfile;
		if (size)
			*size = sizeof(ns1__SellerProfile);
		((ns1__SellerProfile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SellerProfile[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellerProfile);
		for (int i = 0; i < n; i++)
			((ns1__SellerProfile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellerProfile*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerProfile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellerProfile %p -> %p\n", q, p));
	*(ns1__SellerProfile*)p = *(ns1__SellerProfile*)q;
}

void ns1__MarketplaceSearch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__MarketplaceSearch::MarketplaceSearchDetails = NULL;
	/* transient soap skipped */
}

void ns1__MarketplaceSearch::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMarketplaceSearchDetailsArray(soap, &this->ns1__MarketplaceSearch::MarketplaceSearchDetails);
	/* transient soap skipped */
}

int ns1__MarketplaceSearch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MarketplaceSearch);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MarketplaceSearch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MarketplaceSearch(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketplaceSearch(struct soap *soap, const char *tag, int id, const ns1__MarketplaceSearch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketplaceSearch), type))
		return soap->error;
	if (soap_out_PointerToMarketplaceSearchDetailsArray(soap, "MarketplaceSearchDetails", -1, &(a->ns1__MarketplaceSearch::MarketplaceSearchDetails), "ns1:MarketplaceSearchDetails"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__MarketplaceSearch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MarketplaceSearch(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MarketplaceSearch * SOAP_FMAC4 soap_get_ns1__MarketplaceSearch(struct soap *soap, ns1__MarketplaceSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketplaceSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__MarketplaceSearch::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MarketplaceSearch(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MarketplaceSearch * SOAP_FMAC4 soap_in_ns1__MarketplaceSearch(struct soap *soap, const char *tag, ns1__MarketplaceSearch *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MarketplaceSearch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketplaceSearch, sizeof(ns1__MarketplaceSearch), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MarketplaceSearch)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MarketplaceSearch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_MarketplaceSearchDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MarketplaceSearchDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMarketplaceSearchDetailsArray(soap, "MarketplaceSearchDetails", &(a->ns1__MarketplaceSearch::MarketplaceSearchDetails), "ns1:MarketplaceSearchDetails"))
				{	soap_flag_MarketplaceSearchDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MarketplaceSearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketplaceSearch, 0, sizeof(ns1__MarketplaceSearch), 0, soap_copy_ns1__MarketplaceSearch);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MarketplaceSearchDetails1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MarketplaceSearch * SOAP_FMAC6 soap_new_ns1__MarketplaceSearch(struct soap *soap, int n)
{	return soap_instantiate_ns1__MarketplaceSearch(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MarketplaceSearch(struct soap *soap, ns1__MarketplaceSearch *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MarketplaceSearch * SOAP_FMAC4 soap_instantiate_ns1__MarketplaceSearch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MarketplaceSearch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MarketplaceSearch, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MarketplaceSearch;
		if (size)
			*size = sizeof(ns1__MarketplaceSearch);
		((ns1__MarketplaceSearch*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MarketplaceSearch[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MarketplaceSearch);
		for (int i = 0; i < n; i++)
			((ns1__MarketplaceSearch*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MarketplaceSearch*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MarketplaceSearch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MarketplaceSearch %p -> %p\n", q, p));
	*(ns1__MarketplaceSearch*)p = *(ns1__MarketplaceSearch*)q;
}

void ListArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ListArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ListArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int ListArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ListArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ListArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ListArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ListArray(struct soap *soap, const char *tag, int id, const ListArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ListArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ListArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ListArray(soap, this, tag, type);
}

SOAP_FMAC3 ListArray * SOAP_FMAC4 soap_get_ListArray(struct soap *soap, ListArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ListArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ListArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ListArray(soap, tag, this, type);
}

SOAP_FMAC3 ListArray * SOAP_FMAC4 soap_in_ListArray(struct soap *soap, const char *tag, ListArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ListArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ListArray, sizeof(ListArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ListArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ListArray, 0, sizeof(ListArray), 0, soap_copy_ListArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ListArray * SOAP_FMAC6 soap_new_ListArray(struct soap *soap, int n)
{	return soap_instantiate_ListArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ListArray(struct soap *soap, ListArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ListArray * SOAP_FMAC4 soap_instantiate_ListArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ListArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ListArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ListArray;
		if (size)
			*size = sizeof(ListArray);
		((ListArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ListArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ListArray);
		for (int i = 0; i < n; i++)
			((ListArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ListArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ListArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ListArray %p -> %p\n", q, p));
	*(ListArray*)p = *(ListArray*)q;
}

void SimilarProductsArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void SimilarProductsArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_SimilarProductsArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int SimilarProductsArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_SimilarProductsArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int SimilarProductsArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_SimilarProductsArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SimilarProductsArray(struct soap *soap, const char *tag, int id, const SimilarProductsArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_SimilarProductsArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *SimilarProductsArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SimilarProductsArray(soap, this, tag, type);
}

SOAP_FMAC3 SimilarProductsArray * SOAP_FMAC4 soap_get_SimilarProductsArray(struct soap *soap, SimilarProductsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_SimilarProductsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *SimilarProductsArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_SimilarProductsArray(soap, tag, this, type);
}

SOAP_FMAC3 SimilarProductsArray * SOAP_FMAC4 soap_in_SimilarProductsArray(struct soap *soap, const char *tag, SimilarProductsArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (SimilarProductsArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SimilarProductsArray, sizeof(SimilarProductsArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SimilarProductsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SimilarProductsArray, 0, sizeof(SimilarProductsArray), 0, soap_copy_SimilarProductsArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 SimilarProductsArray * SOAP_FMAC6 soap_new_SimilarProductsArray(struct soap *soap, int n)
{	return soap_instantiate_SimilarProductsArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SimilarProductsArray(struct soap *soap, SimilarProductsArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 SimilarProductsArray * SOAP_FMAC4 soap_instantiate_SimilarProductsArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SimilarProductsArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SimilarProductsArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new SimilarProductsArray;
		if (size)
			*size = sizeof(SimilarProductsArray);
		((SimilarProductsArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new SimilarProductsArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(SimilarProductsArray);
		for (int i = 0; i < n; i++)
			((SimilarProductsArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (SimilarProductsArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SimilarProductsArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying SimilarProductsArray %p -> %p\n", q, p));
	*(SimilarProductsArray*)p = *(SimilarProductsArray*)q;
}

void ns1__CustomerReview::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CustomerReview::Rating = NULL;
	this->ns1__CustomerReview::Summary = NULL;
	this->ns1__CustomerReview::Comment = NULL;
	/* transient soap skipped */
}

void ns1__CustomerReview::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__CustomerReview::Rating);
	soap_serialize_PointerTostd__string(soap, &this->ns1__CustomerReview::Summary);
	soap_serialize_PointerTostd__string(soap, &this->ns1__CustomerReview::Comment);
	/* transient soap skipped */
}

int ns1__CustomerReview::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CustomerReview);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CustomerReview::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CustomerReview(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CustomerReview(struct soap *soap, const char *tag, int id, const ns1__CustomerReview *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CustomerReview), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Rating", -1, &(a->ns1__CustomerReview::Rating), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Summary", -1, &(a->ns1__CustomerReview::Summary), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Comment", -1, &(a->ns1__CustomerReview::Comment), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CustomerReview::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CustomerReview(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CustomerReview * SOAP_FMAC4 soap_get_ns1__CustomerReview(struct soap *soap, ns1__CustomerReview *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CustomerReview(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__CustomerReview::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CustomerReview(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CustomerReview * SOAP_FMAC4 soap_in_ns1__CustomerReview(struct soap *soap, const char *tag, ns1__CustomerReview *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CustomerReview *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomerReview, sizeof(ns1__CustomerReview), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CustomerReview)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CustomerReview *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Rating1 = 1;
	size_t soap_flag_Summary1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Rating", &(a->ns1__CustomerReview::Rating), "xsd:string"))
				{	soap_flag_Rating1--;
					continue;
				}
			if (soap_flag_Summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Summary", &(a->ns1__CustomerReview::Summary), "xsd:string"))
				{	soap_flag_Summary1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Comment", &(a->ns1__CustomerReview::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CustomerReview *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CustomerReview, 0, sizeof(ns1__CustomerReview), 0, soap_copy_ns1__CustomerReview);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CustomerReview * SOAP_FMAC6 soap_new_ns1__CustomerReview(struct soap *soap, int n)
{	return soap_instantiate_ns1__CustomerReview(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CustomerReview(struct soap *soap, ns1__CustomerReview *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CustomerReview * SOAP_FMAC4 soap_instantiate_ns1__CustomerReview(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CustomerReview(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CustomerReview, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CustomerReview;
		if (size)
			*size = sizeof(ns1__CustomerReview);
		((ns1__CustomerReview*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CustomerReview[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CustomerReview);
		for (int i = 0; i < n; i++)
			((ns1__CustomerReview*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CustomerReview*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CustomerReview(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CustomerReview %p -> %p\n", q, p));
	*(ns1__CustomerReview*)p = *(ns1__CustomerReview*)q;
}

void CustomerReviewArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void CustomerReviewArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_CustomerReviewArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CustomerReview(soap, this->__ptr + i);
		}
}

int CustomerReviewArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_CustomerReviewArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CustomerReviewArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_CustomerReviewArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CustomerReviewArray(struct soap *soap, const char *tag, int id, const CustomerReviewArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CustomerReview", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_CustomerReviewArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CustomerReview(soap, "item", -1, &a->__ptr[i], "ns1:CustomerReview");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *CustomerReviewArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CustomerReviewArray(soap, this, tag, type);
}

SOAP_FMAC3 CustomerReviewArray * SOAP_FMAC4 soap_get_CustomerReviewArray(struct soap *soap, CustomerReviewArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_CustomerReviewArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CustomerReviewArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CustomerReviewArray(soap, tag, this, type);
}

SOAP_FMAC3 CustomerReviewArray * SOAP_FMAC4 soap_in_CustomerReviewArray(struct soap *soap, const char *tag, CustomerReviewArray *a, const char *type)
{	int i, j;
	ns1__CustomerReview **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (CustomerReviewArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CustomerReviewArray, sizeof(CustomerReviewArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CustomerReview **)soap_malloc(soap, sizeof(ns1__CustomerReview *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CustomerReview(soap, NULL, a->__ptr + i, "ns1:CustomerReview"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CustomerReview **)soap_push_block(soap, NULL, sizeof(ns1__CustomerReview *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CustomerReview(soap, NULL, p, "ns1:CustomerReview"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__CustomerReview **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CustomerReviewArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CustomerReviewArray, 0, sizeof(CustomerReviewArray), 0, soap_copy_CustomerReviewArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 CustomerReviewArray * SOAP_FMAC6 soap_new_CustomerReviewArray(struct soap *soap, int n)
{	return soap_instantiate_CustomerReviewArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_CustomerReviewArray(struct soap *soap, CustomerReviewArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 CustomerReviewArray * SOAP_FMAC4 soap_instantiate_CustomerReviewArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CustomerReviewArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CustomerReviewArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CustomerReviewArray;
		if (size)
			*size = sizeof(CustomerReviewArray);
		((CustomerReviewArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CustomerReviewArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CustomerReviewArray);
		for (int i = 0; i < n; i++)
			((CustomerReviewArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CustomerReviewArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CustomerReviewArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CustomerReviewArray %p -> %p\n", q, p));
	*(CustomerReviewArray*)p = *(CustomerReviewArray*)q;
}

void ns1__Reviews::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Reviews::AvgCustomerRating = NULL;
	this->ns1__Reviews::TotalCustomerReviews = NULL;
	this->ns1__Reviews::CustomerReviews = NULL;
	/* transient soap skipped */
}

void ns1__Reviews::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Reviews::AvgCustomerRating);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Reviews::TotalCustomerReviews);
	soap_serialize_PointerToCustomerReviewArray(soap, &this->ns1__Reviews::CustomerReviews);
	/* transient soap skipped */
}

int ns1__Reviews::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Reviews);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Reviews::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Reviews(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Reviews(struct soap *soap, const char *tag, int id, const ns1__Reviews *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Reviews), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "AvgCustomerRating", -1, &(a->ns1__Reviews::AvgCustomerRating), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "TotalCustomerReviews", -1, &(a->ns1__Reviews::TotalCustomerReviews), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToCustomerReviewArray(soap, "CustomerReviews", -1, &(a->ns1__Reviews::CustomerReviews), "ns1:CustomerReview"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Reviews::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Reviews(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Reviews * SOAP_FMAC4 soap_get_ns1__Reviews(struct soap *soap, ns1__Reviews *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Reviews(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Reviews::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Reviews(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Reviews * SOAP_FMAC4 soap_in_ns1__Reviews(struct soap *soap, const char *tag, ns1__Reviews *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Reviews *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Reviews, sizeof(ns1__Reviews), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Reviews)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Reviews *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AvgCustomerRating1 = 1;
	size_t soap_flag_TotalCustomerReviews1 = 1;
	size_t soap_flag_CustomerReviews1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AvgCustomerRating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "AvgCustomerRating", &(a->ns1__Reviews::AvgCustomerRating), "xsd:string"))
				{	soap_flag_AvgCustomerRating1--;
					continue;
				}
			if (soap_flag_TotalCustomerReviews1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "TotalCustomerReviews", &(a->ns1__Reviews::TotalCustomerReviews), "xsd:string"))
				{	soap_flag_TotalCustomerReviews1--;
					continue;
				}
			if (soap_flag_CustomerReviews1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCustomerReviewArray(soap, "CustomerReviews", &(a->ns1__Reviews::CustomerReviews), "ns1:CustomerReview"))
				{	soap_flag_CustomerReviews1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Reviews *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Reviews, 0, sizeof(ns1__Reviews), 0, soap_copy_ns1__Reviews);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Reviews * SOAP_FMAC6 soap_new_ns1__Reviews(struct soap *soap, int n)
{	return soap_instantiate_ns1__Reviews(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Reviews(struct soap *soap, ns1__Reviews *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Reviews * SOAP_FMAC4 soap_instantiate_ns1__Reviews(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Reviews(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Reviews, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Reviews;
		if (size)
			*size = sizeof(ns1__Reviews);
		((ns1__Reviews*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Reviews[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Reviews);
		for (int i = 0; i < n; i++)
			((ns1__Reviews*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Reviews*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Reviews(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Reviews %p -> %p\n", q, p));
	*(ns1__Reviews*)p = *(ns1__Reviews*)q;
}

void PlatformArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void PlatformArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_PlatformArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int PlatformArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_PlatformArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int PlatformArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_PlatformArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PlatformArray(struct soap *soap, const char *tag, int id, const PlatformArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_PlatformArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *PlatformArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_PlatformArray(soap, this, tag, type);
}

SOAP_FMAC3 PlatformArray * SOAP_FMAC4 soap_get_PlatformArray(struct soap *soap, PlatformArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_PlatformArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *PlatformArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_PlatformArray(soap, tag, this, type);
}

SOAP_FMAC3 PlatformArray * SOAP_FMAC4 soap_in_PlatformArray(struct soap *soap, const char *tag, PlatformArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (PlatformArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_PlatformArray, sizeof(PlatformArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (PlatformArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_PlatformArray, 0, sizeof(PlatformArray), 0, soap_copy_PlatformArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 PlatformArray * SOAP_FMAC6 soap_new_PlatformArray(struct soap *soap, int n)
{	return soap_instantiate_PlatformArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_PlatformArray(struct soap *soap, PlatformArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 PlatformArray * SOAP_FMAC4 soap_instantiate_PlatformArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_PlatformArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_PlatformArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new PlatformArray;
		if (size)
			*size = sizeof(PlatformArray);
		((PlatformArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new PlatformArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(PlatformArray);
		for (int i = 0; i < n; i++)
			((PlatformArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (PlatformArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_PlatformArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying PlatformArray %p -> %p\n", q, p));
	*(PlatformArray*)p = *(PlatformArray*)q;
}

void AccessoryArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void AccessoryArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_AccessoryArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int AccessoryArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_AccessoryArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int AccessoryArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_AccessoryArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_AccessoryArray(struct soap *soap, const char *tag, int id, const AccessoryArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_AccessoryArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *AccessoryArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_AccessoryArray(soap, this, tag, type);
}

SOAP_FMAC3 AccessoryArray * SOAP_FMAC4 soap_get_AccessoryArray(struct soap *soap, AccessoryArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_AccessoryArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *AccessoryArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_AccessoryArray(soap, tag, this, type);
}

SOAP_FMAC3 AccessoryArray * SOAP_FMAC4 soap_in_AccessoryArray(struct soap *soap, const char *tag, AccessoryArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (AccessoryArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_AccessoryArray, sizeof(AccessoryArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (AccessoryArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_AccessoryArray, 0, sizeof(AccessoryArray), 0, soap_copy_AccessoryArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 AccessoryArray * SOAP_FMAC6 soap_new_AccessoryArray(struct soap *soap, int n)
{	return soap_instantiate_AccessoryArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_AccessoryArray(struct soap *soap, AccessoryArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 AccessoryArray * SOAP_FMAC4 soap_instantiate_AccessoryArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_AccessoryArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_AccessoryArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new AccessoryArray;
		if (size)
			*size = sizeof(AccessoryArray);
		((AccessoryArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new AccessoryArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(AccessoryArray);
		for (int i = 0; i < n; i++)
			((AccessoryArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (AccessoryArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_AccessoryArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying AccessoryArray %p -> %p\n", q, p));
	*(AccessoryArray*)p = *(AccessoryArray*)q;
}

void ns1__Track::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Track::TrackName = NULL;
	this->ns1__Track::ByArtist = NULL;
	/* transient soap skipped */
}

void ns1__Track::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Track::TrackName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Track::ByArtist);
	/* transient soap skipped */
}

int ns1__Track::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Track);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Track::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Track(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Track(struct soap *soap, const char *tag, int id, const ns1__Track *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Track), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "TrackName", -1, &(a->ns1__Track::TrackName), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ByArtist", -1, &(a->ns1__Track::ByArtist), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Track::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Track(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Track * SOAP_FMAC4 soap_get_ns1__Track(struct soap *soap, ns1__Track *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Track(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Track::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Track(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Track * SOAP_FMAC4 soap_in_ns1__Track(struct soap *soap, const char *tag, ns1__Track *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Track *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Track, sizeof(ns1__Track), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Track)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Track *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TrackName1 = 1;
	size_t soap_flag_ByArtist1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "TrackName", &(a->ns1__Track::TrackName), "xsd:string"))
				{	soap_flag_TrackName1--;
					continue;
				}
			if (soap_flag_ByArtist1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ByArtist", &(a->ns1__Track::ByArtist), "xsd:string"))
				{	soap_flag_ByArtist1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Track *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Track, 0, sizeof(ns1__Track), 0, soap_copy_ns1__Track);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Track * SOAP_FMAC6 soap_new_ns1__Track(struct soap *soap, int n)
{	return soap_instantiate_ns1__Track(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Track(struct soap *soap, ns1__Track *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Track * SOAP_FMAC4 soap_instantiate_ns1__Track(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Track(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Track, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Track;
		if (size)
			*size = sizeof(ns1__Track);
		((ns1__Track*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Track[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Track);
		for (int i = 0; i < n; i++)
			((ns1__Track*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Track*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Track(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Track %p -> %p\n", q, p));
	*(ns1__Track*)p = *(ns1__Track*)q;
}

void TrackArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void TrackArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_TrackArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__Track(soap, this->__ptr + i);
		}
}

int TrackArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_TrackArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TrackArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TrackArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrackArray(struct soap *soap, const char *tag, int id, const TrackArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:Track", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_TrackArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Track(soap, "item", -1, &a->__ptr[i], "ns1:Track");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrackArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrackArray(soap, this, tag, type);
}

SOAP_FMAC3 TrackArray * SOAP_FMAC4 soap_get_TrackArray(struct soap *soap, TrackArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrackArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TrackArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TrackArray(soap, tag, this, type);
}

SOAP_FMAC3 TrackArray * SOAP_FMAC4 soap_in_TrackArray(struct soap *soap, const char *tag, TrackArray *a, const char *type)
{	int i, j;
	ns1__Track **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrackArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TrackArray, sizeof(TrackArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__Track **)soap_malloc(soap, sizeof(ns1__Track *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Track(soap, NULL, a->__ptr + i, "ns1:Track"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Track **)soap_push_block(soap, NULL, sizeof(ns1__Track *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Track(soap, NULL, p, "ns1:Track"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__Track **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrackArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrackArray, 0, sizeof(TrackArray), 0, soap_copy_TrackArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TrackArray * SOAP_FMAC6 soap_new_TrackArray(struct soap *soap, int n)
{	return soap_instantiate_TrackArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TrackArray(struct soap *soap, TrackArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TrackArray * SOAP_FMAC4 soap_instantiate_TrackArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TrackArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TrackArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TrackArray;
		if (size)
			*size = sizeof(TrackArray);
		((TrackArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TrackArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TrackArray);
		for (int i = 0; i < n; i++)
			((TrackArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TrackArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TrackArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TrackArray %p -> %p\n", q, p));
	*(TrackArray*)p = *(TrackArray*)q;
}

void FeaturesArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void FeaturesArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_FeaturesArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int FeaturesArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_FeaturesArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int FeaturesArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_FeaturesArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FeaturesArray(struct soap *soap, const char *tag, int id, const FeaturesArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_FeaturesArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *FeaturesArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_FeaturesArray(soap, this, tag, type);
}

SOAP_FMAC3 FeaturesArray * SOAP_FMAC4 soap_get_FeaturesArray(struct soap *soap, FeaturesArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_FeaturesArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *FeaturesArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_FeaturesArray(soap, tag, this, type);
}

SOAP_FMAC3 FeaturesArray * SOAP_FMAC4 soap_in_FeaturesArray(struct soap *soap, const char *tag, FeaturesArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (FeaturesArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FeaturesArray, sizeof(FeaturesArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (FeaturesArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FeaturesArray, 0, sizeof(FeaturesArray), 0, soap_copy_FeaturesArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 FeaturesArray * SOAP_FMAC6 soap_new_FeaturesArray(struct soap *soap, int n)
{	return soap_instantiate_FeaturesArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_FeaturesArray(struct soap *soap, FeaturesArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 FeaturesArray * SOAP_FMAC4 soap_instantiate_FeaturesArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_FeaturesArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FeaturesArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new FeaturesArray;
		if (size)
			*size = sizeof(FeaturesArray);
		((FeaturesArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new FeaturesArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(FeaturesArray);
		for (int i = 0; i < n; i++)
			((FeaturesArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (FeaturesArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_FeaturesArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying FeaturesArray %p -> %p\n", q, p));
	*(FeaturesArray*)p = *(FeaturesArray*)q;
}

void ns1__BrowseNode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BrowseNode::BrowseId = NULL;
	this->ns1__BrowseNode::BrowseName = NULL;
	/* transient soap skipped */
}

void ns1__BrowseNode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__BrowseNode::BrowseId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BrowseNode::BrowseName);
	/* transient soap skipped */
}

int ns1__BrowseNode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BrowseNode);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__BrowseNode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BrowseNode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BrowseNode(struct soap *soap, const char *tag, int id, const ns1__BrowseNode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BrowseNode), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "BrowseId", -1, &(a->ns1__BrowseNode::BrowseId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "BrowseName", -1, &(a->ns1__BrowseNode::BrowseName), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__BrowseNode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BrowseNode(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BrowseNode * SOAP_FMAC4 soap_get_ns1__BrowseNode(struct soap *soap, ns1__BrowseNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BrowseNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__BrowseNode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BrowseNode(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BrowseNode * SOAP_FMAC4 soap_in_ns1__BrowseNode(struct soap *soap, const char *tag, ns1__BrowseNode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BrowseNode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BrowseNode, sizeof(ns1__BrowseNode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BrowseNode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BrowseNode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_BrowseId1 = 1;
	size_t soap_flag_BrowseName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BrowseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "BrowseId", &(a->ns1__BrowseNode::BrowseId), "xsd:string"))
				{	soap_flag_BrowseId1--;
					continue;
				}
			if (soap_flag_BrowseName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "BrowseName", &(a->ns1__BrowseNode::BrowseName), "xsd:string"))
				{	soap_flag_BrowseName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BrowseNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BrowseNode, 0, sizeof(ns1__BrowseNode), 0, soap_copy_ns1__BrowseNode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__BrowseNode * SOAP_FMAC6 soap_new_ns1__BrowseNode(struct soap *soap, int n)
{	return soap_instantiate_ns1__BrowseNode(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BrowseNode(struct soap *soap, ns1__BrowseNode *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__BrowseNode * SOAP_FMAC4 soap_instantiate_ns1__BrowseNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BrowseNode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BrowseNode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__BrowseNode;
		if (size)
			*size = sizeof(ns1__BrowseNode);
		((ns1__BrowseNode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__BrowseNode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BrowseNode);
		for (int i = 0; i < n; i++)
			((ns1__BrowseNode*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BrowseNode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BrowseNode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BrowseNode %p -> %p\n", q, p));
	*(ns1__BrowseNode*)p = *(ns1__BrowseNode*)q;
}

void BrowseNodeArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void BrowseNodeArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_BrowseNodeArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__BrowseNode(soap, this->__ptr + i);
		}
}

int BrowseNodeArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_BrowseNodeArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int BrowseNodeArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_BrowseNodeArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_BrowseNodeArray(struct soap *soap, const char *tag, int id, const BrowseNodeArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:BrowseNode", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_BrowseNodeArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__BrowseNode(soap, "item", -1, &a->__ptr[i], "ns1:BrowseNode");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *BrowseNodeArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_BrowseNodeArray(soap, this, tag, type);
}

SOAP_FMAC3 BrowseNodeArray * SOAP_FMAC4 soap_get_BrowseNodeArray(struct soap *soap, BrowseNodeArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_BrowseNodeArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *BrowseNodeArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_BrowseNodeArray(soap, tag, this, type);
}

SOAP_FMAC3 BrowseNodeArray * SOAP_FMAC4 soap_in_BrowseNodeArray(struct soap *soap, const char *tag, BrowseNodeArray *a, const char *type)
{	int i, j;
	ns1__BrowseNode **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (BrowseNodeArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_BrowseNodeArray, sizeof(BrowseNodeArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__BrowseNode **)soap_malloc(soap, sizeof(ns1__BrowseNode *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__BrowseNode(soap, NULL, a->__ptr + i, "ns1:BrowseNode"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__BrowseNode **)soap_push_block(soap, NULL, sizeof(ns1__BrowseNode *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__BrowseNode(soap, NULL, p, "ns1:BrowseNode"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__BrowseNode **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (BrowseNodeArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_BrowseNodeArray, 0, sizeof(BrowseNodeArray), 0, soap_copy_BrowseNodeArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 BrowseNodeArray * SOAP_FMAC6 soap_new_BrowseNodeArray(struct soap *soap, int n)
{	return soap_instantiate_BrowseNodeArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_BrowseNodeArray(struct soap *soap, BrowseNodeArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 BrowseNodeArray * SOAP_FMAC4 soap_instantiate_BrowseNodeArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_BrowseNodeArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_BrowseNodeArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new BrowseNodeArray;
		if (size)
			*size = sizeof(BrowseNodeArray);
		((BrowseNodeArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new BrowseNodeArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(BrowseNodeArray);
		for (int i = 0; i < n; i++)
			((BrowseNodeArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (BrowseNodeArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_BrowseNodeArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying BrowseNodeArray %p -> %p\n", q, p));
	*(BrowseNodeArray*)p = *(BrowseNodeArray*)q;
}

void DirectorArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void DirectorArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_DirectorArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int DirectorArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_DirectorArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DirectorArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_DirectorArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DirectorArray(struct soap *soap, const char *tag, int id, const DirectorArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_DirectorArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *DirectorArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DirectorArray(soap, this, tag, type);
}

SOAP_FMAC3 DirectorArray * SOAP_FMAC4 soap_get_DirectorArray(struct soap *soap, DirectorArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_DirectorArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *DirectorArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DirectorArray(soap, tag, this, type);
}

SOAP_FMAC3 DirectorArray * SOAP_FMAC4 soap_in_DirectorArray(struct soap *soap, const char *tag, DirectorArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (DirectorArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DirectorArray, sizeof(DirectorArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DirectorArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_DirectorArray, 0, sizeof(DirectorArray), 0, soap_copy_DirectorArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DirectorArray * SOAP_FMAC6 soap_new_DirectorArray(struct soap *soap, int n)
{	return soap_instantiate_DirectorArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DirectorArray(struct soap *soap, DirectorArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DirectorArray * SOAP_FMAC4 soap_instantiate_DirectorArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DirectorArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DirectorArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DirectorArray;
		if (size)
			*size = sizeof(DirectorArray);
		((DirectorArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new DirectorArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(DirectorArray);
		for (int i = 0; i < n; i++)
			((DirectorArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DirectorArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DirectorArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DirectorArray %p -> %p\n", q, p));
	*(DirectorArray*)p = *(DirectorArray*)q;
}

void StarringArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void StarringArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_StarringArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int StarringArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_StarringArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int StarringArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_StarringArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_StarringArray(struct soap *soap, const char *tag, int id, const StarringArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_StarringArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *StarringArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_StarringArray(soap, this, tag, type);
}

SOAP_FMAC3 StarringArray * SOAP_FMAC4 soap_get_StarringArray(struct soap *soap, StarringArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_StarringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *StarringArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_StarringArray(soap, tag, this, type);
}

SOAP_FMAC3 StarringArray * SOAP_FMAC4 soap_in_StarringArray(struct soap *soap, const char *tag, StarringArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (StarringArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_StarringArray, sizeof(StarringArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (StarringArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_StarringArray, 0, sizeof(StarringArray), 0, soap_copy_StarringArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 StarringArray * SOAP_FMAC6 soap_new_StarringArray(struct soap *soap, int n)
{	return soap_instantiate_StarringArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_StarringArray(struct soap *soap, StarringArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 StarringArray * SOAP_FMAC4 soap_instantiate_StarringArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_StarringArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_StarringArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new StarringArray;
		if (size)
			*size = sizeof(StarringArray);
		((StarringArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new StarringArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(StarringArray);
		for (int i = 0; i < n; i++)
			((StarringArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (StarringArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_StarringArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying StarringArray %p -> %p\n", q, p));
	*(StarringArray*)p = *(StarringArray*)q;
}

void AuthorArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void AuthorArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_AuthorArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int AuthorArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_AuthorArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int AuthorArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_AuthorArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_AuthorArray(struct soap *soap, const char *tag, int id, const AuthorArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_AuthorArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *AuthorArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_AuthorArray(soap, this, tag, type);
}

SOAP_FMAC3 AuthorArray * SOAP_FMAC4 soap_get_AuthorArray(struct soap *soap, AuthorArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_AuthorArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *AuthorArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_AuthorArray(soap, tag, this, type);
}

SOAP_FMAC3 AuthorArray * SOAP_FMAC4 soap_in_AuthorArray(struct soap *soap, const char *tag, AuthorArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (AuthorArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_AuthorArray, sizeof(AuthorArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (AuthorArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_AuthorArray, 0, sizeof(AuthorArray), 0, soap_copy_AuthorArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 AuthorArray * SOAP_FMAC6 soap_new_AuthorArray(struct soap *soap, int n)
{	return soap_instantiate_AuthorArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_AuthorArray(struct soap *soap, AuthorArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 AuthorArray * SOAP_FMAC4 soap_instantiate_AuthorArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_AuthorArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_AuthorArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new AuthorArray;
		if (size)
			*size = sizeof(AuthorArray);
		((AuthorArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new AuthorArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(AuthorArray);
		for (int i = 0; i < n; i++)
			((AuthorArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (AuthorArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_AuthorArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying AuthorArray %p -> %p\n", q, p));
	*(AuthorArray*)p = *(AuthorArray*)q;
}

void ArtistArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArtistArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArtistArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int ArtistArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArtistArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArtistArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArtistArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArtistArray(struct soap *soap, const char *tag, int id, const ArtistArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArtistArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArtistArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArtistArray(soap, this, tag, type);
}

SOAP_FMAC3 ArtistArray * SOAP_FMAC4 soap_get_ArtistArray(struct soap *soap, ArtistArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArtistArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArtistArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArtistArray(soap, tag, this, type);
}

SOAP_FMAC3 ArtistArray * SOAP_FMAC4 soap_in_ArtistArray(struct soap *soap, const char *tag, ArtistArray *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArtistArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArtistArray, sizeof(ArtistArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArtistArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArtistArray, 0, sizeof(ArtistArray), 0, soap_copy_ArtistArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArtistArray * SOAP_FMAC6 soap_new_ArtistArray(struct soap *soap, int n)
{	return soap_instantiate_ArtistArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArtistArray(struct soap *soap, ArtistArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArtistArray * SOAP_FMAC4 soap_instantiate_ArtistArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArtistArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArtistArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArtistArray;
		if (size)
			*size = sizeof(ArtistArray);
		((ArtistArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArtistArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArtistArray);
		for (int i = 0; i < n; i++)
			((ArtistArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArtistArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArtistArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArtistArray %p -> %p\n", q, p));
	*(ArtistArray*)p = *(ArtistArray*)q;
}

void ns1__KeyPhrase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__KeyPhrase::KeyPhrase = NULL;
	this->ns1__KeyPhrase::Type = NULL;
	/* transient soap skipped */
}

void ns1__KeyPhrase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__KeyPhrase::KeyPhrase);
	soap_serialize_PointerTostd__string(soap, &this->ns1__KeyPhrase::Type);
	/* transient soap skipped */
}

int ns1__KeyPhrase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__KeyPhrase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__KeyPhrase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__KeyPhrase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__KeyPhrase(struct soap *soap, const char *tag, int id, const ns1__KeyPhrase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__KeyPhrase), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "KeyPhrase", -1, &(a->ns1__KeyPhrase::KeyPhrase), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Type", -1, &(a->ns1__KeyPhrase::Type), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__KeyPhrase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__KeyPhrase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__KeyPhrase * SOAP_FMAC4 soap_get_ns1__KeyPhrase(struct soap *soap, ns1__KeyPhrase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__KeyPhrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__KeyPhrase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__KeyPhrase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__KeyPhrase * SOAP_FMAC4 soap_in_ns1__KeyPhrase(struct soap *soap, const char *tag, ns1__KeyPhrase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__KeyPhrase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__KeyPhrase, sizeof(ns1__KeyPhrase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__KeyPhrase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__KeyPhrase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_KeyPhrase1 = 1;
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyPhrase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "KeyPhrase", &(a->ns1__KeyPhrase::KeyPhrase), "xsd:string"))
				{	soap_flag_KeyPhrase1--;
					continue;
				}
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Type", &(a->ns1__KeyPhrase::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__KeyPhrase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__KeyPhrase, 0, sizeof(ns1__KeyPhrase), 0, soap_copy_ns1__KeyPhrase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__KeyPhrase * SOAP_FMAC6 soap_new_ns1__KeyPhrase(struct soap *soap, int n)
{	return soap_instantiate_ns1__KeyPhrase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__KeyPhrase(struct soap *soap, ns1__KeyPhrase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__KeyPhrase * SOAP_FMAC4 soap_instantiate_ns1__KeyPhrase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__KeyPhrase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__KeyPhrase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__KeyPhrase;
		if (size)
			*size = sizeof(ns1__KeyPhrase);
		((ns1__KeyPhrase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__KeyPhrase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__KeyPhrase);
		for (int i = 0; i < n; i++)
			((ns1__KeyPhrase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__KeyPhrase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__KeyPhrase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__KeyPhrase %p -> %p\n", q, p));
	*(ns1__KeyPhrase*)p = *(ns1__KeyPhrase*)q;
}

void KeyPhraseArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void KeyPhraseArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_KeyPhraseArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__KeyPhrase(soap, this->__ptr + i);
		}
}

int KeyPhraseArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_KeyPhraseArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int KeyPhraseArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_KeyPhraseArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_KeyPhraseArray(struct soap *soap, const char *tag, int id, const KeyPhraseArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:KeyPhrase", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_KeyPhraseArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__KeyPhrase(soap, "item", -1, &a->__ptr[i], "ns1:KeyPhrase");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *KeyPhraseArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_KeyPhraseArray(soap, this, tag, type);
}

SOAP_FMAC3 KeyPhraseArray * SOAP_FMAC4 soap_get_KeyPhraseArray(struct soap *soap, KeyPhraseArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_KeyPhraseArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *KeyPhraseArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_KeyPhraseArray(soap, tag, this, type);
}

SOAP_FMAC3 KeyPhraseArray * SOAP_FMAC4 soap_in_KeyPhraseArray(struct soap *soap, const char *tag, KeyPhraseArray *a, const char *type)
{	int i, j;
	ns1__KeyPhrase **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (KeyPhraseArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_KeyPhraseArray, sizeof(KeyPhraseArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__KeyPhrase **)soap_malloc(soap, sizeof(ns1__KeyPhrase *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__KeyPhrase(soap, NULL, a->__ptr + i, "ns1:KeyPhrase"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__KeyPhrase **)soap_push_block(soap, NULL, sizeof(ns1__KeyPhrase *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__KeyPhrase(soap, NULL, p, "ns1:KeyPhrase"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__KeyPhrase **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (KeyPhraseArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_KeyPhraseArray, 0, sizeof(KeyPhraseArray), 0, soap_copy_KeyPhraseArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 KeyPhraseArray * SOAP_FMAC6 soap_new_KeyPhraseArray(struct soap *soap, int n)
{	return soap_instantiate_KeyPhraseArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_KeyPhraseArray(struct soap *soap, KeyPhraseArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 KeyPhraseArray * SOAP_FMAC4 soap_instantiate_KeyPhraseArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_KeyPhraseArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_KeyPhraseArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new KeyPhraseArray;
		if (size)
			*size = sizeof(KeyPhraseArray);
		((KeyPhraseArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new KeyPhraseArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(KeyPhraseArray);
		for (int i = 0; i < n; i++)
			((KeyPhraseArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (KeyPhraseArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_KeyPhraseArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying KeyPhraseArray %p -> %p\n", q, p));
	*(KeyPhraseArray*)p = *(KeyPhraseArray*)q;
}

void ns1__Details::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Details::Url = NULL;
	this->ns1__Details::Asin = NULL;
	this->ns1__Details::ProductName = NULL;
	this->ns1__Details::Catalog = NULL;
	this->ns1__Details::KeyPhrases = NULL;
	this->ns1__Details::Artists = NULL;
	this->ns1__Details::Authors = NULL;
	this->ns1__Details::Mpn = NULL;
	this->ns1__Details::Starring = NULL;
	this->ns1__Details::Directors = NULL;
	this->ns1__Details::TheatricalReleaseDate = NULL;
	this->ns1__Details::ReleaseDate = NULL;
	this->ns1__Details::Manufacturer = NULL;
	this->ns1__Details::Distributor = NULL;
	this->ns1__Details::ImageUrlSmall = NULL;
	this->ns1__Details::ImageUrlMedium = NULL;
	this->ns1__Details::ImageUrlLarge = NULL;
	this->ns1__Details::ListPrice = NULL;
	this->ns1__Details::OurPrice = NULL;
	this->ns1__Details::UsedPrice = NULL;
	this->ns1__Details::RefurbishedPrice = NULL;
	this->ns1__Details::CollectiblePrice = NULL;
	this->ns1__Details::ThirdPartyNewPrice = NULL;
	this->ns1__Details::NumberOfOfferings = NULL;
	this->ns1__Details::ThirdPartyNewCount = NULL;
	this->ns1__Details::UsedCount = NULL;
	this->ns1__Details::CollectibleCount = NULL;
	this->ns1__Details::RefurbishedCount = NULL;
	this->ns1__Details::ThirdPartyProductInfo = NULL;
	this->ns1__Details::SalesRank = NULL;
	this->ns1__Details::BrowseList = NULL;
	this->ns1__Details::Media = NULL;
	this->ns1__Details::ReadingLevel = NULL;
	this->ns1__Details::NumberOfPages = NULL;
	this->ns1__Details::NumberOfIssues = NULL;
	this->ns1__Details::IssuesPerYear = NULL;
	this->ns1__Details::SubscriptionLength = NULL;
	this->ns1__Details::DeweyNumber = NULL;
	this->ns1__Details::RunningTime = NULL;
	this->ns1__Details::Publisher = NULL;
	this->ns1__Details::NumMedia = NULL;
	this->ns1__Details::Isbn = NULL;
	this->ns1__Details::Features = NULL;
	this->ns1__Details::MpaaRating = NULL;
	this->ns1__Details::EsrbRating = NULL;
	this->ns1__Details::AgeGroup = NULL;
	this->ns1__Details::Availability = NULL;
	this->ns1__Details::Upc = NULL;
	this->ns1__Details::Tracks = NULL;
	this->ns1__Details::Accessories = NULL;
	this->ns1__Details::Platforms = NULL;
	this->ns1__Details::Encoding = NULL;
	this->ns1__Details::Reviews = NULL;
	this->ns1__Details::SimilarProducts = NULL;
	this->ns1__Details::Lists = NULL;
	this->ns1__Details::Status = NULL;
	/* transient soap skipped */
}

void ns1__Details::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Url);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Asin);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ProductName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Catalog);
	soap_serialize_PointerToKeyPhraseArray(soap, &this->ns1__Details::KeyPhrases);
	soap_serialize_PointerToArtistArray(soap, &this->ns1__Details::Artists);
	soap_serialize_PointerToAuthorArray(soap, &this->ns1__Details::Authors);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Mpn);
	soap_serialize_PointerToStarringArray(soap, &this->ns1__Details::Starring);
	soap_serialize_PointerToDirectorArray(soap, &this->ns1__Details::Directors);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::TheatricalReleaseDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ReleaseDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Manufacturer);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Distributor);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ImageUrlSmall);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ImageUrlMedium);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ImageUrlLarge);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ListPrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::OurPrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::UsedPrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::RefurbishedPrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::CollectiblePrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ThirdPartyNewPrice);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::NumberOfOfferings);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ThirdPartyNewCount);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::UsedCount);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::CollectibleCount);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::RefurbishedCount);
	soap_serialize_PointerTons1__ThirdPartyProductInfo(soap, &this->ns1__Details::ThirdPartyProductInfo);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::SalesRank);
	soap_serialize_PointerToBrowseNodeArray(soap, &this->ns1__Details::BrowseList);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Media);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::ReadingLevel);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::NumberOfPages);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::NumberOfIssues);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::IssuesPerYear);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::SubscriptionLength);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::DeweyNumber);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::RunningTime);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Publisher);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::NumMedia);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Isbn);
	soap_serialize_PointerToFeaturesArray(soap, &this->ns1__Details::Features);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::MpaaRating);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::EsrbRating);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::AgeGroup);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Availability);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Upc);
	soap_serialize_PointerToTrackArray(soap, &this->ns1__Details::Tracks);
	soap_serialize_PointerToAccessoryArray(soap, &this->ns1__Details::Accessories);
	soap_serialize_PointerToPlatformArray(soap, &this->ns1__Details::Platforms);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Encoding);
	soap_serialize_PointerTons1__Reviews(soap, &this->ns1__Details::Reviews);
	soap_serialize_PointerToSimilarProductsArray(soap, &this->ns1__Details::SimilarProducts);
	soap_serialize_PointerToListArray(soap, &this->ns1__Details::Lists);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Details::Status);
	/* transient soap skipped */
}

int ns1__Details::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Details);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Details::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Details(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Details(struct soap *soap, const char *tag, int id, const ns1__Details *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Details), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Url", -1, &(a->ns1__Details::Url), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Asin", -1, &(a->ns1__Details::Asin), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ProductName", -1, &(a->ns1__Details::ProductName), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Catalog", -1, &(a->ns1__Details::Catalog), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToKeyPhraseArray(soap, "KeyPhrases", -1, &(a->ns1__Details::KeyPhrases), "ns1:KeyPhrase"))
		return soap->error;
	if (soap_out_PointerToArtistArray(soap, "Artists", -1, &(a->ns1__Details::Artists), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToAuthorArray(soap, "Authors", -1, &(a->ns1__Details::Authors), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Mpn", -1, &(a->ns1__Details::Mpn), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToStarringArray(soap, "Starring", -1, &(a->ns1__Details::Starring), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToDirectorArray(soap, "Directors", -1, &(a->ns1__Details::Directors), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "TheatricalReleaseDate", -1, &(a->ns1__Details::TheatricalReleaseDate), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ReleaseDate", -1, &(a->ns1__Details::ReleaseDate), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Manufacturer", -1, &(a->ns1__Details::Manufacturer), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Distributor", -1, &(a->ns1__Details::Distributor), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ImageUrlSmall", -1, &(a->ns1__Details::ImageUrlSmall), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ImageUrlMedium", -1, &(a->ns1__Details::ImageUrlMedium), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ImageUrlLarge", -1, &(a->ns1__Details::ImageUrlLarge), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ListPrice", -1, &(a->ns1__Details::ListPrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "OurPrice", -1, &(a->ns1__Details::OurPrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "UsedPrice", -1, &(a->ns1__Details::UsedPrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "RefurbishedPrice", -1, &(a->ns1__Details::RefurbishedPrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CollectiblePrice", -1, &(a->ns1__Details::CollectiblePrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ThirdPartyNewPrice", -1, &(a->ns1__Details::ThirdPartyNewPrice), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfOfferings", -1, &(a->ns1__Details::NumberOfOfferings), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ThirdPartyNewCount", -1, &(a->ns1__Details::ThirdPartyNewCount), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "UsedCount", -1, &(a->ns1__Details::UsedCount), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CollectibleCount", -1, &(a->ns1__Details::CollectibleCount), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "RefurbishedCount", -1, &(a->ns1__Details::RefurbishedCount), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__ThirdPartyProductInfo(soap, "ThirdPartyProductInfo", -1, &(a->ns1__Details::ThirdPartyProductInfo), "ns1:ThirdPartyProductInfo"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SalesRank", -1, &(a->ns1__Details::SalesRank), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToBrowseNodeArray(soap, "BrowseList", -1, &(a->ns1__Details::BrowseList), "ns1:BrowseNode"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Media", -1, &(a->ns1__Details::Media), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ReadingLevel", -1, &(a->ns1__Details::ReadingLevel), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfPages", -1, &(a->ns1__Details::NumberOfPages), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumberOfIssues", -1, &(a->ns1__Details::NumberOfIssues), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "IssuesPerYear", -1, &(a->ns1__Details::IssuesPerYear), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "SubscriptionLength", -1, &(a->ns1__Details::SubscriptionLength), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "DeweyNumber", -1, &(a->ns1__Details::DeweyNumber), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "RunningTime", -1, &(a->ns1__Details::RunningTime), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Publisher", -1, &(a->ns1__Details::Publisher), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NumMedia", -1, &(a->ns1__Details::NumMedia), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Isbn", -1, &(a->ns1__Details::Isbn), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToFeaturesArray(soap, "Features", -1, &(a->ns1__Details::Features), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MpaaRating", -1, &(a->ns1__Details::MpaaRating), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "EsrbRating", -1, &(a->ns1__Details::EsrbRating), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "AgeGroup", -1, &(a->ns1__Details::AgeGroup), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Availability", -1, &(a->ns1__Details::Availability), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Upc", -1, &(a->ns1__Details::Upc), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToTrackArray(soap, "Tracks", -1, &(a->ns1__Details::Tracks), "ns1:Track"))
		return soap->error;
	if (soap_out_PointerToAccessoryArray(soap, "Accessories", -1, &(a->ns1__Details::Accessories), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToPlatformArray(soap, "Platforms", -1, &(a->ns1__Details::Platforms), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Encoding", -1, &(a->ns1__Details::Encoding), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__Reviews(soap, "Reviews", -1, &(a->ns1__Details::Reviews), "ns1:Reviews"))
		return soap->error;
	if (soap_out_PointerToSimilarProductsArray(soap, "SimilarProducts", -1, &(a->ns1__Details::SimilarProducts), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToListArray(soap, "Lists", -1, &(a->ns1__Details::Lists), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Status", -1, &(a->ns1__Details::Status), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Details::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Details(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Details * SOAP_FMAC4 soap_get_ns1__Details(struct soap *soap, ns1__Details *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Details(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Details::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Details(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Details * SOAP_FMAC4 soap_in_ns1__Details(struct soap *soap, const char *tag, ns1__Details *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Details *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Details, sizeof(ns1__Details), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Details)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Details *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Url1 = 1;
	size_t soap_flag_Asin1 = 1;
	size_t soap_flag_ProductName1 = 1;
	size_t soap_flag_Catalog1 = 1;
	size_t soap_flag_KeyPhrases1 = 1;
	size_t soap_flag_Artists1 = 1;
	size_t soap_flag_Authors1 = 1;
	size_t soap_flag_Mpn1 = 1;
	size_t soap_flag_Starring1 = 1;
	size_t soap_flag_Directors1 = 1;
	size_t soap_flag_TheatricalReleaseDate1 = 1;
	size_t soap_flag_ReleaseDate1 = 1;
	size_t soap_flag_Manufacturer1 = 1;
	size_t soap_flag_Distributor1 = 1;
	size_t soap_flag_ImageUrlSmall1 = 1;
	size_t soap_flag_ImageUrlMedium1 = 1;
	size_t soap_flag_ImageUrlLarge1 = 1;
	size_t soap_flag_ListPrice1 = 1;
	size_t soap_flag_OurPrice1 = 1;
	size_t soap_flag_UsedPrice1 = 1;
	size_t soap_flag_RefurbishedPrice1 = 1;
	size_t soap_flag_CollectiblePrice1 = 1;
	size_t soap_flag_ThirdPartyNewPrice1 = 1;
	size_t soap_flag_NumberOfOfferings1 = 1;
	size_t soap_flag_ThirdPartyNewCount1 = 1;
	size_t soap_flag_UsedCount1 = 1;
	size_t soap_flag_CollectibleCount1 = 1;
	size_t soap_flag_RefurbishedCount1 = 1;
	size_t soap_flag_ThirdPartyProductInfo1 = 1;
	size_t soap_flag_SalesRank1 = 1;
	size_t soap_flag_BrowseList1 = 1;
	size_t soap_flag_Media1 = 1;
	size_t soap_flag_ReadingLevel1 = 1;
	size_t soap_flag_NumberOfPages1 = 1;
	size_t soap_flag_NumberOfIssues1 = 1;
	size_t soap_flag_IssuesPerYear1 = 1;
	size_t soap_flag_SubscriptionLength1 = 1;
	size_t soap_flag_DeweyNumber1 = 1;
	size_t soap_flag_RunningTime1 = 1;
	size_t soap_flag_Publisher1 = 1;
	size_t soap_flag_NumMedia1 = 1;
	size_t soap_flag_Isbn1 = 1;
	size_t soap_flag_Features1 = 1;
	size_t soap_flag_MpaaRating1 = 1;
	size_t soap_flag_EsrbRating1 = 1;
	size_t soap_flag_AgeGroup1 = 1;
	size_t soap_flag_Availability1 = 1;
	size_t soap_flag_Upc1 = 1;
	size_t soap_flag_Tracks1 = 1;
	size_t soap_flag_Accessories1 = 1;
	size_t soap_flag_Platforms1 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Reviews1 = 1;
	size_t soap_flag_SimilarProducts1 = 1;
	size_t soap_flag_Lists1 = 1;
	size_t soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Url", &(a->ns1__Details::Url), "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_Asin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Asin", &(a->ns1__Details::Asin), "xsd:string"))
				{	soap_flag_Asin1--;
					continue;
				}
			if (soap_flag_ProductName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ProductName", &(a->ns1__Details::ProductName), "xsd:string"))
				{	soap_flag_ProductName1--;
					continue;
				}
			if (soap_flag_Catalog1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Catalog", &(a->ns1__Details::Catalog), "xsd:string"))
				{	soap_flag_Catalog1--;
					continue;
				}
			if (soap_flag_KeyPhrases1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToKeyPhraseArray(soap, "KeyPhrases", &(a->ns1__Details::KeyPhrases), "ns1:KeyPhrase"))
				{	soap_flag_KeyPhrases1--;
					continue;
				}
			if (soap_flag_Artists1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArtistArray(soap, "Artists", &(a->ns1__Details::Artists), "xsd:string"))
				{	soap_flag_Artists1--;
					continue;
				}
			if (soap_flag_Authors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToAuthorArray(soap, "Authors", &(a->ns1__Details::Authors), "xsd:string"))
				{	soap_flag_Authors1--;
					continue;
				}
			if (soap_flag_Mpn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Mpn", &(a->ns1__Details::Mpn), "xsd:string"))
				{	soap_flag_Mpn1--;
					continue;
				}
			if (soap_flag_Starring1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToStarringArray(soap, "Starring", &(a->ns1__Details::Starring), "xsd:string"))
				{	soap_flag_Starring1--;
					continue;
				}
			if (soap_flag_Directors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDirectorArray(soap, "Directors", &(a->ns1__Details::Directors), "xsd:string"))
				{	soap_flag_Directors1--;
					continue;
				}
			if (soap_flag_TheatricalReleaseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "TheatricalReleaseDate", &(a->ns1__Details::TheatricalReleaseDate), "xsd:string"))
				{	soap_flag_TheatricalReleaseDate1--;
					continue;
				}
			if (soap_flag_ReleaseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ReleaseDate", &(a->ns1__Details::ReleaseDate), "xsd:string"))
				{	soap_flag_ReleaseDate1--;
					continue;
				}
			if (soap_flag_Manufacturer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Manufacturer", &(a->ns1__Details::Manufacturer), "xsd:string"))
				{	soap_flag_Manufacturer1--;
					continue;
				}
			if (soap_flag_Distributor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Distributor", &(a->ns1__Details::Distributor), "xsd:string"))
				{	soap_flag_Distributor1--;
					continue;
				}
			if (soap_flag_ImageUrlSmall1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ImageUrlSmall", &(a->ns1__Details::ImageUrlSmall), "xsd:string"))
				{	soap_flag_ImageUrlSmall1--;
					continue;
				}
			if (soap_flag_ImageUrlMedium1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ImageUrlMedium", &(a->ns1__Details::ImageUrlMedium), "xsd:string"))
				{	soap_flag_ImageUrlMedium1--;
					continue;
				}
			if (soap_flag_ImageUrlLarge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ImageUrlLarge", &(a->ns1__Details::ImageUrlLarge), "xsd:string"))
				{	soap_flag_ImageUrlLarge1--;
					continue;
				}
			if (soap_flag_ListPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ListPrice", &(a->ns1__Details::ListPrice), "xsd:string"))
				{	soap_flag_ListPrice1--;
					continue;
				}
			if (soap_flag_OurPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "OurPrice", &(a->ns1__Details::OurPrice), "xsd:string"))
				{	soap_flag_OurPrice1--;
					continue;
				}
			if (soap_flag_UsedPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "UsedPrice", &(a->ns1__Details::UsedPrice), "xsd:string"))
				{	soap_flag_UsedPrice1--;
					continue;
				}
			if (soap_flag_RefurbishedPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "RefurbishedPrice", &(a->ns1__Details::RefurbishedPrice), "xsd:string"))
				{	soap_flag_RefurbishedPrice1--;
					continue;
				}
			if (soap_flag_CollectiblePrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CollectiblePrice", &(a->ns1__Details::CollectiblePrice), "xsd:string"))
				{	soap_flag_CollectiblePrice1--;
					continue;
				}
			if (soap_flag_ThirdPartyNewPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ThirdPartyNewPrice", &(a->ns1__Details::ThirdPartyNewPrice), "xsd:string"))
				{	soap_flag_ThirdPartyNewPrice1--;
					continue;
				}
			if (soap_flag_NumberOfOfferings1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfOfferings", &(a->ns1__Details::NumberOfOfferings), "xsd:string"))
				{	soap_flag_NumberOfOfferings1--;
					continue;
				}
			if (soap_flag_ThirdPartyNewCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ThirdPartyNewCount", &(a->ns1__Details::ThirdPartyNewCount), "xsd:string"))
				{	soap_flag_ThirdPartyNewCount1--;
					continue;
				}
			if (soap_flag_UsedCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "UsedCount", &(a->ns1__Details::UsedCount), "xsd:string"))
				{	soap_flag_UsedCount1--;
					continue;
				}
			if (soap_flag_CollectibleCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CollectibleCount", &(a->ns1__Details::CollectibleCount), "xsd:string"))
				{	soap_flag_CollectibleCount1--;
					continue;
				}
			if (soap_flag_RefurbishedCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "RefurbishedCount", &(a->ns1__Details::RefurbishedCount), "xsd:string"))
				{	soap_flag_RefurbishedCount1--;
					continue;
				}
			if (soap_flag_ThirdPartyProductInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ThirdPartyProductInfo(soap, "ThirdPartyProductInfo", &(a->ns1__Details::ThirdPartyProductInfo), "ns1:ThirdPartyProductInfo"))
				{	soap_flag_ThirdPartyProductInfo1--;
					continue;
				}
			if (soap_flag_SalesRank1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SalesRank", &(a->ns1__Details::SalesRank), "xsd:string"))
				{	soap_flag_SalesRank1--;
					continue;
				}
			if (soap_flag_BrowseList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToBrowseNodeArray(soap, "BrowseList", &(a->ns1__Details::BrowseList), "ns1:BrowseNode"))
				{	soap_flag_BrowseList1--;
					continue;
				}
			if (soap_flag_Media1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Media", &(a->ns1__Details::Media), "xsd:string"))
				{	soap_flag_Media1--;
					continue;
				}
			if (soap_flag_ReadingLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ReadingLevel", &(a->ns1__Details::ReadingLevel), "xsd:string"))
				{	soap_flag_ReadingLevel1--;
					continue;
				}
			if (soap_flag_NumberOfPages1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfPages", &(a->ns1__Details::NumberOfPages), "xsd:string"))
				{	soap_flag_NumberOfPages1--;
					continue;
				}
			if (soap_flag_NumberOfIssues1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumberOfIssues", &(a->ns1__Details::NumberOfIssues), "xsd:string"))
				{	soap_flag_NumberOfIssues1--;
					continue;
				}
			if (soap_flag_IssuesPerYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "IssuesPerYear", &(a->ns1__Details::IssuesPerYear), "xsd:string"))
				{	soap_flag_IssuesPerYear1--;
					continue;
				}
			if (soap_flag_SubscriptionLength1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "SubscriptionLength", &(a->ns1__Details::SubscriptionLength), "xsd:string"))
				{	soap_flag_SubscriptionLength1--;
					continue;
				}
			if (soap_flag_DeweyNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "DeweyNumber", &(a->ns1__Details::DeweyNumber), "xsd:string"))
				{	soap_flag_DeweyNumber1--;
					continue;
				}
			if (soap_flag_RunningTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "RunningTime", &(a->ns1__Details::RunningTime), "xsd:string"))
				{	soap_flag_RunningTime1--;
					continue;
				}
			if (soap_flag_Publisher1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Publisher", &(a->ns1__Details::Publisher), "xsd:string"))
				{	soap_flag_Publisher1--;
					continue;
				}
			if (soap_flag_NumMedia1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "NumMedia", &(a->ns1__Details::NumMedia), "xsd:string"))
				{	soap_flag_NumMedia1--;
					continue;
				}
			if (soap_flag_Isbn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Isbn", &(a->ns1__Details::Isbn), "xsd:string"))
				{	soap_flag_Isbn1--;
					continue;
				}
			if (soap_flag_Features1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToFeaturesArray(soap, "Features", &(a->ns1__Details::Features), "xsd:string"))
				{	soap_flag_Features1--;
					continue;
				}
			if (soap_flag_MpaaRating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MpaaRating", &(a->ns1__Details::MpaaRating), "xsd:string"))
				{	soap_flag_MpaaRating1--;
					continue;
				}
			if (soap_flag_EsrbRating1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "EsrbRating", &(a->ns1__Details::EsrbRating), "xsd:string"))
				{	soap_flag_EsrbRating1--;
					continue;
				}
			if (soap_flag_AgeGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "AgeGroup", &(a->ns1__Details::AgeGroup), "xsd:string"))
				{	soap_flag_AgeGroup1--;
					continue;
				}
			if (soap_flag_Availability1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Availability", &(a->ns1__Details::Availability), "xsd:string"))
				{	soap_flag_Availability1--;
					continue;
				}
			if (soap_flag_Upc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Upc", &(a->ns1__Details::Upc), "xsd:string"))
				{	soap_flag_Upc1--;
					continue;
				}
			if (soap_flag_Tracks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTrackArray(soap, "Tracks", &(a->ns1__Details::Tracks), "ns1:Track"))
				{	soap_flag_Tracks1--;
					continue;
				}
			if (soap_flag_Accessories1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToAccessoryArray(soap, "Accessories", &(a->ns1__Details::Accessories), "xsd:string"))
				{	soap_flag_Accessories1--;
					continue;
				}
			if (soap_flag_Platforms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPlatformArray(soap, "Platforms", &(a->ns1__Details::Platforms), "xsd:string"))
				{	soap_flag_Platforms1--;
					continue;
				}
			if (soap_flag_Encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Encoding", &(a->ns1__Details::Encoding), "xsd:string"))
				{	soap_flag_Encoding1--;
					continue;
				}
			if (soap_flag_Reviews1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Reviews(soap, "Reviews", &(a->ns1__Details::Reviews), "ns1:Reviews"))
				{	soap_flag_Reviews1--;
					continue;
				}
			if (soap_flag_SimilarProducts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSimilarProductsArray(soap, "SimilarProducts", &(a->ns1__Details::SimilarProducts), "xsd:string"))
				{	soap_flag_SimilarProducts1--;
					continue;
				}
			if (soap_flag_Lists1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToListArray(soap, "Lists", &(a->ns1__Details::Lists), "xsd:string"))
				{	soap_flag_Lists1--;
					continue;
				}
			if (soap_flag_Status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Status", &(a->ns1__Details::Status), "xsd:string"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Details *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Details, 0, sizeof(ns1__Details), 0, soap_copy_ns1__Details);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Details * SOAP_FMAC6 soap_new_ns1__Details(struct soap *soap, int n)
{	return soap_instantiate_ns1__Details(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Details(struct soap *soap, ns1__Details *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Details * SOAP_FMAC4 soap_instantiate_ns1__Details(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Details(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Details, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Details;
		if (size)
			*size = sizeof(ns1__Details);
		((ns1__Details*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Details[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Details);
		for (int i = 0; i < n; i++)
			((ns1__Details*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Details*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Details(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Details %p -> %p\n", q, p));
	*(ns1__Details*)p = *(ns1__Details*)q;
}

void DetailsArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void DetailsArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_DetailsArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__Details(soap, this->__ptr + i);
		}
}

int DetailsArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_DetailsArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DetailsArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_DetailsArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DetailsArray(struct soap *soap, const char *tag, int id, const DetailsArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:Details", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_DetailsArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Details(soap, "item", -1, &a->__ptr[i], "ns1:Details");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *DetailsArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DetailsArray(soap, this, tag, type);
}

SOAP_FMAC3 DetailsArray * SOAP_FMAC4 soap_get_DetailsArray(struct soap *soap, DetailsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_DetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *DetailsArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DetailsArray(soap, tag, this, type);
}

SOAP_FMAC3 DetailsArray * SOAP_FMAC4 soap_in_DetailsArray(struct soap *soap, const char *tag, DetailsArray *a, const char *type)
{	int i, j;
	ns1__Details **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (DetailsArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DetailsArray, sizeof(DetailsArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__Details **)soap_malloc(soap, sizeof(ns1__Details *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Details(soap, NULL, a->__ptr + i, "ns1:Details"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Details **)soap_push_block(soap, NULL, sizeof(ns1__Details *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Details(soap, NULL, p, "ns1:Details"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__Details **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DetailsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_DetailsArray, 0, sizeof(DetailsArray), 0, soap_copy_DetailsArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DetailsArray * SOAP_FMAC6 soap_new_DetailsArray(struct soap *soap, int n)
{	return soap_instantiate_DetailsArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DetailsArray(struct soap *soap, DetailsArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DetailsArray * SOAP_FMAC4 soap_instantiate_DetailsArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DetailsArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DetailsArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DetailsArray;
		if (size)
			*size = sizeof(DetailsArray);
		((DetailsArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new DetailsArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(DetailsArray);
		for (int i = 0; i < n; i++)
			((DetailsArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DetailsArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DetailsArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DetailsArray %p -> %p\n", q, p));
	*(DetailsArray*)p = *(DetailsArray*)q;
}

void ns1__ProductInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ProductInfo::TotalResults = NULL;
	this->ns1__ProductInfo::TotalPages = NULL;
	this->ns1__ProductInfo::ListName = NULL;
	this->ns1__ProductInfo::Details = NULL;
	/* transient soap skipped */
}

void ns1__ProductInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ProductInfo::TotalResults);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ProductInfo::TotalPages);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ProductInfo::ListName);
	soap_serialize_PointerToDetailsArray(soap, &this->ns1__ProductInfo::Details);
	/* transient soap skipped */
}

int ns1__ProductInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ProductInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ProductInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProductInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProductInfo(struct soap *soap, const char *tag, int id, const ns1__ProductInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProductInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "TotalResults", -1, &(a->ns1__ProductInfo::TotalResults), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "TotalPages", -1, &(a->ns1__ProductInfo::TotalPages), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ListName", -1, &(a->ns1__ProductInfo::ListName), "xsd:string"))
		return soap->error;
	if (soap_out_PointerToDetailsArray(soap, "Details", -1, &(a->ns1__ProductInfo::Details), "ns1:Details"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ProductInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProductInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProductInfo * SOAP_FMAC4 soap_get_ns1__ProductInfo(struct soap *soap, ns1__ProductInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProductInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ProductInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ProductInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProductInfo * SOAP_FMAC4 soap_in_ns1__ProductInfo(struct soap *soap, const char *tag, ns1__ProductInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ProductInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProductInfo, sizeof(ns1__ProductInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ProductInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ProductInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalResults1 = 1;
	size_t soap_flag_TotalPages1 = 1;
	size_t soap_flag_ListName1 = 1;
	size_t soap_flag_Details1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalResults1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "TotalResults", &(a->ns1__ProductInfo::TotalResults), "xsd:string"))
				{	soap_flag_TotalResults1--;
					continue;
				}
			if (soap_flag_TotalPages1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "TotalPages", &(a->ns1__ProductInfo::TotalPages), "xsd:string"))
				{	soap_flag_TotalPages1--;
					continue;
				}
			if (soap_flag_ListName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ListName", &(a->ns1__ProductInfo::ListName), "xsd:string"))
				{	soap_flag_ListName1--;
					continue;
				}
			if (soap_flag_Details1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDetailsArray(soap, "Details", &(a->ns1__ProductInfo::Details), "ns1:Details"))
				{	soap_flag_Details1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ProductInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProductInfo, 0, sizeof(ns1__ProductInfo), 0, soap_copy_ns1__ProductInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ProductInfo * SOAP_FMAC6 soap_new_ns1__ProductInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__ProductInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ProductInfo(struct soap *soap, ns1__ProductInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ProductInfo * SOAP_FMAC4 soap_instantiate_ns1__ProductInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProductInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProductInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ProductInfo;
		if (size)
			*size = sizeof(ns1__ProductInfo);
		((ns1__ProductInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ProductInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ProductInfo);
		for (int i = 0; i < n; i++)
			((ns1__ProductInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ProductInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ProductInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ProductInfo %p -> %p\n", q, p));
	*(ns1__ProductInfo*)p = *(ns1__ProductInfo*)q;
}

void ns1__ProductLine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ProductLine::Mode = NULL;
	this->ns1__ProductLine::ProductInfo = NULL;
	/* transient soap skipped */
}

void ns1__ProductLine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ProductLine::Mode);
	soap_serialize_PointerTons1__ProductInfo(soap, &this->ns1__ProductLine::ProductInfo);
	/* transient soap skipped */
}

int ns1__ProductLine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ProductLine);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ProductLine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProductLine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProductLine(struct soap *soap, const char *tag, int id, const ns1__ProductLine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProductLine), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Mode", -1, &(a->ns1__ProductLine::Mode), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "ProductInfo", -1, &(a->ns1__ProductLine::ProductInfo), "ns1:ProductInfo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ProductLine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProductLine(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProductLine * SOAP_FMAC4 soap_get_ns1__ProductLine(struct soap *soap, ns1__ProductLine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProductLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ProductLine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ProductLine(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProductLine * SOAP_FMAC4 soap_in_ns1__ProductLine(struct soap *soap, const char *tag, ns1__ProductLine *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ProductLine *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProductLine, sizeof(ns1__ProductLine), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ProductLine)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ProductLine *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_ProductInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Mode", &(a->ns1__ProductLine::Mode), "xsd:string"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_ProductInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "ProductInfo", &(a->ns1__ProductLine::ProductInfo), "ns1:ProductInfo"))
				{	soap_flag_ProductInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ProductLine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProductLine, 0, sizeof(ns1__ProductLine), 0, soap_copy_ns1__ProductLine);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ProductLine * SOAP_FMAC6 soap_new_ns1__ProductLine(struct soap *soap, int n)
{	return soap_instantiate_ns1__ProductLine(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ProductLine(struct soap *soap, ns1__ProductLine *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ProductLine * SOAP_FMAC4 soap_instantiate_ns1__ProductLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProductLine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProductLine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ProductLine;
		if (size)
			*size = sizeof(ns1__ProductLine);
		((ns1__ProductLine*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ProductLine[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ProductLine);
		for (int i = 0; i < n; i++)
			((ns1__ProductLine*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ProductLine*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ProductLine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ProductLine %p -> %p\n", q, p));
	*(ns1__ProductLine*)p = *(ns1__ProductLine*)q;
}

void ProductLineArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ProductLineArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ProductLineArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ProductLine(soap, this->__ptr + i);
		}
}

int ProductLineArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ProductLineArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ProductLineArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ProductLineArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ProductLineArray(struct soap *soap, const char *tag, int id, const ProductLineArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ProductLine", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ProductLineArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ProductLine(soap, "item", -1, &a->__ptr[i], "ns1:ProductLine");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ProductLineArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ProductLineArray(soap, this, tag, type);
}

SOAP_FMAC3 ProductLineArray * SOAP_FMAC4 soap_get_ProductLineArray(struct soap *soap, ProductLineArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ProductLineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ProductLineArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ProductLineArray(soap, tag, this, type);
}

SOAP_FMAC3 ProductLineArray * SOAP_FMAC4 soap_in_ProductLineArray(struct soap *soap, const char *tag, ProductLineArray *a, const char *type)
{	int i, j;
	ns1__ProductLine **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ProductLineArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ProductLineArray, sizeof(ProductLineArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ProductLine **)soap_malloc(soap, sizeof(ns1__ProductLine *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ProductLine(soap, NULL, a->__ptr + i, "ns1:ProductLine"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ProductLine **)soap_push_block(soap, NULL, sizeof(ns1__ProductLine *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ProductLine(soap, NULL, p, "ns1:ProductLine"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__ProductLine **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ProductLineArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ProductLineArray, 0, sizeof(ProductLineArray), 0, soap_copy_ProductLineArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ProductLineArray * SOAP_FMAC6 soap_new_ProductLineArray(struct soap *soap, int n)
{	return soap_instantiate_ProductLineArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ProductLineArray(struct soap *soap, ProductLineArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ProductLineArray * SOAP_FMAC4 soap_instantiate_ProductLineArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ProductLineArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ProductLineArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ProductLineArray;
		if (size)
			*size = sizeof(ProductLineArray);
		((ProductLineArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ProductLineArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ProductLineArray);
		for (int i = 0; i < n; i++)
			((ProductLineArray*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ProductLineArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ProductLineArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ProductLineArray %p -> %p\n", q, p));
	*(ProductLineArray*)p = *(ProductLineArray*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, struct ns1__ModifyShoppingCartItemsRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ModifyShoppingCartItemsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, const struct ns1__ModifyShoppingCartItemsRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ModifyShoppingCartItemsRequest(soap, &a->ModifyShoppingCartItemsRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, const struct ns1__ModifyShoppingCartItemsRequest_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_);
	if (soap_out_ns1__ModifyShoppingCartItemsRequest_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, const char *tag, int id, const struct ns1__ModifyShoppingCartItemsRequest_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_), type))
		return soap->error;
	if (soap_out_PointerTons1__ModifyShoppingCartItemsRequest(soap, "ModifyShoppingCartItemsRequest", -1, &a->ModifyShoppingCartItemsRequest, "ns1:ModifyShoppingCartItemsRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ModifyShoppingCartItemsRequest_ * SOAP_FMAC4 soap_get_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, struct ns1__ModifyShoppingCartItemsRequest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ModifyShoppingCartItemsRequest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ModifyShoppingCartItemsRequest_ * SOAP_FMAC4 soap_in_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, const char *tag, struct ns1__ModifyShoppingCartItemsRequest_ *a, const char *type)
{
	size_t soap_flag_ModifyShoppingCartItemsRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ModifyShoppingCartItemsRequest_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_, sizeof(struct ns1__ModifyShoppingCartItemsRequest_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ModifyShoppingCartItemsRequest_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ModifyShoppingCartItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ModifyShoppingCartItemsRequest(soap, "ModifyShoppingCartItemsRequest", &a->ModifyShoppingCartItemsRequest, "ns1:ModifyShoppingCartItemsRequest"))
				{	soap_flag_ModifyShoppingCartItemsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ModifyShoppingCartItemsRequest_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_, 0, sizeof(struct ns1__ModifyShoppingCartItemsRequest_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ModifyShoppingCartItemsRequest_ * SOAP_FMAC6 soap_new_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, int n)
{	return soap_instantiate_ns1__ModifyShoppingCartItemsRequest_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, struct ns1__ModifyShoppingCartItemsRequest_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ModifyShoppingCartItemsRequest_ * SOAP_FMAC4 soap_instantiate_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ModifyShoppingCartItemsRequest_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ModifyShoppingCartItemsRequest_;
		if (size)
			*size = sizeof(struct ns1__ModifyShoppingCartItemsRequest_);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ModifyShoppingCartItemsRequest_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ModifyShoppingCartItemsRequest_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ModifyShoppingCartItemsRequest_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ModifyShoppingCartItemsRequest_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ModifyShoppingCartItemsRequest_ %p -> %p\n", q, p));
	*(struct ns1__ModifyShoppingCartItemsRequest_*)p = *(struct ns1__ModifyShoppingCartItemsRequest_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__ModifyShoppingCartItemsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ShoppingCart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, const struct ns1__ModifyShoppingCartItemsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ShoppingCart(soap, &a->ShoppingCart);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, const struct ns1__ModifyShoppingCartItemsRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse);
	if (soap_out_ns1__ModifyShoppingCartItemsRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__ModifyShoppingCartItemsRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ShoppingCart(soap, "ShoppingCart", -1, &a->ShoppingCart, "ns1:ShoppingCart"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ModifyShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_get_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__ModifyShoppingCartItemsRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ModifyShoppingCartItemsRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ModifyShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_in_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, const char *tag, struct ns1__ModifyShoppingCartItemsRequestResponse *a, const char *type)
{
	size_t soap_flag_ShoppingCart = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ModifyShoppingCartItemsRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse, sizeof(struct ns1__ModifyShoppingCartItemsRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ModifyShoppingCartItemsRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShoppingCart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ShoppingCart(soap, "ShoppingCart", &a->ShoppingCart, "ns1:ShoppingCart"))
				{	soap_flag_ShoppingCart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ModifyShoppingCartItemsRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse, 0, sizeof(struct ns1__ModifyShoppingCartItemsRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ModifyShoppingCartItemsRequestResponse * SOAP_FMAC6 soap_new_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__ModifyShoppingCartItemsRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__ModifyShoppingCartItemsRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ModifyShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ModifyShoppingCartItemsRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ModifyShoppingCartItemsRequestResponse;
		if (size)
			*size = sizeof(struct ns1__ModifyShoppingCartItemsRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ModifyShoppingCartItemsRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ModifyShoppingCartItemsRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ModifyShoppingCartItemsRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ModifyShoppingCartItemsRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ModifyShoppingCartItemsRequestResponse %p -> %p\n", q, p));
	*(struct ns1__ModifyShoppingCartItemsRequestResponse*)p = *(struct ns1__ModifyShoppingCartItemsRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, struct ns1__RemoveShoppingCartItemsRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoveShoppingCartItemsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, const struct ns1__RemoveShoppingCartItemsRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RemoveShoppingCartItemsRequest(soap, &a->RemoveShoppingCartItemsRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, const struct ns1__RemoveShoppingCartItemsRequest_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_);
	if (soap_out_ns1__RemoveShoppingCartItemsRequest_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, const char *tag, int id, const struct ns1__RemoveShoppingCartItemsRequest_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_), type))
		return soap->error;
	if (soap_out_PointerTons1__RemoveShoppingCartItemsRequest(soap, "RemoveShoppingCartItemsRequest", -1, &a->RemoveShoppingCartItemsRequest, "ns1:RemoveShoppingCartItemsRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__RemoveShoppingCartItemsRequest_ * SOAP_FMAC4 soap_get_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, struct ns1__RemoveShoppingCartItemsRequest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemoveShoppingCartItemsRequest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__RemoveShoppingCartItemsRequest_ * SOAP_FMAC4 soap_in_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, const char *tag, struct ns1__RemoveShoppingCartItemsRequest_ *a, const char *type)
{
	size_t soap_flag_RemoveShoppingCartItemsRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__RemoveShoppingCartItemsRequest_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_, sizeof(struct ns1__RemoveShoppingCartItemsRequest_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__RemoveShoppingCartItemsRequest_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoveShoppingCartItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RemoveShoppingCartItemsRequest(soap, "RemoveShoppingCartItemsRequest", &a->RemoveShoppingCartItemsRequest, "ns1:RemoveShoppingCartItemsRequest"))
				{	soap_flag_RemoveShoppingCartItemsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__RemoveShoppingCartItemsRequest_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_, 0, sizeof(struct ns1__RemoveShoppingCartItemsRequest_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__RemoveShoppingCartItemsRequest_ * SOAP_FMAC6 soap_new_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, int n)
{	return soap_instantiate_ns1__RemoveShoppingCartItemsRequest_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, struct ns1__RemoveShoppingCartItemsRequest_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__RemoveShoppingCartItemsRequest_ * SOAP_FMAC4 soap_instantiate_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemoveShoppingCartItemsRequest_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__RemoveShoppingCartItemsRequest_;
		if (size)
			*size = sizeof(struct ns1__RemoveShoppingCartItemsRequest_);
	}
	else
	{	cp->ptr = (void*)new struct ns1__RemoveShoppingCartItemsRequest_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__RemoveShoppingCartItemsRequest_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__RemoveShoppingCartItemsRequest_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RemoveShoppingCartItemsRequest_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__RemoveShoppingCartItemsRequest_ %p -> %p\n", q, p));
	*(struct ns1__RemoveShoppingCartItemsRequest_*)p = *(struct ns1__RemoveShoppingCartItemsRequest_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__RemoveShoppingCartItemsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ShoppingCart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, const struct ns1__RemoveShoppingCartItemsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ShoppingCart(soap, &a->ShoppingCart);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, const struct ns1__RemoveShoppingCartItemsRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse);
	if (soap_out_ns1__RemoveShoppingCartItemsRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__RemoveShoppingCartItemsRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ShoppingCart(soap, "ShoppingCart", -1, &a->ShoppingCart, "ns1:ShoppingCart"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__RemoveShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_get_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__RemoveShoppingCartItemsRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemoveShoppingCartItemsRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__RemoveShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_in_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, const char *tag, struct ns1__RemoveShoppingCartItemsRequestResponse *a, const char *type)
{
	size_t soap_flag_ShoppingCart = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__RemoveShoppingCartItemsRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse, sizeof(struct ns1__RemoveShoppingCartItemsRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__RemoveShoppingCartItemsRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShoppingCart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ShoppingCart(soap, "ShoppingCart", &a->ShoppingCart, "ns1:ShoppingCart"))
				{	soap_flag_ShoppingCart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__RemoveShoppingCartItemsRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse, 0, sizeof(struct ns1__RemoveShoppingCartItemsRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__RemoveShoppingCartItemsRequestResponse * SOAP_FMAC6 soap_new_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__RemoveShoppingCartItemsRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__RemoveShoppingCartItemsRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__RemoveShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RemoveShoppingCartItemsRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__RemoveShoppingCartItemsRequestResponse;
		if (size)
			*size = sizeof(struct ns1__RemoveShoppingCartItemsRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__RemoveShoppingCartItemsRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__RemoveShoppingCartItemsRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__RemoveShoppingCartItemsRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RemoveShoppingCartItemsRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__RemoveShoppingCartItemsRequestResponse %p -> %p\n", q, p));
	*(struct ns1__RemoveShoppingCartItemsRequestResponse*)p = *(struct ns1__RemoveShoppingCartItemsRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AddShoppingCartItemsRequest_(struct soap *soap, struct ns1__AddShoppingCartItemsRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AddShoppingCartItemsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AddShoppingCartItemsRequest_(struct soap *soap, const struct ns1__AddShoppingCartItemsRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AddShoppingCartItemsRequest(soap, &a->AddShoppingCartItemsRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AddShoppingCartItemsRequest_(struct soap *soap, const struct ns1__AddShoppingCartItemsRequest_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AddShoppingCartItemsRequest_);
	if (soap_out_ns1__AddShoppingCartItemsRequest_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddShoppingCartItemsRequest_(struct soap *soap, const char *tag, int id, const struct ns1__AddShoppingCartItemsRequest_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddShoppingCartItemsRequest_), type))
		return soap->error;
	if (soap_out_PointerTons1__AddShoppingCartItemsRequest(soap, "AddShoppingCartItemsRequest", -1, &a->AddShoppingCartItemsRequest, "ns1:AddShoppingCartItemsRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AddShoppingCartItemsRequest_ * SOAP_FMAC4 soap_get_ns1__AddShoppingCartItemsRequest_(struct soap *soap, struct ns1__AddShoppingCartItemsRequest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddShoppingCartItemsRequest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AddShoppingCartItemsRequest_ * SOAP_FMAC4 soap_in_ns1__AddShoppingCartItemsRequest_(struct soap *soap, const char *tag, struct ns1__AddShoppingCartItemsRequest_ *a, const char *type)
{
	size_t soap_flag_AddShoppingCartItemsRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AddShoppingCartItemsRequest_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddShoppingCartItemsRequest_, sizeof(struct ns1__AddShoppingCartItemsRequest_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AddShoppingCartItemsRequest_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddShoppingCartItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AddShoppingCartItemsRequest(soap, "AddShoppingCartItemsRequest", &a->AddShoppingCartItemsRequest, "ns1:AddShoppingCartItemsRequest"))
				{	soap_flag_AddShoppingCartItemsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AddShoppingCartItemsRequest_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddShoppingCartItemsRequest_, 0, sizeof(struct ns1__AddShoppingCartItemsRequest_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__AddShoppingCartItemsRequest_ * SOAP_FMAC6 soap_new_ns1__AddShoppingCartItemsRequest_(struct soap *soap, int n)
{	return soap_instantiate_ns1__AddShoppingCartItemsRequest_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AddShoppingCartItemsRequest_(struct soap *soap, struct ns1__AddShoppingCartItemsRequest_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__AddShoppingCartItemsRequest_ * SOAP_FMAC4 soap_instantiate_ns1__AddShoppingCartItemsRequest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddShoppingCartItemsRequest_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AddShoppingCartItemsRequest_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__AddShoppingCartItemsRequest_;
		if (size)
			*size = sizeof(struct ns1__AddShoppingCartItemsRequest_);
	}
	else
	{	cp->ptr = (void*)new struct ns1__AddShoppingCartItemsRequest_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__AddShoppingCartItemsRequest_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__AddShoppingCartItemsRequest_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AddShoppingCartItemsRequest_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__AddShoppingCartItemsRequest_ %p -> %p\n", q, p));
	*(struct ns1__AddShoppingCartItemsRequest_*)p = *(struct ns1__AddShoppingCartItemsRequest_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__AddShoppingCartItemsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ShoppingCart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, const struct ns1__AddShoppingCartItemsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ShoppingCart(soap, &a->ShoppingCart);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, const struct ns1__AddShoppingCartItemsRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse);
	if (soap_out_ns1__AddShoppingCartItemsRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__AddShoppingCartItemsRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ShoppingCart(soap, "ShoppingCart", -1, &a->ShoppingCart, "ns1:ShoppingCart"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AddShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_get_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__AddShoppingCartItemsRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddShoppingCartItemsRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AddShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_in_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, const char *tag, struct ns1__AddShoppingCartItemsRequestResponse *a, const char *type)
{
	size_t soap_flag_ShoppingCart = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AddShoppingCartItemsRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse, sizeof(struct ns1__AddShoppingCartItemsRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AddShoppingCartItemsRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShoppingCart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ShoppingCart(soap, "ShoppingCart", &a->ShoppingCart, "ns1:ShoppingCart"))
				{	soap_flag_ShoppingCart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AddShoppingCartItemsRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse, 0, sizeof(struct ns1__AddShoppingCartItemsRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__AddShoppingCartItemsRequestResponse * SOAP_FMAC6 soap_new_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__AddShoppingCartItemsRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, struct ns1__AddShoppingCartItemsRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__AddShoppingCartItemsRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddShoppingCartItemsRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AddShoppingCartItemsRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__AddShoppingCartItemsRequestResponse;
		if (size)
			*size = sizeof(struct ns1__AddShoppingCartItemsRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__AddShoppingCartItemsRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__AddShoppingCartItemsRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__AddShoppingCartItemsRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AddShoppingCartItemsRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__AddShoppingCartItemsRequestResponse %p -> %p\n", q, p));
	*(struct ns1__AddShoppingCartItemsRequestResponse*)p = *(struct ns1__AddShoppingCartItemsRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ClearShoppingCartRequest_(struct soap *soap, struct ns1__ClearShoppingCartRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ClearShoppingCartRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ClearShoppingCartRequest_(struct soap *soap, const struct ns1__ClearShoppingCartRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ClearShoppingCartRequest(soap, &a->ClearShoppingCartRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ClearShoppingCartRequest_(struct soap *soap, const struct ns1__ClearShoppingCartRequest_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ClearShoppingCartRequest_);
	if (soap_out_ns1__ClearShoppingCartRequest_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearShoppingCartRequest_(struct soap *soap, const char *tag, int id, const struct ns1__ClearShoppingCartRequest_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearShoppingCartRequest_), type))
		return soap->error;
	if (soap_out_PointerTons1__ClearShoppingCartRequest(soap, "ClearShoppingCartRequest", -1, &a->ClearShoppingCartRequest, "ns1:ClearShoppingCartRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ClearShoppingCartRequest_ * SOAP_FMAC4 soap_get_ns1__ClearShoppingCartRequest_(struct soap *soap, struct ns1__ClearShoppingCartRequest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearShoppingCartRequest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ClearShoppingCartRequest_ * SOAP_FMAC4 soap_in_ns1__ClearShoppingCartRequest_(struct soap *soap, const char *tag, struct ns1__ClearShoppingCartRequest_ *a, const char *type)
{
	size_t soap_flag_ClearShoppingCartRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ClearShoppingCartRequest_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearShoppingCartRequest_, sizeof(struct ns1__ClearShoppingCartRequest_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ClearShoppingCartRequest_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClearShoppingCartRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ClearShoppingCartRequest(soap, "ClearShoppingCartRequest", &a->ClearShoppingCartRequest, "ns1:ClearShoppingCartRequest"))
				{	soap_flag_ClearShoppingCartRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ClearShoppingCartRequest_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearShoppingCartRequest_, 0, sizeof(struct ns1__ClearShoppingCartRequest_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ClearShoppingCartRequest_ * SOAP_FMAC6 soap_new_ns1__ClearShoppingCartRequest_(struct soap *soap, int n)
{	return soap_instantiate_ns1__ClearShoppingCartRequest_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ClearShoppingCartRequest_(struct soap *soap, struct ns1__ClearShoppingCartRequest_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ClearShoppingCartRequest_ * SOAP_FMAC4 soap_instantiate_ns1__ClearShoppingCartRequest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearShoppingCartRequest_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ClearShoppingCartRequest_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ClearShoppingCartRequest_;
		if (size)
			*size = sizeof(struct ns1__ClearShoppingCartRequest_);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ClearShoppingCartRequest_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ClearShoppingCartRequest_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ClearShoppingCartRequest_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ClearShoppingCartRequest_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ClearShoppingCartRequest_ %p -> %p\n", q, p));
	*(struct ns1__ClearShoppingCartRequest_*)p = *(struct ns1__ClearShoppingCartRequest_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ClearShoppingCartRequestResponse(struct soap *soap, struct ns1__ClearShoppingCartRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ShoppingCart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ClearShoppingCartRequestResponse(struct soap *soap, const struct ns1__ClearShoppingCartRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ShoppingCart(soap, &a->ShoppingCart);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ClearShoppingCartRequestResponse(struct soap *soap, const struct ns1__ClearShoppingCartRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ClearShoppingCartRequestResponse);
	if (soap_out_ns1__ClearShoppingCartRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearShoppingCartRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__ClearShoppingCartRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearShoppingCartRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ShoppingCart(soap, "ShoppingCart", -1, &a->ShoppingCart, "ns1:ShoppingCart"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ClearShoppingCartRequestResponse * SOAP_FMAC4 soap_get_ns1__ClearShoppingCartRequestResponse(struct soap *soap, struct ns1__ClearShoppingCartRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearShoppingCartRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ClearShoppingCartRequestResponse * SOAP_FMAC4 soap_in_ns1__ClearShoppingCartRequestResponse(struct soap *soap, const char *tag, struct ns1__ClearShoppingCartRequestResponse *a, const char *type)
{
	size_t soap_flag_ShoppingCart = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ClearShoppingCartRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearShoppingCartRequestResponse, sizeof(struct ns1__ClearShoppingCartRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ClearShoppingCartRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShoppingCart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ShoppingCart(soap, "ShoppingCart", &a->ShoppingCart, "ns1:ShoppingCart"))
				{	soap_flag_ShoppingCart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ClearShoppingCartRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearShoppingCartRequestResponse, 0, sizeof(struct ns1__ClearShoppingCartRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ClearShoppingCartRequestResponse * SOAP_FMAC6 soap_new_ns1__ClearShoppingCartRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__ClearShoppingCartRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ClearShoppingCartRequestResponse(struct soap *soap, struct ns1__ClearShoppingCartRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ClearShoppingCartRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__ClearShoppingCartRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearShoppingCartRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ClearShoppingCartRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ClearShoppingCartRequestResponse;
		if (size)
			*size = sizeof(struct ns1__ClearShoppingCartRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ClearShoppingCartRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ClearShoppingCartRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ClearShoppingCartRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ClearShoppingCartRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ClearShoppingCartRequestResponse %p -> %p\n", q, p));
	*(struct ns1__ClearShoppingCartRequestResponse*)p = *(struct ns1__ClearShoppingCartRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetShoppingCartRequest_(struct soap *soap, struct ns1__GetShoppingCartRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetShoppingCartRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetShoppingCartRequest_(struct soap *soap, const struct ns1__GetShoppingCartRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GetShoppingCartRequest(soap, &a->GetShoppingCartRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetShoppingCartRequest_(struct soap *soap, const struct ns1__GetShoppingCartRequest_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetShoppingCartRequest_);
	if (soap_out_ns1__GetShoppingCartRequest_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetShoppingCartRequest_(struct soap *soap, const char *tag, int id, const struct ns1__GetShoppingCartRequest_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetShoppingCartRequest_), type))
		return soap->error;
	if (soap_out_PointerTons1__GetShoppingCartRequest(soap, "GetShoppingCartRequest", -1, &a->GetShoppingCartRequest, "ns1:GetShoppingCartRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetShoppingCartRequest_ * SOAP_FMAC4 soap_get_ns1__GetShoppingCartRequest_(struct soap *soap, struct ns1__GetShoppingCartRequest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetShoppingCartRequest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__GetShoppingCartRequest_ * SOAP_FMAC4 soap_in_ns1__GetShoppingCartRequest_(struct soap *soap, const char *tag, struct ns1__GetShoppingCartRequest_ *a, const char *type)
{
	size_t soap_flag_GetShoppingCartRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetShoppingCartRequest_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetShoppingCartRequest_, sizeof(struct ns1__GetShoppingCartRequest_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetShoppingCartRequest_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShoppingCartRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GetShoppingCartRequest(soap, "GetShoppingCartRequest", &a->GetShoppingCartRequest, "ns1:GetShoppingCartRequest"))
				{	soap_flag_GetShoppingCartRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetShoppingCartRequest_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetShoppingCartRequest_, 0, sizeof(struct ns1__GetShoppingCartRequest_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__GetShoppingCartRequest_ * SOAP_FMAC6 soap_new_ns1__GetShoppingCartRequest_(struct soap *soap, int n)
{	return soap_instantiate_ns1__GetShoppingCartRequest_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GetShoppingCartRequest_(struct soap *soap, struct ns1__GetShoppingCartRequest_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__GetShoppingCartRequest_ * SOAP_FMAC4 soap_instantiate_ns1__GetShoppingCartRequest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetShoppingCartRequest_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetShoppingCartRequest_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__GetShoppingCartRequest_;
		if (size)
			*size = sizeof(struct ns1__GetShoppingCartRequest_);
	}
	else
	{	cp->ptr = (void*)new struct ns1__GetShoppingCartRequest_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetShoppingCartRequest_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetShoppingCartRequest_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetShoppingCartRequest_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetShoppingCartRequest_ %p -> %p\n", q, p));
	*(struct ns1__GetShoppingCartRequest_*)p = *(struct ns1__GetShoppingCartRequest_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetShoppingCartRequestResponse(struct soap *soap, struct ns1__GetShoppingCartRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ShoppingCart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetShoppingCartRequestResponse(struct soap *soap, const struct ns1__GetShoppingCartRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ShoppingCart(soap, &a->ShoppingCart);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetShoppingCartRequestResponse(struct soap *soap, const struct ns1__GetShoppingCartRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetShoppingCartRequestResponse);
	if (soap_out_ns1__GetShoppingCartRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetShoppingCartRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetShoppingCartRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetShoppingCartRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ShoppingCart(soap, "ShoppingCart", -1, &a->ShoppingCart, "ns1:ShoppingCart"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetShoppingCartRequestResponse * SOAP_FMAC4 soap_get_ns1__GetShoppingCartRequestResponse(struct soap *soap, struct ns1__GetShoppingCartRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetShoppingCartRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__GetShoppingCartRequestResponse * SOAP_FMAC4 soap_in_ns1__GetShoppingCartRequestResponse(struct soap *soap, const char *tag, struct ns1__GetShoppingCartRequestResponse *a, const char *type)
{
	size_t soap_flag_ShoppingCart = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetShoppingCartRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetShoppingCartRequestResponse, sizeof(struct ns1__GetShoppingCartRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetShoppingCartRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShoppingCart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ShoppingCart(soap, "ShoppingCart", &a->ShoppingCart, "ns1:ShoppingCart"))
				{	soap_flag_ShoppingCart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetShoppingCartRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetShoppingCartRequestResponse, 0, sizeof(struct ns1__GetShoppingCartRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__GetShoppingCartRequestResponse * SOAP_FMAC6 soap_new_ns1__GetShoppingCartRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__GetShoppingCartRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GetShoppingCartRequestResponse(struct soap *soap, struct ns1__GetShoppingCartRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__GetShoppingCartRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__GetShoppingCartRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetShoppingCartRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetShoppingCartRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__GetShoppingCartRequestResponse;
		if (size)
			*size = sizeof(struct ns1__GetShoppingCartRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__GetShoppingCartRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetShoppingCartRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetShoppingCartRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetShoppingCartRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetShoppingCartRequestResponse %p -> %p\n", q, p));
	*(struct ns1__GetShoppingCartRequestResponse*)p = *(struct ns1__GetShoppingCartRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SimilaritySearchRequest(struct soap *soap, struct ns1__SimilaritySearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SimilaritySearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SimilaritySearchRequest(struct soap *soap, const struct ns1__SimilaritySearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SimilarityRequest(soap, &a->SimilaritySearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SimilaritySearchRequest(struct soap *soap, const struct ns1__SimilaritySearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SimilaritySearchRequest);
	if (soap_out_ns1__SimilaritySearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SimilaritySearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__SimilaritySearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SimilaritySearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__SimilarityRequest(soap, "SimilaritySearchRequest", -1, &a->SimilaritySearchRequest, "ns1:SimilarityRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SimilaritySearchRequest * SOAP_FMAC4 soap_get_ns1__SimilaritySearchRequest(struct soap *soap, struct ns1__SimilaritySearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SimilaritySearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SimilaritySearchRequest * SOAP_FMAC4 soap_in_ns1__SimilaritySearchRequest(struct soap *soap, const char *tag, struct ns1__SimilaritySearchRequest *a, const char *type)
{
	size_t soap_flag_SimilaritySearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SimilaritySearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SimilaritySearchRequest, sizeof(struct ns1__SimilaritySearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SimilaritySearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SimilaritySearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SimilarityRequest(soap, "SimilaritySearchRequest", &a->SimilaritySearchRequest, "ns1:SimilarityRequest"))
				{	soap_flag_SimilaritySearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SimilaritySearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SimilaritySearchRequest, 0, sizeof(struct ns1__SimilaritySearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__SimilaritySearchRequest * SOAP_FMAC6 soap_new_ns1__SimilaritySearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__SimilaritySearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SimilaritySearchRequest(struct soap *soap, struct ns1__SimilaritySearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__SimilaritySearchRequest * SOAP_FMAC4 soap_instantiate_ns1__SimilaritySearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SimilaritySearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SimilaritySearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__SimilaritySearchRequest;
		if (size)
			*size = sizeof(struct ns1__SimilaritySearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__SimilaritySearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SimilaritySearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SimilaritySearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SimilaritySearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SimilaritySearchRequest %p -> %p\n", q, p));
	*(struct ns1__SimilaritySearchRequest*)p = *(struct ns1__SimilaritySearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SimilaritySearchRequestResponse(struct soap *soap, struct ns1__SimilaritySearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SimilaritySearchRequestResponse(struct soap *soap, const struct ns1__SimilaritySearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SimilaritySearchRequestResponse(struct soap *soap, const struct ns1__SimilaritySearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SimilaritySearchRequestResponse);
	if (soap_out_ns1__SimilaritySearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SimilaritySearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__SimilaritySearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SimilaritySearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SimilaritySearchRequestResponse * SOAP_FMAC4 soap_get_ns1__SimilaritySearchRequestResponse(struct soap *soap, struct ns1__SimilaritySearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SimilaritySearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SimilaritySearchRequestResponse * SOAP_FMAC4 soap_in_ns1__SimilaritySearchRequestResponse(struct soap *soap, const char *tag, struct ns1__SimilaritySearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SimilaritySearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SimilaritySearchRequestResponse, sizeof(struct ns1__SimilaritySearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SimilaritySearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SimilaritySearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SimilaritySearchRequestResponse, 0, sizeof(struct ns1__SimilaritySearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__SimilaritySearchRequestResponse * SOAP_FMAC6 soap_new_ns1__SimilaritySearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__SimilaritySearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SimilaritySearchRequestResponse(struct soap *soap, struct ns1__SimilaritySearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__SimilaritySearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__SimilaritySearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SimilaritySearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SimilaritySearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__SimilaritySearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__SimilaritySearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__SimilaritySearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SimilaritySearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SimilaritySearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SimilaritySearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SimilaritySearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__SimilaritySearchRequestResponse*)p = *(struct ns1__SimilaritySearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MarketplaceSearchRequest(struct soap *soap, struct ns1__MarketplaceSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MarketplaceSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__MarketplaceSearchRequest(struct soap *soap, const struct ns1__MarketplaceSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MarketplaceRequest(soap, &a->MarketplaceSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MarketplaceSearchRequest(struct soap *soap, const struct ns1__MarketplaceSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MarketplaceSearchRequest);
	if (soap_out_ns1__MarketplaceSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketplaceSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__MarketplaceSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketplaceSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__MarketplaceRequest(soap, "MarketplaceSearchRequest", -1, &a->MarketplaceSearchRequest, "ns1:MarketplaceRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__MarketplaceSearchRequest * SOAP_FMAC4 soap_get_ns1__MarketplaceSearchRequest(struct soap *soap, struct ns1__MarketplaceSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketplaceSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__MarketplaceSearchRequest * SOAP_FMAC4 soap_in_ns1__MarketplaceSearchRequest(struct soap *soap, const char *tag, struct ns1__MarketplaceSearchRequest *a, const char *type)
{
	size_t soap_flag_MarketplaceSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__MarketplaceSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketplaceSearchRequest, sizeof(struct ns1__MarketplaceSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__MarketplaceSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MarketplaceSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MarketplaceRequest(soap, "MarketplaceSearchRequest", &a->MarketplaceSearchRequest, "ns1:MarketplaceRequest"))
				{	soap_flag_MarketplaceSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__MarketplaceSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketplaceSearchRequest, 0, sizeof(struct ns1__MarketplaceSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__MarketplaceSearchRequest * SOAP_FMAC6 soap_new_ns1__MarketplaceSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__MarketplaceSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MarketplaceSearchRequest(struct soap *soap, struct ns1__MarketplaceSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__MarketplaceSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__MarketplaceSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MarketplaceSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MarketplaceSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__MarketplaceSearchRequest;
		if (size)
			*size = sizeof(struct ns1__MarketplaceSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__MarketplaceSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__MarketplaceSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__MarketplaceSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MarketplaceSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__MarketplaceSearchRequest %p -> %p\n", q, p));
	*(struct ns1__MarketplaceSearchRequest*)p = *(struct ns1__MarketplaceSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MarketplaceSearchRequestResponse(struct soap *soap, struct ns1__MarketplaceSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__MarketplaceSearchRequestResponse(struct soap *soap, const struct ns1__MarketplaceSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MarketplaceSearch(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MarketplaceSearchRequestResponse(struct soap *soap, const struct ns1__MarketplaceSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MarketplaceSearchRequestResponse);
	if (soap_out_ns1__MarketplaceSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketplaceSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__MarketplaceSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketplaceSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__MarketplaceSearch(soap, "return", -1, &a->return_, "ns1:MarketplaceSearch"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__MarketplaceSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__MarketplaceSearchRequestResponse(struct soap *soap, struct ns1__MarketplaceSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketplaceSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__MarketplaceSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__MarketplaceSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__MarketplaceSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__MarketplaceSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketplaceSearchRequestResponse, sizeof(struct ns1__MarketplaceSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__MarketplaceSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MarketplaceSearch(soap, "return", &a->return_, "ns1:MarketplaceSearch"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__MarketplaceSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketplaceSearchRequestResponse, 0, sizeof(struct ns1__MarketplaceSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__MarketplaceSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__MarketplaceSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__MarketplaceSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MarketplaceSearchRequestResponse(struct soap *soap, struct ns1__MarketplaceSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__MarketplaceSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__MarketplaceSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MarketplaceSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MarketplaceSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__MarketplaceSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__MarketplaceSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__MarketplaceSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__MarketplaceSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__MarketplaceSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MarketplaceSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__MarketplaceSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__MarketplaceSearchRequestResponse*)p = *(struct ns1__MarketplaceSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SellerSearchRequest(struct soap *soap, struct ns1__SellerSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SellerSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SellerSearchRequest(struct soap *soap, const struct ns1__SellerSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SellerRequest(soap, &a->SellerSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SellerSearchRequest(struct soap *soap, const struct ns1__SellerSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SellerSearchRequest);
	if (soap_out_ns1__SellerSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__SellerSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__SellerRequest(soap, "SellerSearchRequest", -1, &a->SellerSearchRequest, "ns1:SellerRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SellerSearchRequest * SOAP_FMAC4 soap_get_ns1__SellerSearchRequest(struct soap *soap, struct ns1__SellerSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SellerSearchRequest * SOAP_FMAC4 soap_in_ns1__SellerSearchRequest(struct soap *soap, const char *tag, struct ns1__SellerSearchRequest *a, const char *type)
{
	size_t soap_flag_SellerSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SellerSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerSearchRequest, sizeof(struct ns1__SellerSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SellerSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellerSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SellerRequest(soap, "SellerSearchRequest", &a->SellerSearchRequest, "ns1:SellerRequest"))
				{	soap_flag_SellerSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SellerSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerSearchRequest, 0, sizeof(struct ns1__SellerSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__SellerSearchRequest * SOAP_FMAC6 soap_new_ns1__SellerSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerSearchRequest(struct soap *soap, struct ns1__SellerSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__SellerSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__SellerSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__SellerSearchRequest;
		if (size)
			*size = sizeof(struct ns1__SellerSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__SellerSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SellerSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SellerSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SellerSearchRequest %p -> %p\n", q, p));
	*(struct ns1__SellerSearchRequest*)p = *(struct ns1__SellerSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SellerSearchRequestResponse(struct soap *soap, struct ns1__SellerSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SellerSearchRequestResponse(struct soap *soap, const struct ns1__SellerSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SellerSearch(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SellerSearchRequestResponse(struct soap *soap, const struct ns1__SellerSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SellerSearchRequestResponse);
	if (soap_out_ns1__SellerSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__SellerSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__SellerSearch(soap, "return", -1, &a->return_, "ns1:SellerSearch"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SellerSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__SellerSearchRequestResponse(struct soap *soap, struct ns1__SellerSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SellerSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__SellerSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__SellerSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SellerSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerSearchRequestResponse, sizeof(struct ns1__SellerSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SellerSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SellerSearch(soap, "return", &a->return_, "ns1:SellerSearch"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SellerSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerSearchRequestResponse, 0, sizeof(struct ns1__SellerSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__SellerSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__SellerSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerSearchRequestResponse(struct soap *soap, struct ns1__SellerSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__SellerSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__SellerSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__SellerSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__SellerSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__SellerSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SellerSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SellerSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SellerSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__SellerSearchRequestResponse*)p = *(struct ns1__SellerSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SellerProfileSearchRequest(struct soap *soap, struct ns1__SellerProfileSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SellerProfileSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SellerProfileSearchRequest(struct soap *soap, const struct ns1__SellerProfileSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SellerProfileRequest(soap, &a->SellerProfileSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SellerProfileSearchRequest(struct soap *soap, const struct ns1__SellerProfileSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SellerProfileSearchRequest);
	if (soap_out_ns1__SellerProfileSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerProfileSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__SellerProfileSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerProfileSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__SellerProfileRequest(soap, "SellerProfileSearchRequest", -1, &a->SellerProfileSearchRequest, "ns1:SellerProfileRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SellerProfileSearchRequest * SOAP_FMAC4 soap_get_ns1__SellerProfileSearchRequest(struct soap *soap, struct ns1__SellerProfileSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerProfileSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SellerProfileSearchRequest * SOAP_FMAC4 soap_in_ns1__SellerProfileSearchRequest(struct soap *soap, const char *tag, struct ns1__SellerProfileSearchRequest *a, const char *type)
{
	size_t soap_flag_SellerProfileSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SellerProfileSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerProfileSearchRequest, sizeof(struct ns1__SellerProfileSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SellerProfileSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellerProfileSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SellerProfileRequest(soap, "SellerProfileSearchRequest", &a->SellerProfileSearchRequest, "ns1:SellerProfileRequest"))
				{	soap_flag_SellerProfileSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SellerProfileSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerProfileSearchRequest, 0, sizeof(struct ns1__SellerProfileSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__SellerProfileSearchRequest * SOAP_FMAC6 soap_new_ns1__SellerProfileSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerProfileSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerProfileSearchRequest(struct soap *soap, struct ns1__SellerProfileSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__SellerProfileSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__SellerProfileSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerProfileSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerProfileSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__SellerProfileSearchRequest;
		if (size)
			*size = sizeof(struct ns1__SellerProfileSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__SellerProfileSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SellerProfileSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SellerProfileSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerProfileSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SellerProfileSearchRequest %p -> %p\n", q, p));
	*(struct ns1__SellerProfileSearchRequest*)p = *(struct ns1__SellerProfileSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SellerProfileSearchRequestResponse(struct soap *soap, struct ns1__SellerProfileSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SellerProfileSearchRequestResponse(struct soap *soap, const struct ns1__SellerProfileSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SellerProfile(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SellerProfileSearchRequestResponse(struct soap *soap, const struct ns1__SellerProfileSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SellerProfileSearchRequestResponse);
	if (soap_out_ns1__SellerProfileSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellerProfileSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__SellerProfileSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellerProfileSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__SellerProfile(soap, "return", -1, &a->return_, "ns1:SellerProfile"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SellerProfileSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__SellerProfileSearchRequestResponse(struct soap *soap, struct ns1__SellerProfileSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellerProfileSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SellerProfileSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__SellerProfileSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__SellerProfileSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SellerProfileSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellerProfileSearchRequestResponse, sizeof(struct ns1__SellerProfileSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SellerProfileSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SellerProfile(soap, "return", &a->return_, "ns1:SellerProfile"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SellerProfileSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellerProfileSearchRequestResponse, 0, sizeof(struct ns1__SellerProfileSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__SellerProfileSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__SellerProfileSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__SellerProfileSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SellerProfileSearchRequestResponse(struct soap *soap, struct ns1__SellerProfileSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__SellerProfileSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__SellerProfileSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellerProfileSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellerProfileSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__SellerProfileSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__SellerProfileSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__SellerProfileSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SellerProfileSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SellerProfileSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellerProfileSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SellerProfileSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__SellerProfileSearchRequestResponse*)p = *(struct ns1__SellerProfileSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WishlistSearchRequest(struct soap *soap, struct ns1__WishlistSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WishlistSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__WishlistSearchRequest(struct soap *soap, const struct ns1__WishlistSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__WishlistRequest(soap, &a->WishlistSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WishlistSearchRequest(struct soap *soap, const struct ns1__WishlistSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__WishlistSearchRequest);
	if (soap_out_ns1__WishlistSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WishlistSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__WishlistSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WishlistSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__WishlistRequest(soap, "WishlistSearchRequest", -1, &a->WishlistSearchRequest, "ns1:WishlistRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__WishlistSearchRequest * SOAP_FMAC4 soap_get_ns1__WishlistSearchRequest(struct soap *soap, struct ns1__WishlistSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WishlistSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__WishlistSearchRequest * SOAP_FMAC4 soap_in_ns1__WishlistSearchRequest(struct soap *soap, const char *tag, struct ns1__WishlistSearchRequest *a, const char *type)
{
	size_t soap_flag_WishlistSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__WishlistSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WishlistSearchRequest, sizeof(struct ns1__WishlistSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__WishlistSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WishlistSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WishlistRequest(soap, "WishlistSearchRequest", &a->WishlistSearchRequest, "ns1:WishlistRequest"))
				{	soap_flag_WishlistSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__WishlistSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WishlistSearchRequest, 0, sizeof(struct ns1__WishlistSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__WishlistSearchRequest * SOAP_FMAC6 soap_new_ns1__WishlistSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__WishlistSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__WishlistSearchRequest(struct soap *soap, struct ns1__WishlistSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__WishlistSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__WishlistSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WishlistSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__WishlistSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__WishlistSearchRequest;
		if (size)
			*size = sizeof(struct ns1__WishlistSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__WishlistSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__WishlistSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__WishlistSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__WishlistSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__WishlistSearchRequest %p -> %p\n", q, p));
	*(struct ns1__WishlistSearchRequest*)p = *(struct ns1__WishlistSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WishlistSearchRequestResponse(struct soap *soap, struct ns1__WishlistSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__WishlistSearchRequestResponse(struct soap *soap, const struct ns1__WishlistSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WishlistSearchRequestResponse(struct soap *soap, const struct ns1__WishlistSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__WishlistSearchRequestResponse);
	if (soap_out_ns1__WishlistSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WishlistSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__WishlistSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WishlistSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__WishlistSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__WishlistSearchRequestResponse(struct soap *soap, struct ns1__WishlistSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WishlistSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__WishlistSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__WishlistSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__WishlistSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__WishlistSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WishlistSearchRequestResponse, sizeof(struct ns1__WishlistSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__WishlistSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__WishlistSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WishlistSearchRequestResponse, 0, sizeof(struct ns1__WishlistSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__WishlistSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__WishlistSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__WishlistSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__WishlistSearchRequestResponse(struct soap *soap, struct ns1__WishlistSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__WishlistSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__WishlistSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WishlistSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__WishlistSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__WishlistSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__WishlistSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__WishlistSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__WishlistSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__WishlistSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__WishlistSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__WishlistSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__WishlistSearchRequestResponse*)p = *(struct ns1__WishlistSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ListManiaSearchRequest(struct soap *soap, struct ns1__ListManiaSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ListManiaSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ListManiaSearchRequest(struct soap *soap, const struct ns1__ListManiaSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ListManiaRequest(soap, &a->ListManiaSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ListManiaSearchRequest(struct soap *soap, const struct ns1__ListManiaSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ListManiaSearchRequest);
	if (soap_out_ns1__ListManiaSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListManiaSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__ListManiaSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListManiaSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__ListManiaRequest(soap, "ListManiaSearchRequest", -1, &a->ListManiaSearchRequest, "ns1:ListManiaRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ListManiaSearchRequest * SOAP_FMAC4 soap_get_ns1__ListManiaSearchRequest(struct soap *soap, struct ns1__ListManiaSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListManiaSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ListManiaSearchRequest * SOAP_FMAC4 soap_in_ns1__ListManiaSearchRequest(struct soap *soap, const char *tag, struct ns1__ListManiaSearchRequest *a, const char *type)
{
	size_t soap_flag_ListManiaSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ListManiaSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListManiaSearchRequest, sizeof(struct ns1__ListManiaSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ListManiaSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListManiaSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ListManiaRequest(soap, "ListManiaSearchRequest", &a->ListManiaSearchRequest, "ns1:ListManiaRequest"))
				{	soap_flag_ListManiaSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ListManiaSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListManiaSearchRequest, 0, sizeof(struct ns1__ListManiaSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ListManiaSearchRequest * SOAP_FMAC6 soap_new_ns1__ListManiaSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ListManiaSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ListManiaSearchRequest(struct soap *soap, struct ns1__ListManiaSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ListManiaSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__ListManiaSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListManiaSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListManiaSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ListManiaSearchRequest;
		if (size)
			*size = sizeof(struct ns1__ListManiaSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ListManiaSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ListManiaSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ListManiaSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListManiaSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ListManiaSearchRequest %p -> %p\n", q, p));
	*(struct ns1__ListManiaSearchRequest*)p = *(struct ns1__ListManiaSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ListManiaSearchRequestResponse(struct soap *soap, struct ns1__ListManiaSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ListManiaSearchRequestResponse(struct soap *soap, const struct ns1__ListManiaSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ListManiaSearchRequestResponse(struct soap *soap, const struct ns1__ListManiaSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ListManiaSearchRequestResponse);
	if (soap_out_ns1__ListManiaSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListManiaSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__ListManiaSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListManiaSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ListManiaSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__ListManiaSearchRequestResponse(struct soap *soap, struct ns1__ListManiaSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListManiaSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ListManiaSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__ListManiaSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__ListManiaSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ListManiaSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListManiaSearchRequestResponse, sizeof(struct ns1__ListManiaSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ListManiaSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ListManiaSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListManiaSearchRequestResponse, 0, sizeof(struct ns1__ListManiaSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ListManiaSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__ListManiaSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__ListManiaSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ListManiaSearchRequestResponse(struct soap *soap, struct ns1__ListManiaSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ListManiaSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__ListManiaSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListManiaSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListManiaSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ListManiaSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__ListManiaSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ListManiaSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ListManiaSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ListManiaSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListManiaSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ListManiaSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__ListManiaSearchRequestResponse*)p = *(struct ns1__ListManiaSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ExchangeSearchRequest(struct soap *soap, struct ns1__ExchangeSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ExchangeSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExchangeSearchRequest(struct soap *soap, const struct ns1__ExchangeSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ExchangeRequest(soap, &a->ExchangeSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExchangeSearchRequest(struct soap *soap, const struct ns1__ExchangeSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ExchangeSearchRequest);
	if (soap_out_ns1__ExchangeSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExchangeSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__ExchangeSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExchangeSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__ExchangeRequest(soap, "ExchangeSearchRequest", -1, &a->ExchangeSearchRequest, "ns1:ExchangeRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ExchangeSearchRequest * SOAP_FMAC4 soap_get_ns1__ExchangeSearchRequest(struct soap *soap, struct ns1__ExchangeSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExchangeSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ExchangeSearchRequest * SOAP_FMAC4 soap_in_ns1__ExchangeSearchRequest(struct soap *soap, const char *tag, struct ns1__ExchangeSearchRequest *a, const char *type)
{
	size_t soap_flag_ExchangeSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ExchangeSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExchangeSearchRequest, sizeof(struct ns1__ExchangeSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ExchangeSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ExchangeRequest(soap, "ExchangeSearchRequest", &a->ExchangeSearchRequest, "ns1:ExchangeRequest"))
				{	soap_flag_ExchangeSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ExchangeSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExchangeSearchRequest, 0, sizeof(struct ns1__ExchangeSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ExchangeSearchRequest * SOAP_FMAC6 soap_new_ns1__ExchangeSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ExchangeSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ExchangeSearchRequest(struct soap *soap, struct ns1__ExchangeSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ExchangeSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__ExchangeSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExchangeSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ExchangeSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ExchangeSearchRequest;
		if (size)
			*size = sizeof(struct ns1__ExchangeSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ExchangeSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ExchangeSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ExchangeSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ExchangeSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ExchangeSearchRequest %p -> %p\n", q, p));
	*(struct ns1__ExchangeSearchRequest*)p = *(struct ns1__ExchangeSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ExchangeSearchRequestResponse(struct soap *soap, struct ns1__ExchangeSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExchangeSearchRequestResponse(struct soap *soap, const struct ns1__ExchangeSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ListingProductDetails(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExchangeSearchRequestResponse(struct soap *soap, const struct ns1__ExchangeSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ExchangeSearchRequestResponse);
	if (soap_out_ns1__ExchangeSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExchangeSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__ExchangeSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExchangeSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ListingProductDetails(soap, "return", -1, &a->return_, "ns1:ListingProductDetails"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ExchangeSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__ExchangeSearchRequestResponse(struct soap *soap, struct ns1__ExchangeSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExchangeSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ExchangeSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__ExchangeSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__ExchangeSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ExchangeSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExchangeSearchRequestResponse, sizeof(struct ns1__ExchangeSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ExchangeSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ListingProductDetails(soap, "return", &a->return_, "ns1:ListingProductDetails"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ExchangeSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExchangeSearchRequestResponse, 0, sizeof(struct ns1__ExchangeSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ExchangeSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__ExchangeSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__ExchangeSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ExchangeSearchRequestResponse(struct soap *soap, struct ns1__ExchangeSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ExchangeSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__ExchangeSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExchangeSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ExchangeSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ExchangeSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__ExchangeSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ExchangeSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ExchangeSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ExchangeSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ExchangeSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ExchangeSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__ExchangeSearchRequestResponse*)p = *(struct ns1__ExchangeSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DirectorSearchRequest(struct soap *soap, struct ns1__DirectorSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DirectorSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DirectorSearchRequest(struct soap *soap, const struct ns1__DirectorSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__DirectorRequest(soap, &a->DirectorSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DirectorSearchRequest(struct soap *soap, const struct ns1__DirectorSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DirectorSearchRequest);
	if (soap_out_ns1__DirectorSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DirectorSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__DirectorSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DirectorSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__DirectorRequest(soap, "DirectorSearchRequest", -1, &a->DirectorSearchRequest, "ns1:DirectorRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DirectorSearchRequest * SOAP_FMAC4 soap_get_ns1__DirectorSearchRequest(struct soap *soap, struct ns1__DirectorSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DirectorSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__DirectorSearchRequest * SOAP_FMAC4 soap_in_ns1__DirectorSearchRequest(struct soap *soap, const char *tag, struct ns1__DirectorSearchRequest *a, const char *type)
{
	size_t soap_flag_DirectorSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DirectorSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DirectorSearchRequest, sizeof(struct ns1__DirectorSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DirectorSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DirectorSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DirectorRequest(soap, "DirectorSearchRequest", &a->DirectorSearchRequest, "ns1:DirectorRequest"))
				{	soap_flag_DirectorSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DirectorSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DirectorSearchRequest, 0, sizeof(struct ns1__DirectorSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__DirectorSearchRequest * SOAP_FMAC6 soap_new_ns1__DirectorSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__DirectorSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DirectorSearchRequest(struct soap *soap, struct ns1__DirectorSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__DirectorSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__DirectorSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DirectorSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DirectorSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__DirectorSearchRequest;
		if (size)
			*size = sizeof(struct ns1__DirectorSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__DirectorSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__DirectorSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__DirectorSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DirectorSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DirectorSearchRequest %p -> %p\n", q, p));
	*(struct ns1__DirectorSearchRequest*)p = *(struct ns1__DirectorSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DirectorSearchRequestResponse(struct soap *soap, struct ns1__DirectorSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DirectorSearchRequestResponse(struct soap *soap, const struct ns1__DirectorSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DirectorSearchRequestResponse(struct soap *soap, const struct ns1__DirectorSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DirectorSearchRequestResponse);
	if (soap_out_ns1__DirectorSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DirectorSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__DirectorSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DirectorSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DirectorSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__DirectorSearchRequestResponse(struct soap *soap, struct ns1__DirectorSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DirectorSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__DirectorSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__DirectorSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__DirectorSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DirectorSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DirectorSearchRequestResponse, sizeof(struct ns1__DirectorSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DirectorSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DirectorSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DirectorSearchRequestResponse, 0, sizeof(struct ns1__DirectorSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__DirectorSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__DirectorSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__DirectorSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DirectorSearchRequestResponse(struct soap *soap, struct ns1__DirectorSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__DirectorSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__DirectorSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DirectorSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DirectorSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__DirectorSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__DirectorSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__DirectorSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__DirectorSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__DirectorSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DirectorSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DirectorSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__DirectorSearchRequestResponse*)p = *(struct ns1__DirectorSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ManufacturerSearchRequest(struct soap *soap, struct ns1__ManufacturerSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ManufacturerSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ManufacturerSearchRequest(struct soap *soap, const struct ns1__ManufacturerSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ManufacturerRequest(soap, &a->ManufacturerSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ManufacturerSearchRequest(struct soap *soap, const struct ns1__ManufacturerSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ManufacturerSearchRequest);
	if (soap_out_ns1__ManufacturerSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ManufacturerSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__ManufacturerSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ManufacturerSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__ManufacturerRequest(soap, "ManufacturerSearchRequest", -1, &a->ManufacturerSearchRequest, "ns1:ManufacturerRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ManufacturerSearchRequest * SOAP_FMAC4 soap_get_ns1__ManufacturerSearchRequest(struct soap *soap, struct ns1__ManufacturerSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ManufacturerSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ManufacturerSearchRequest * SOAP_FMAC4 soap_in_ns1__ManufacturerSearchRequest(struct soap *soap, const char *tag, struct ns1__ManufacturerSearchRequest *a, const char *type)
{
	size_t soap_flag_ManufacturerSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ManufacturerSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ManufacturerSearchRequest, sizeof(struct ns1__ManufacturerSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ManufacturerSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ManufacturerSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ManufacturerRequest(soap, "ManufacturerSearchRequest", &a->ManufacturerSearchRequest, "ns1:ManufacturerRequest"))
				{	soap_flag_ManufacturerSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ManufacturerSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ManufacturerSearchRequest, 0, sizeof(struct ns1__ManufacturerSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ManufacturerSearchRequest * SOAP_FMAC6 soap_new_ns1__ManufacturerSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ManufacturerSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ManufacturerSearchRequest(struct soap *soap, struct ns1__ManufacturerSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ManufacturerSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__ManufacturerSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ManufacturerSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ManufacturerSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ManufacturerSearchRequest;
		if (size)
			*size = sizeof(struct ns1__ManufacturerSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ManufacturerSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ManufacturerSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ManufacturerSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ManufacturerSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ManufacturerSearchRequest %p -> %p\n", q, p));
	*(struct ns1__ManufacturerSearchRequest*)p = *(struct ns1__ManufacturerSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ManufacturerSearchRequestResponse(struct soap *soap, struct ns1__ManufacturerSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ManufacturerSearchRequestResponse(struct soap *soap, const struct ns1__ManufacturerSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ManufacturerSearchRequestResponse(struct soap *soap, const struct ns1__ManufacturerSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ManufacturerSearchRequestResponse);
	if (soap_out_ns1__ManufacturerSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ManufacturerSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__ManufacturerSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ManufacturerSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ManufacturerSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__ManufacturerSearchRequestResponse(struct soap *soap, struct ns1__ManufacturerSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ManufacturerSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ManufacturerSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__ManufacturerSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__ManufacturerSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ManufacturerSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ManufacturerSearchRequestResponse, sizeof(struct ns1__ManufacturerSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ManufacturerSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ManufacturerSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ManufacturerSearchRequestResponse, 0, sizeof(struct ns1__ManufacturerSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ManufacturerSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__ManufacturerSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__ManufacturerSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ManufacturerSearchRequestResponse(struct soap *soap, struct ns1__ManufacturerSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ManufacturerSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__ManufacturerSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ManufacturerSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ManufacturerSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ManufacturerSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__ManufacturerSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ManufacturerSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ManufacturerSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ManufacturerSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ManufacturerSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ManufacturerSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__ManufacturerSearchRequestResponse*)p = *(struct ns1__ManufacturerSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ActorSearchRequest(struct soap *soap, struct ns1__ActorSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActorSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ActorSearchRequest(struct soap *soap, const struct ns1__ActorSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ActorRequest(soap, &a->ActorSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ActorSearchRequest(struct soap *soap, const struct ns1__ActorSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ActorSearchRequest);
	if (soap_out_ns1__ActorSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActorSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__ActorSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ActorSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__ActorRequest(soap, "ActorSearchRequest", -1, &a->ActorSearchRequest, "ns1:ActorRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ActorSearchRequest * SOAP_FMAC4 soap_get_ns1__ActorSearchRequest(struct soap *soap, struct ns1__ActorSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActorSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ActorSearchRequest * SOAP_FMAC4 soap_in_ns1__ActorSearchRequest(struct soap *soap, const char *tag, struct ns1__ActorSearchRequest *a, const char *type)
{
	size_t soap_flag_ActorSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ActorSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActorSearchRequest, sizeof(struct ns1__ActorSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ActorSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActorSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ActorRequest(soap, "ActorSearchRequest", &a->ActorSearchRequest, "ns1:ActorRequest"))
				{	soap_flag_ActorSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ActorSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActorSearchRequest, 0, sizeof(struct ns1__ActorSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ActorSearchRequest * SOAP_FMAC6 soap_new_ns1__ActorSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ActorSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ActorSearchRequest(struct soap *soap, struct ns1__ActorSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ActorSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__ActorSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ActorSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ActorSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ActorSearchRequest;
		if (size)
			*size = sizeof(struct ns1__ActorSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ActorSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ActorSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ActorSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ActorSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ActorSearchRequest %p -> %p\n", q, p));
	*(struct ns1__ActorSearchRequest*)p = *(struct ns1__ActorSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ActorSearchRequestResponse(struct soap *soap, struct ns1__ActorSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ActorSearchRequestResponse(struct soap *soap, const struct ns1__ActorSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ActorSearchRequestResponse(struct soap *soap, const struct ns1__ActorSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ActorSearchRequestResponse);
	if (soap_out_ns1__ActorSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActorSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__ActorSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ActorSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ActorSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__ActorSearchRequestResponse(struct soap *soap, struct ns1__ActorSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActorSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ActorSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__ActorSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__ActorSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ActorSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActorSearchRequestResponse, sizeof(struct ns1__ActorSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ActorSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ActorSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActorSearchRequestResponse, 0, sizeof(struct ns1__ActorSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ActorSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__ActorSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__ActorSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ActorSearchRequestResponse(struct soap *soap, struct ns1__ActorSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ActorSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__ActorSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ActorSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ActorSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ActorSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__ActorSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ActorSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ActorSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ActorSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ActorSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ActorSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__ActorSearchRequestResponse*)p = *(struct ns1__ActorSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArtistSearchRequest(struct soap *soap, struct ns1__ArtistSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ArtistSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArtistSearchRequest(struct soap *soap, const struct ns1__ArtistSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArtistRequest(soap, &a->ArtistSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArtistSearchRequest(struct soap *soap, const struct ns1__ArtistSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArtistSearchRequest);
	if (soap_out_ns1__ArtistSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArtistSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__ArtistSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArtistSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__ArtistRequest(soap, "ArtistSearchRequest", -1, &a->ArtistSearchRequest, "ns1:ArtistRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArtistSearchRequest * SOAP_FMAC4 soap_get_ns1__ArtistSearchRequest(struct soap *soap, struct ns1__ArtistSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArtistSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ArtistSearchRequest * SOAP_FMAC4 soap_in_ns1__ArtistSearchRequest(struct soap *soap, const char *tag, struct ns1__ArtistSearchRequest *a, const char *type)
{
	size_t soap_flag_ArtistSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArtistSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArtistSearchRequest, sizeof(struct ns1__ArtistSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArtistSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ArtistSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArtistRequest(soap, "ArtistSearchRequest", &a->ArtistSearchRequest, "ns1:ArtistRequest"))
				{	soap_flag_ArtistSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArtistSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArtistSearchRequest, 0, sizeof(struct ns1__ArtistSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ArtistSearchRequest * SOAP_FMAC6 soap_new_ns1__ArtistSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArtistSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArtistSearchRequest(struct soap *soap, struct ns1__ArtistSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ArtistSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__ArtistSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArtistSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArtistSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ArtistSearchRequest;
		if (size)
			*size = sizeof(struct ns1__ArtistSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ArtistSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ArtistSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ArtistSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArtistSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ArtistSearchRequest %p -> %p\n", q, p));
	*(struct ns1__ArtistSearchRequest*)p = *(struct ns1__ArtistSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArtistSearchRequestResponse(struct soap *soap, struct ns1__ArtistSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArtistSearchRequestResponse(struct soap *soap, const struct ns1__ArtistSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArtistSearchRequestResponse(struct soap *soap, const struct ns1__ArtistSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArtistSearchRequestResponse);
	if (soap_out_ns1__ArtistSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArtistSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__ArtistSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArtistSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArtistSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__ArtistSearchRequestResponse(struct soap *soap, struct ns1__ArtistSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArtistSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ArtistSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__ArtistSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__ArtistSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArtistSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArtistSearchRequestResponse, sizeof(struct ns1__ArtistSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArtistSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArtistSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArtistSearchRequestResponse, 0, sizeof(struct ns1__ArtistSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__ArtistSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__ArtistSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArtistSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArtistSearchRequestResponse(struct soap *soap, struct ns1__ArtistSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__ArtistSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__ArtistSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArtistSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArtistSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__ArtistSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__ArtistSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__ArtistSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ArtistSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ArtistSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArtistSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ArtistSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__ArtistSearchRequestResponse*)p = *(struct ns1__ArtistSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AuthorSearchRequest(struct soap *soap, struct ns1__AuthorSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AuthorSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AuthorSearchRequest(struct soap *soap, const struct ns1__AuthorSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AuthorRequest(soap, &a->AuthorSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AuthorSearchRequest(struct soap *soap, const struct ns1__AuthorSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AuthorSearchRequest);
	if (soap_out_ns1__AuthorSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuthorSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__AuthorSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuthorSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__AuthorRequest(soap, "AuthorSearchRequest", -1, &a->AuthorSearchRequest, "ns1:AuthorRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AuthorSearchRequest * SOAP_FMAC4 soap_get_ns1__AuthorSearchRequest(struct soap *soap, struct ns1__AuthorSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuthorSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AuthorSearchRequest * SOAP_FMAC4 soap_in_ns1__AuthorSearchRequest(struct soap *soap, const char *tag, struct ns1__AuthorSearchRequest *a, const char *type)
{
	size_t soap_flag_AuthorSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AuthorSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuthorSearchRequest, sizeof(struct ns1__AuthorSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AuthorSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuthorSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuthorRequest(soap, "AuthorSearchRequest", &a->AuthorSearchRequest, "ns1:AuthorRequest"))
				{	soap_flag_AuthorSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AuthorSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuthorSearchRequest, 0, sizeof(struct ns1__AuthorSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__AuthorSearchRequest * SOAP_FMAC6 soap_new_ns1__AuthorSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__AuthorSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AuthorSearchRequest(struct soap *soap, struct ns1__AuthorSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__AuthorSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__AuthorSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AuthorSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AuthorSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__AuthorSearchRequest;
		if (size)
			*size = sizeof(struct ns1__AuthorSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__AuthorSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__AuthorSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__AuthorSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AuthorSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__AuthorSearchRequest %p -> %p\n", q, p));
	*(struct ns1__AuthorSearchRequest*)p = *(struct ns1__AuthorSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AuthorSearchRequestResponse(struct soap *soap, struct ns1__AuthorSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AuthorSearchRequestResponse(struct soap *soap, const struct ns1__AuthorSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AuthorSearchRequestResponse(struct soap *soap, const struct ns1__AuthorSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AuthorSearchRequestResponse);
	if (soap_out_ns1__AuthorSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuthorSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__AuthorSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuthorSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AuthorSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__AuthorSearchRequestResponse(struct soap *soap, struct ns1__AuthorSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuthorSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AuthorSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__AuthorSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__AuthorSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AuthorSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuthorSearchRequestResponse, sizeof(struct ns1__AuthorSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AuthorSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AuthorSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuthorSearchRequestResponse, 0, sizeof(struct ns1__AuthorSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__AuthorSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__AuthorSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__AuthorSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AuthorSearchRequestResponse(struct soap *soap, struct ns1__AuthorSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__AuthorSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__AuthorSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AuthorSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AuthorSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__AuthorSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__AuthorSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__AuthorSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__AuthorSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__AuthorSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AuthorSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__AuthorSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__AuthorSearchRequestResponse*)p = *(struct ns1__AuthorSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpcSearchRequest(struct soap *soap, struct ns1__UpcSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->UpcSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpcSearchRequest(struct soap *soap, const struct ns1__UpcSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UpcRequest(soap, &a->UpcSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpcSearchRequest(struct soap *soap, const struct ns1__UpcSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__UpcSearchRequest);
	if (soap_out_ns1__UpcSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpcSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__UpcSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpcSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__UpcRequest(soap, "UpcSearchRequest", -1, &a->UpcSearchRequest, "ns1:UpcRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpcSearchRequest * SOAP_FMAC4 soap_get_ns1__UpcSearchRequest(struct soap *soap, struct ns1__UpcSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpcSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__UpcSearchRequest * SOAP_FMAC4 soap_in_ns1__UpcSearchRequest(struct soap *soap, const char *tag, struct ns1__UpcSearchRequest *a, const char *type)
{
	size_t soap_flag_UpcSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpcSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpcSearchRequest, sizeof(struct ns1__UpcSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpcSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpcSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UpcRequest(soap, "UpcSearchRequest", &a->UpcSearchRequest, "ns1:UpcRequest"))
				{	soap_flag_UpcSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpcSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpcSearchRequest, 0, sizeof(struct ns1__UpcSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__UpcSearchRequest * SOAP_FMAC6 soap_new_ns1__UpcSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__UpcSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UpcSearchRequest(struct soap *soap, struct ns1__UpcSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__UpcSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__UpcSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpcSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UpcSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__UpcSearchRequest;
		if (size)
			*size = sizeof(struct ns1__UpcSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__UpcSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__UpcSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__UpcSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UpcSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__UpcSearchRequest %p -> %p\n", q, p));
	*(struct ns1__UpcSearchRequest*)p = *(struct ns1__UpcSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpcSearchRequestResponse(struct soap *soap, struct ns1__UpcSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpcSearchRequestResponse(struct soap *soap, const struct ns1__UpcSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpcSearchRequestResponse(struct soap *soap, const struct ns1__UpcSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__UpcSearchRequestResponse);
	if (soap_out_ns1__UpcSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpcSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__UpcSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpcSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpcSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__UpcSearchRequestResponse(struct soap *soap, struct ns1__UpcSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpcSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__UpcSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__UpcSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__UpcSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpcSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpcSearchRequestResponse, sizeof(struct ns1__UpcSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpcSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpcSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpcSearchRequestResponse, 0, sizeof(struct ns1__UpcSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__UpcSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__UpcSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__UpcSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UpcSearchRequestResponse(struct soap *soap, struct ns1__UpcSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__UpcSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__UpcSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpcSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UpcSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__UpcSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__UpcSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__UpcSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__UpcSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__UpcSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UpcSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__UpcSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__UpcSearchRequestResponse*)p = *(struct ns1__UpcSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__BlendedSearchRequest(struct soap *soap, struct ns1__BlendedSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BlendedSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BlendedSearchRequest(struct soap *soap, const struct ns1__BlendedSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BlendedRequest(soap, &a->BlendedSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BlendedSearchRequest(struct soap *soap, const struct ns1__BlendedSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__BlendedSearchRequest);
	if (soap_out_ns1__BlendedSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BlendedSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__BlendedSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BlendedSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__BlendedRequest(soap, "BlendedSearchRequest", -1, &a->BlendedSearchRequest, "ns1:BlendedRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__BlendedSearchRequest * SOAP_FMAC4 soap_get_ns1__BlendedSearchRequest(struct soap *soap, struct ns1__BlendedSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BlendedSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__BlendedSearchRequest * SOAP_FMAC4 soap_in_ns1__BlendedSearchRequest(struct soap *soap, const char *tag, struct ns1__BlendedSearchRequest *a, const char *type)
{
	size_t soap_flag_BlendedSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__BlendedSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BlendedSearchRequest, sizeof(struct ns1__BlendedSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__BlendedSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BlendedSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BlendedRequest(soap, "BlendedSearchRequest", &a->BlendedSearchRequest, "ns1:BlendedRequest"))
				{	soap_flag_BlendedSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__BlendedSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BlendedSearchRequest, 0, sizeof(struct ns1__BlendedSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__BlendedSearchRequest * SOAP_FMAC6 soap_new_ns1__BlendedSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__BlendedSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BlendedSearchRequest(struct soap *soap, struct ns1__BlendedSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__BlendedSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__BlendedSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BlendedSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BlendedSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__BlendedSearchRequest;
		if (size)
			*size = sizeof(struct ns1__BlendedSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__BlendedSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__BlendedSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__BlendedSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BlendedSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__BlendedSearchRequest %p -> %p\n", q, p));
	*(struct ns1__BlendedSearchRequest*)p = *(struct ns1__BlendedSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__BlendedSearchRequestResponse(struct soap *soap, struct ns1__BlendedSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BlendedSearchRequestResponse(struct soap *soap, const struct ns1__BlendedSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToProductLineArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BlendedSearchRequestResponse(struct soap *soap, const struct ns1__BlendedSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__BlendedSearchRequestResponse);
	if (soap_out_ns1__BlendedSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BlendedSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__BlendedSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BlendedSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerToProductLineArray(soap, "return", -1, &a->return_, "ns1:ProductLine"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__BlendedSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__BlendedSearchRequestResponse(struct soap *soap, struct ns1__BlendedSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BlendedSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__BlendedSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__BlendedSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__BlendedSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__BlendedSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BlendedSearchRequestResponse, sizeof(struct ns1__BlendedSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__BlendedSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToProductLineArray(soap, "return", &a->return_, "ns1:ProductLine"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__BlendedSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BlendedSearchRequestResponse, 0, sizeof(struct ns1__BlendedSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__BlendedSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__BlendedSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__BlendedSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BlendedSearchRequestResponse(struct soap *soap, struct ns1__BlendedSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__BlendedSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__BlendedSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BlendedSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BlendedSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__BlendedSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__BlendedSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__BlendedSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__BlendedSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__BlendedSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BlendedSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__BlendedSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__BlendedSearchRequestResponse*)p = *(struct ns1__BlendedSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AsinSearchRequest(struct soap *soap, struct ns1__AsinSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AsinSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AsinSearchRequest(struct soap *soap, const struct ns1__AsinSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AsinRequest(soap, &a->AsinSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AsinSearchRequest(struct soap *soap, const struct ns1__AsinSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AsinSearchRequest);
	if (soap_out_ns1__AsinSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AsinSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__AsinSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AsinSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__AsinRequest(soap, "AsinSearchRequest", -1, &a->AsinSearchRequest, "ns1:AsinRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AsinSearchRequest * SOAP_FMAC4 soap_get_ns1__AsinSearchRequest(struct soap *soap, struct ns1__AsinSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AsinSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AsinSearchRequest * SOAP_FMAC4 soap_in_ns1__AsinSearchRequest(struct soap *soap, const char *tag, struct ns1__AsinSearchRequest *a, const char *type)
{
	size_t soap_flag_AsinSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AsinSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AsinSearchRequest, sizeof(struct ns1__AsinSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AsinSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AsinSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AsinRequest(soap, "AsinSearchRequest", &a->AsinSearchRequest, "ns1:AsinRequest"))
				{	soap_flag_AsinSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AsinSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AsinSearchRequest, 0, sizeof(struct ns1__AsinSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__AsinSearchRequest * SOAP_FMAC6 soap_new_ns1__AsinSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__AsinSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AsinSearchRequest(struct soap *soap, struct ns1__AsinSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__AsinSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__AsinSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AsinSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AsinSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__AsinSearchRequest;
		if (size)
			*size = sizeof(struct ns1__AsinSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__AsinSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__AsinSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__AsinSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AsinSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__AsinSearchRequest %p -> %p\n", q, p));
	*(struct ns1__AsinSearchRequest*)p = *(struct ns1__AsinSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AsinSearchRequestResponse(struct soap *soap, struct ns1__AsinSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AsinSearchRequestResponse(struct soap *soap, const struct ns1__AsinSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AsinSearchRequestResponse(struct soap *soap, const struct ns1__AsinSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AsinSearchRequestResponse);
	if (soap_out_ns1__AsinSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AsinSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__AsinSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AsinSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AsinSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__AsinSearchRequestResponse(struct soap *soap, struct ns1__AsinSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AsinSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AsinSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__AsinSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__AsinSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AsinSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AsinSearchRequestResponse, sizeof(struct ns1__AsinSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AsinSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AsinSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AsinSearchRequestResponse, 0, sizeof(struct ns1__AsinSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__AsinSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__AsinSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__AsinSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AsinSearchRequestResponse(struct soap *soap, struct ns1__AsinSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__AsinSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__AsinSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AsinSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AsinSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__AsinSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__AsinSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__AsinSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__AsinSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__AsinSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AsinSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__AsinSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__AsinSearchRequestResponse*)p = *(struct ns1__AsinSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__BrowseNodeSearchRequest(struct soap *soap, struct ns1__BrowseNodeSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BrowseNodeSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BrowseNodeSearchRequest(struct soap *soap, const struct ns1__BrowseNodeSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BrowseNodeRequest(soap, &a->BrowseNodeSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BrowseNodeSearchRequest(struct soap *soap, const struct ns1__BrowseNodeSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__BrowseNodeSearchRequest);
	if (soap_out_ns1__BrowseNodeSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BrowseNodeSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__BrowseNodeSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BrowseNodeSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__BrowseNodeRequest(soap, "BrowseNodeSearchRequest", -1, &a->BrowseNodeSearchRequest, "ns1:BrowseNodeRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__BrowseNodeSearchRequest * SOAP_FMAC4 soap_get_ns1__BrowseNodeSearchRequest(struct soap *soap, struct ns1__BrowseNodeSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BrowseNodeSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__BrowseNodeSearchRequest * SOAP_FMAC4 soap_in_ns1__BrowseNodeSearchRequest(struct soap *soap, const char *tag, struct ns1__BrowseNodeSearchRequest *a, const char *type)
{
	size_t soap_flag_BrowseNodeSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__BrowseNodeSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BrowseNodeSearchRequest, sizeof(struct ns1__BrowseNodeSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__BrowseNodeSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BrowseNodeSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BrowseNodeRequest(soap, "BrowseNodeSearchRequest", &a->BrowseNodeSearchRequest, "ns1:BrowseNodeRequest"))
				{	soap_flag_BrowseNodeSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__BrowseNodeSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BrowseNodeSearchRequest, 0, sizeof(struct ns1__BrowseNodeSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__BrowseNodeSearchRequest * SOAP_FMAC6 soap_new_ns1__BrowseNodeSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__BrowseNodeSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BrowseNodeSearchRequest(struct soap *soap, struct ns1__BrowseNodeSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__BrowseNodeSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__BrowseNodeSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BrowseNodeSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BrowseNodeSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__BrowseNodeSearchRequest;
		if (size)
			*size = sizeof(struct ns1__BrowseNodeSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__BrowseNodeSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__BrowseNodeSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__BrowseNodeSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BrowseNodeSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__BrowseNodeSearchRequest %p -> %p\n", q, p));
	*(struct ns1__BrowseNodeSearchRequest*)p = *(struct ns1__BrowseNodeSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, struct ns1__BrowseNodeSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, const struct ns1__BrowseNodeSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, const struct ns1__BrowseNodeSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse);
	if (soap_out_ns1__BrowseNodeSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__BrowseNodeSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__BrowseNodeSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, struct ns1__BrowseNodeSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BrowseNodeSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__BrowseNodeSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__BrowseNodeSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__BrowseNodeSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse, sizeof(struct ns1__BrowseNodeSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__BrowseNodeSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__BrowseNodeSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse, 0, sizeof(struct ns1__BrowseNodeSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__BrowseNodeSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__BrowseNodeSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, struct ns1__BrowseNodeSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__BrowseNodeSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BrowseNodeSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BrowseNodeSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__BrowseNodeSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__BrowseNodeSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__BrowseNodeSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__BrowseNodeSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__BrowseNodeSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BrowseNodeSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__BrowseNodeSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__BrowseNodeSearchRequestResponse*)p = *(struct ns1__BrowseNodeSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PowerSearchRequest(struct soap *soap, struct ns1__PowerSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PowerSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PowerSearchRequest(struct soap *soap, const struct ns1__PowerSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PowerRequest(soap, &a->PowerSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PowerSearchRequest(struct soap *soap, const struct ns1__PowerSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PowerSearchRequest);
	if (soap_out_ns1__PowerSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PowerSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__PowerSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PowerSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__PowerRequest(soap, "PowerSearchRequest", -1, &a->PowerSearchRequest, "ns1:PowerRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PowerSearchRequest * SOAP_FMAC4 soap_get_ns1__PowerSearchRequest(struct soap *soap, struct ns1__PowerSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PowerSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__PowerSearchRequest * SOAP_FMAC4 soap_in_ns1__PowerSearchRequest(struct soap *soap, const char *tag, struct ns1__PowerSearchRequest *a, const char *type)
{
	size_t soap_flag_PowerSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PowerSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PowerSearchRequest, sizeof(struct ns1__PowerSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PowerSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PowerSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PowerRequest(soap, "PowerSearchRequest", &a->PowerSearchRequest, "ns1:PowerRequest"))
				{	soap_flag_PowerSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PowerSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PowerSearchRequest, 0, sizeof(struct ns1__PowerSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__PowerSearchRequest * SOAP_FMAC6 soap_new_ns1__PowerSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__PowerSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PowerSearchRequest(struct soap *soap, struct ns1__PowerSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__PowerSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__PowerSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PowerSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PowerSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__PowerSearchRequest;
		if (size)
			*size = sizeof(struct ns1__PowerSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__PowerSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__PowerSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__PowerSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PowerSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__PowerSearchRequest %p -> %p\n", q, p));
	*(struct ns1__PowerSearchRequest*)p = *(struct ns1__PowerSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PowerSearchRequestResponse(struct soap *soap, struct ns1__PowerSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PowerSearchRequestResponse(struct soap *soap, const struct ns1__PowerSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PowerSearchRequestResponse(struct soap *soap, const struct ns1__PowerSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PowerSearchRequestResponse);
	if (soap_out_ns1__PowerSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PowerSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__PowerSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PowerSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PowerSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__PowerSearchRequestResponse(struct soap *soap, struct ns1__PowerSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PowerSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__PowerSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__PowerSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__PowerSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PowerSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PowerSearchRequestResponse, sizeof(struct ns1__PowerSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PowerSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PowerSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PowerSearchRequestResponse, 0, sizeof(struct ns1__PowerSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__PowerSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__PowerSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__PowerSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PowerSearchRequestResponse(struct soap *soap, struct ns1__PowerSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__PowerSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__PowerSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PowerSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PowerSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__PowerSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__PowerSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__PowerSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__PowerSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__PowerSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PowerSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__PowerSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__PowerSearchRequestResponse*)p = *(struct ns1__PowerSearchRequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__KeywordSearchRequest(struct soap *soap, struct ns1__KeywordSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeywordSearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__KeywordSearchRequest(struct soap *soap, const struct ns1__KeywordSearchRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__KeywordRequest(soap, &a->KeywordSearchRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__KeywordSearchRequest(struct soap *soap, const struct ns1__KeywordSearchRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__KeywordSearchRequest);
	if (soap_out_ns1__KeywordSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__KeywordSearchRequest(struct soap *soap, const char *tag, int id, const struct ns1__KeywordSearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__KeywordSearchRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__KeywordRequest(soap, "KeywordSearchRequest", -1, &a->KeywordSearchRequest, "ns1:KeywordRequest"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__KeywordSearchRequest * SOAP_FMAC4 soap_get_ns1__KeywordSearchRequest(struct soap *soap, struct ns1__KeywordSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__KeywordSearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__KeywordSearchRequest * SOAP_FMAC4 soap_in_ns1__KeywordSearchRequest(struct soap *soap, const char *tag, struct ns1__KeywordSearchRequest *a, const char *type)
{
	size_t soap_flag_KeywordSearchRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__KeywordSearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__KeywordSearchRequest, sizeof(struct ns1__KeywordSearchRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__KeywordSearchRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeywordSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__KeywordRequest(soap, "KeywordSearchRequest", &a->KeywordSearchRequest, "ns1:KeywordRequest"))
				{	soap_flag_KeywordSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__KeywordSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__KeywordSearchRequest, 0, sizeof(struct ns1__KeywordSearchRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__KeywordSearchRequest * SOAP_FMAC6 soap_new_ns1__KeywordSearchRequest(struct soap *soap, int n)
{	return soap_instantiate_ns1__KeywordSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__KeywordSearchRequest(struct soap *soap, struct ns1__KeywordSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__KeywordSearchRequest * SOAP_FMAC4 soap_instantiate_ns1__KeywordSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__KeywordSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__KeywordSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__KeywordSearchRequest;
		if (size)
			*size = sizeof(struct ns1__KeywordSearchRequest);
	}
	else
	{	cp->ptr = (void*)new struct ns1__KeywordSearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__KeywordSearchRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__KeywordSearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__KeywordSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__KeywordSearchRequest %p -> %p\n", q, p));
	*(struct ns1__KeywordSearchRequest*)p = *(struct ns1__KeywordSearchRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__KeywordSearchRequestResponse(struct soap *soap, struct ns1__KeywordSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__KeywordSearchRequestResponse(struct soap *soap, const struct ns1__KeywordSearchRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProductInfo(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__KeywordSearchRequestResponse(struct soap *soap, const struct ns1__KeywordSearchRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__KeywordSearchRequestResponse);
	if (soap_out_ns1__KeywordSearchRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__KeywordSearchRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__KeywordSearchRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__KeywordSearchRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProductInfo(soap, "return", -1, &a->return_, "ns1:ProductInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__KeywordSearchRequestResponse * SOAP_FMAC4 soap_get_ns1__KeywordSearchRequestResponse(struct soap *soap, struct ns1__KeywordSearchRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__KeywordSearchRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__KeywordSearchRequestResponse * SOAP_FMAC4 soap_in_ns1__KeywordSearchRequestResponse(struct soap *soap, const char *tag, struct ns1__KeywordSearchRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__KeywordSearchRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__KeywordSearchRequestResponse, sizeof(struct ns1__KeywordSearchRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__KeywordSearchRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProductInfo(soap, "return", &a->return_, "ns1:ProductInfo"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__KeywordSearchRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__KeywordSearchRequestResponse, 0, sizeof(struct ns1__KeywordSearchRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__KeywordSearchRequestResponse * SOAP_FMAC6 soap_new_ns1__KeywordSearchRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__KeywordSearchRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__KeywordSearchRequestResponse(struct soap *soap, struct ns1__KeywordSearchRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__KeywordSearchRequestResponse * SOAP_FMAC4 soap_instantiate_ns1__KeywordSearchRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__KeywordSearchRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__KeywordSearchRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__KeywordSearchRequestResponse;
		if (size)
			*size = sizeof(struct ns1__KeywordSearchRequestResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__KeywordSearchRequestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__KeywordSearchRequestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__KeywordSearchRequestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__KeywordSearchRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__KeywordSearchRequestResponse %p -> %p\n", q, p));
	*(struct ns1__KeywordSearchRequestResponse*)p = *(struct ns1__KeywordSearchRequestResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ModifyShoppingCartItemsRequest(struct soap *soap, ns1__ModifyShoppingCartItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ModifyShoppingCartItemsRequest(struct soap *soap, ns1__ModifyShoppingCartItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ModifyShoppingCartItemsRequest);
	if (soap_out_PointerTons1__ModifyShoppingCartItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ModifyShoppingCartItemsRequest(struct soap *soap, const char *tag, int id, ns1__ModifyShoppingCartItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ModifyShoppingCartItemsRequest ** SOAP_FMAC4 soap_get_PointerTons1__ModifyShoppingCartItemsRequest(struct soap *soap, ns1__ModifyShoppingCartItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ModifyShoppingCartItemsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ModifyShoppingCartItemsRequest ** SOAP_FMAC4 soap_in_PointerTons1__ModifyShoppingCartItemsRequest(struct soap *soap, const char *tag, ns1__ModifyShoppingCartItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ModifyShoppingCartItemsRequest **)soap_malloc(soap, sizeof(ns1__ModifyShoppingCartItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ModifyShoppingCartItemsRequest *)soap_instantiate_ns1__ModifyShoppingCartItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ModifyShoppingCartItemsRequest ** p = (ns1__ModifyShoppingCartItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ModifyShoppingCartItemsRequest, sizeof(ns1__ModifyShoppingCartItemsRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RemoveShoppingCartItemsRequest(struct soap *soap, ns1__RemoveShoppingCartItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RemoveShoppingCartItemsRequest(struct soap *soap, ns1__RemoveShoppingCartItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RemoveShoppingCartItemsRequest);
	if (soap_out_PointerTons1__RemoveShoppingCartItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RemoveShoppingCartItemsRequest(struct soap *soap, const char *tag, int id, ns1__RemoveShoppingCartItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RemoveShoppingCartItemsRequest ** SOAP_FMAC4 soap_get_PointerTons1__RemoveShoppingCartItemsRequest(struct soap *soap, ns1__RemoveShoppingCartItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RemoveShoppingCartItemsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__RemoveShoppingCartItemsRequest ** SOAP_FMAC4 soap_in_PointerTons1__RemoveShoppingCartItemsRequest(struct soap *soap, const char *tag, ns1__RemoveShoppingCartItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RemoveShoppingCartItemsRequest **)soap_malloc(soap, sizeof(ns1__RemoveShoppingCartItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RemoveShoppingCartItemsRequest *)soap_instantiate_ns1__RemoveShoppingCartItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__RemoveShoppingCartItemsRequest ** p = (ns1__RemoveShoppingCartItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RemoveShoppingCartItemsRequest, sizeof(ns1__RemoveShoppingCartItemsRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AddShoppingCartItemsRequest(struct soap *soap, ns1__AddShoppingCartItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AddShoppingCartItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AddShoppingCartItemsRequest(struct soap *soap, ns1__AddShoppingCartItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AddShoppingCartItemsRequest);
	if (soap_out_PointerTons1__AddShoppingCartItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AddShoppingCartItemsRequest(struct soap *soap, const char *tag, int id, ns1__AddShoppingCartItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AddShoppingCartItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AddShoppingCartItemsRequest ** SOAP_FMAC4 soap_get_PointerTons1__AddShoppingCartItemsRequest(struct soap *soap, ns1__AddShoppingCartItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AddShoppingCartItemsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__AddShoppingCartItemsRequest ** SOAP_FMAC4 soap_in_PointerTons1__AddShoppingCartItemsRequest(struct soap *soap, const char *tag, ns1__AddShoppingCartItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AddShoppingCartItemsRequest **)soap_malloc(soap, sizeof(ns1__AddShoppingCartItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AddShoppingCartItemsRequest *)soap_instantiate_ns1__AddShoppingCartItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AddShoppingCartItemsRequest ** p = (ns1__AddShoppingCartItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AddShoppingCartItemsRequest, sizeof(ns1__AddShoppingCartItemsRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ClearShoppingCartRequest(struct soap *soap, ns1__ClearShoppingCartRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ClearShoppingCartRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ClearShoppingCartRequest(struct soap *soap, ns1__ClearShoppingCartRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ClearShoppingCartRequest);
	if (soap_out_PointerTons1__ClearShoppingCartRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ClearShoppingCartRequest(struct soap *soap, const char *tag, int id, ns1__ClearShoppingCartRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ClearShoppingCartRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ClearShoppingCartRequest ** SOAP_FMAC4 soap_get_PointerTons1__ClearShoppingCartRequest(struct soap *soap, ns1__ClearShoppingCartRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ClearShoppingCartRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ClearShoppingCartRequest ** SOAP_FMAC4 soap_in_PointerTons1__ClearShoppingCartRequest(struct soap *soap, const char *tag, ns1__ClearShoppingCartRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ClearShoppingCartRequest **)soap_malloc(soap, sizeof(ns1__ClearShoppingCartRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ClearShoppingCartRequest *)soap_instantiate_ns1__ClearShoppingCartRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ClearShoppingCartRequest ** p = (ns1__ClearShoppingCartRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ClearShoppingCartRequest, sizeof(ns1__ClearShoppingCartRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetShoppingCartRequest(struct soap *soap, ns1__GetShoppingCartRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetShoppingCartRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetShoppingCartRequest(struct soap *soap, ns1__GetShoppingCartRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GetShoppingCartRequest);
	if (soap_out_PointerTons1__GetShoppingCartRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetShoppingCartRequest(struct soap *soap, const char *tag, int id, ns1__GetShoppingCartRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetShoppingCartRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GetShoppingCartRequest ** SOAP_FMAC4 soap_get_PointerTons1__GetShoppingCartRequest(struct soap *soap, ns1__GetShoppingCartRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetShoppingCartRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__GetShoppingCartRequest ** SOAP_FMAC4 soap_in_PointerTons1__GetShoppingCartRequest(struct soap *soap, const char *tag, ns1__GetShoppingCartRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetShoppingCartRequest **)soap_malloc(soap, sizeof(ns1__GetShoppingCartRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetShoppingCartRequest *)soap_instantiate_ns1__GetShoppingCartRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__GetShoppingCartRequest ** p = (ns1__GetShoppingCartRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetShoppingCartRequest, sizeof(ns1__GetShoppingCartRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ShoppingCart(struct soap *soap, ns1__ShoppingCart *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ShoppingCart))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ShoppingCart(struct soap *soap, ns1__ShoppingCart *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ShoppingCart);
	if (soap_out_PointerTons1__ShoppingCart(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ShoppingCart(struct soap *soap, const char *tag, int id, ns1__ShoppingCart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ShoppingCart);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ShoppingCart ** SOAP_FMAC4 soap_get_PointerTons1__ShoppingCart(struct soap *soap, ns1__ShoppingCart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ShoppingCart ** SOAP_FMAC4 soap_in_PointerTons1__ShoppingCart(struct soap *soap, const char *tag, ns1__ShoppingCart **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ShoppingCart **)soap_malloc(soap, sizeof(ns1__ShoppingCart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ShoppingCart *)soap_instantiate_ns1__ShoppingCart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ShoppingCart ** p = (ns1__ShoppingCart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ShoppingCart, sizeof(ns1__ShoppingCart), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SimilarityRequest(struct soap *soap, ns1__SimilarityRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SimilarityRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SimilarityRequest(struct soap *soap, ns1__SimilarityRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SimilarityRequest);
	if (soap_out_PointerTons1__SimilarityRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SimilarityRequest(struct soap *soap, const char *tag, int id, ns1__SimilarityRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SimilarityRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SimilarityRequest ** SOAP_FMAC4 soap_get_PointerTons1__SimilarityRequest(struct soap *soap, ns1__SimilarityRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SimilarityRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SimilarityRequest ** SOAP_FMAC4 soap_in_PointerTons1__SimilarityRequest(struct soap *soap, const char *tag, ns1__SimilarityRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SimilarityRequest **)soap_malloc(soap, sizeof(ns1__SimilarityRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SimilarityRequest *)soap_instantiate_ns1__SimilarityRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SimilarityRequest ** p = (ns1__SimilarityRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SimilarityRequest, sizeof(ns1__SimilarityRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MarketplaceRequest(struct soap *soap, ns1__MarketplaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MarketplaceRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MarketplaceRequest(struct soap *soap, ns1__MarketplaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MarketplaceRequest);
	if (soap_out_PointerTons1__MarketplaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MarketplaceRequest(struct soap *soap, const char *tag, int id, ns1__MarketplaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MarketplaceRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MarketplaceRequest ** SOAP_FMAC4 soap_get_PointerTons1__MarketplaceRequest(struct soap *soap, ns1__MarketplaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MarketplaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__MarketplaceRequest ** SOAP_FMAC4 soap_in_PointerTons1__MarketplaceRequest(struct soap *soap, const char *tag, ns1__MarketplaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketplaceRequest **)soap_malloc(soap, sizeof(ns1__MarketplaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MarketplaceRequest *)soap_instantiate_ns1__MarketplaceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MarketplaceRequest ** p = (ns1__MarketplaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MarketplaceRequest, sizeof(ns1__MarketplaceRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MarketplaceSearch(struct soap *soap, ns1__MarketplaceSearch *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MarketplaceSearch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MarketplaceSearch(struct soap *soap, ns1__MarketplaceSearch *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MarketplaceSearch);
	if (soap_out_PointerTons1__MarketplaceSearch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MarketplaceSearch(struct soap *soap, const char *tag, int id, ns1__MarketplaceSearch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MarketplaceSearch);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MarketplaceSearch ** SOAP_FMAC4 soap_get_PointerTons1__MarketplaceSearch(struct soap *soap, ns1__MarketplaceSearch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MarketplaceSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__MarketplaceSearch ** SOAP_FMAC4 soap_in_PointerTons1__MarketplaceSearch(struct soap *soap, const char *tag, ns1__MarketplaceSearch **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketplaceSearch **)soap_malloc(soap, sizeof(ns1__MarketplaceSearch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MarketplaceSearch *)soap_instantiate_ns1__MarketplaceSearch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MarketplaceSearch ** p = (ns1__MarketplaceSearch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MarketplaceSearch, sizeof(ns1__MarketplaceSearch), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellerRequest(struct soap *soap, ns1__SellerRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellerRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellerRequest(struct soap *soap, ns1__SellerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellerRequest);
	if (soap_out_PointerTons1__SellerRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellerRequest(struct soap *soap, const char *tag, int id, ns1__SellerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellerRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellerRequest ** SOAP_FMAC4 soap_get_PointerTons1__SellerRequest(struct soap *soap, ns1__SellerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerRequest ** SOAP_FMAC4 soap_in_PointerTons1__SellerRequest(struct soap *soap, const char *tag, ns1__SellerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerRequest **)soap_malloc(soap, sizeof(ns1__SellerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellerRequest *)soap_instantiate_ns1__SellerRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellerRequest ** p = (ns1__SellerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellerRequest, sizeof(ns1__SellerRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellerSearch(struct soap *soap, ns1__SellerSearch *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellerSearch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellerSearch(struct soap *soap, ns1__SellerSearch *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellerSearch);
	if (soap_out_PointerTons1__SellerSearch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellerSearch(struct soap *soap, const char *tag, int id, ns1__SellerSearch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellerSearch);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellerSearch ** SOAP_FMAC4 soap_get_PointerTons1__SellerSearch(struct soap *soap, ns1__SellerSearch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellerSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerSearch ** SOAP_FMAC4 soap_in_PointerTons1__SellerSearch(struct soap *soap, const char *tag, ns1__SellerSearch **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerSearch **)soap_malloc(soap, sizeof(ns1__SellerSearch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellerSearch *)soap_instantiate_ns1__SellerSearch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellerSearch ** p = (ns1__SellerSearch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellerSearch, sizeof(ns1__SellerSearch), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellerProfileRequest(struct soap *soap, ns1__SellerProfileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellerProfileRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellerProfileRequest(struct soap *soap, ns1__SellerProfileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellerProfileRequest);
	if (soap_out_PointerTons1__SellerProfileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellerProfileRequest(struct soap *soap, const char *tag, int id, ns1__SellerProfileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellerProfileRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellerProfileRequest ** SOAP_FMAC4 soap_get_PointerTons1__SellerProfileRequest(struct soap *soap, ns1__SellerProfileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellerProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerProfileRequest ** SOAP_FMAC4 soap_in_PointerTons1__SellerProfileRequest(struct soap *soap, const char *tag, ns1__SellerProfileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerProfileRequest **)soap_malloc(soap, sizeof(ns1__SellerProfileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellerProfileRequest *)soap_instantiate_ns1__SellerProfileRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellerProfileRequest ** p = (ns1__SellerProfileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellerProfileRequest, sizeof(ns1__SellerProfileRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellerProfile(struct soap *soap, ns1__SellerProfile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellerProfile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellerProfile(struct soap *soap, ns1__SellerProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellerProfile);
	if (soap_out_PointerTons1__SellerProfile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellerProfile(struct soap *soap, const char *tag, int id, ns1__SellerProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellerProfile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellerProfile ** SOAP_FMAC4 soap_get_PointerTons1__SellerProfile(struct soap *soap, ns1__SellerProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellerProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerProfile ** SOAP_FMAC4 soap_in_PointerTons1__SellerProfile(struct soap *soap, const char *tag, ns1__SellerProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerProfile **)soap_malloc(soap, sizeof(ns1__SellerProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellerProfile *)soap_instantiate_ns1__SellerProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellerProfile ** p = (ns1__SellerProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellerProfile, sizeof(ns1__SellerProfile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__WishlistRequest(struct soap *soap, ns1__WishlistRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__WishlistRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__WishlistRequest(struct soap *soap, ns1__WishlistRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__WishlistRequest);
	if (soap_out_PointerTons1__WishlistRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__WishlistRequest(struct soap *soap, const char *tag, int id, ns1__WishlistRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__WishlistRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__WishlistRequest ** SOAP_FMAC4 soap_get_PointerTons1__WishlistRequest(struct soap *soap, ns1__WishlistRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__WishlistRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__WishlistRequest ** SOAP_FMAC4 soap_in_PointerTons1__WishlistRequest(struct soap *soap, const char *tag, ns1__WishlistRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__WishlistRequest **)soap_malloc(soap, sizeof(ns1__WishlistRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__WishlistRequest *)soap_instantiate_ns1__WishlistRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__WishlistRequest ** p = (ns1__WishlistRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__WishlistRequest, sizeof(ns1__WishlistRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListManiaRequest(struct soap *soap, ns1__ListManiaRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListManiaRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListManiaRequest(struct soap *soap, ns1__ListManiaRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListManiaRequest);
	if (soap_out_PointerTons1__ListManiaRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListManiaRequest(struct soap *soap, const char *tag, int id, ns1__ListManiaRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListManiaRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListManiaRequest ** SOAP_FMAC4 soap_get_PointerTons1__ListManiaRequest(struct soap *soap, ns1__ListManiaRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListManiaRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ListManiaRequest ** SOAP_FMAC4 soap_in_PointerTons1__ListManiaRequest(struct soap *soap, const char *tag, ns1__ListManiaRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListManiaRequest **)soap_malloc(soap, sizeof(ns1__ListManiaRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListManiaRequest *)soap_instantiate_ns1__ListManiaRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListManiaRequest ** p = (ns1__ListManiaRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListManiaRequest, sizeof(ns1__ListManiaRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExchangeRequest(struct soap *soap, ns1__ExchangeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ExchangeRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExchangeRequest(struct soap *soap, ns1__ExchangeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ExchangeRequest);
	if (soap_out_PointerTons1__ExchangeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExchangeRequest(struct soap *soap, const char *tag, int id, ns1__ExchangeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExchangeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ExchangeRequest ** SOAP_FMAC4 soap_get_PointerTons1__ExchangeRequest(struct soap *soap, ns1__ExchangeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExchangeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ExchangeRequest ** SOAP_FMAC4 soap_in_PointerTons1__ExchangeRequest(struct soap *soap, const char *tag, ns1__ExchangeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ExchangeRequest **)soap_malloc(soap, sizeof(ns1__ExchangeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ExchangeRequest *)soap_instantiate_ns1__ExchangeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ExchangeRequest ** p = (ns1__ExchangeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExchangeRequest, sizeof(ns1__ExchangeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DirectorRequest(struct soap *soap, ns1__DirectorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DirectorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DirectorRequest(struct soap *soap, ns1__DirectorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DirectorRequest);
	if (soap_out_PointerTons1__DirectorRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DirectorRequest(struct soap *soap, const char *tag, int id, ns1__DirectorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DirectorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DirectorRequest ** SOAP_FMAC4 soap_get_PointerTons1__DirectorRequest(struct soap *soap, ns1__DirectorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DirectorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DirectorRequest ** SOAP_FMAC4 soap_in_PointerTons1__DirectorRequest(struct soap *soap, const char *tag, ns1__DirectorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DirectorRequest **)soap_malloc(soap, sizeof(ns1__DirectorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DirectorRequest *)soap_instantiate_ns1__DirectorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DirectorRequest ** p = (ns1__DirectorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DirectorRequest, sizeof(ns1__DirectorRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ManufacturerRequest(struct soap *soap, ns1__ManufacturerRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ManufacturerRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ManufacturerRequest(struct soap *soap, ns1__ManufacturerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ManufacturerRequest);
	if (soap_out_PointerTons1__ManufacturerRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ManufacturerRequest(struct soap *soap, const char *tag, int id, ns1__ManufacturerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ManufacturerRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ManufacturerRequest ** SOAP_FMAC4 soap_get_PointerTons1__ManufacturerRequest(struct soap *soap, ns1__ManufacturerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ManufacturerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ManufacturerRequest ** SOAP_FMAC4 soap_in_PointerTons1__ManufacturerRequest(struct soap *soap, const char *tag, ns1__ManufacturerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ManufacturerRequest **)soap_malloc(soap, sizeof(ns1__ManufacturerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ManufacturerRequest *)soap_instantiate_ns1__ManufacturerRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ManufacturerRequest ** p = (ns1__ManufacturerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ManufacturerRequest, sizeof(ns1__ManufacturerRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActorRequest(struct soap *soap, ns1__ActorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActorRequest(struct soap *soap, ns1__ActorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActorRequest);
	if (soap_out_PointerTons1__ActorRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActorRequest(struct soap *soap, const char *tag, int id, ns1__ActorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ActorRequest ** SOAP_FMAC4 soap_get_PointerTons1__ActorRequest(struct soap *soap, ns1__ActorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ActorRequest ** SOAP_FMAC4 soap_in_PointerTons1__ActorRequest(struct soap *soap, const char *tag, ns1__ActorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ActorRequest **)soap_malloc(soap, sizeof(ns1__ActorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ActorRequest *)soap_instantiate_ns1__ActorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ActorRequest ** p = (ns1__ActorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActorRequest, sizeof(ns1__ActorRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArtistRequest(struct soap *soap, ns1__ArtistRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArtistRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArtistRequest(struct soap *soap, ns1__ArtistRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArtistRequest);
	if (soap_out_PointerTons1__ArtistRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArtistRequest(struct soap *soap, const char *tag, int id, ns1__ArtistRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArtistRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArtistRequest ** SOAP_FMAC4 soap_get_PointerTons1__ArtistRequest(struct soap *soap, ns1__ArtistRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArtistRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArtistRequest ** SOAP_FMAC4 soap_in_PointerTons1__ArtistRequest(struct soap *soap, const char *tag, ns1__ArtistRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArtistRequest **)soap_malloc(soap, sizeof(ns1__ArtistRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArtistRequest *)soap_instantiate_ns1__ArtistRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArtistRequest ** p = (ns1__ArtistRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArtistRequest, sizeof(ns1__ArtistRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuthorRequest(struct soap *soap, ns1__AuthorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AuthorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuthorRequest(struct soap *soap, ns1__AuthorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuthorRequest);
	if (soap_out_PointerTons1__AuthorRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuthorRequest(struct soap *soap, const char *tag, int id, ns1__AuthorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuthorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AuthorRequest ** SOAP_FMAC4 soap_get_PointerTons1__AuthorRequest(struct soap *soap, ns1__AuthorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuthorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__AuthorRequest ** SOAP_FMAC4 soap_in_PointerTons1__AuthorRequest(struct soap *soap, const char *tag, ns1__AuthorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AuthorRequest **)soap_malloc(soap, sizeof(ns1__AuthorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AuthorRequest *)soap_instantiate_ns1__AuthorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AuthorRequest ** p = (ns1__AuthorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuthorRequest, sizeof(ns1__AuthorRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UpcRequest(struct soap *soap, ns1__UpcRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UpcRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UpcRequest(struct soap *soap, ns1__UpcRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UpcRequest);
	if (soap_out_PointerTons1__UpcRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UpcRequest(struct soap *soap, const char *tag, int id, ns1__UpcRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UpcRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UpcRequest ** SOAP_FMAC4 soap_get_PointerTons1__UpcRequest(struct soap *soap, ns1__UpcRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UpcRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__UpcRequest ** SOAP_FMAC4 soap_in_PointerTons1__UpcRequest(struct soap *soap, const char *tag, ns1__UpcRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UpcRequest **)soap_malloc(soap, sizeof(ns1__UpcRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UpcRequest *)soap_instantiate_ns1__UpcRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UpcRequest ** p = (ns1__UpcRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UpcRequest, sizeof(ns1__UpcRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BlendedRequest(struct soap *soap, ns1__BlendedRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BlendedRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BlendedRequest(struct soap *soap, ns1__BlendedRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BlendedRequest);
	if (soap_out_PointerTons1__BlendedRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BlendedRequest(struct soap *soap, const char *tag, int id, ns1__BlendedRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BlendedRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BlendedRequest ** SOAP_FMAC4 soap_get_PointerTons1__BlendedRequest(struct soap *soap, ns1__BlendedRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BlendedRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__BlendedRequest ** SOAP_FMAC4 soap_in_PointerTons1__BlendedRequest(struct soap *soap, const char *tag, ns1__BlendedRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BlendedRequest **)soap_malloc(soap, sizeof(ns1__BlendedRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BlendedRequest *)soap_instantiate_ns1__BlendedRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__BlendedRequest ** p = (ns1__BlendedRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BlendedRequest, sizeof(ns1__BlendedRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToProductLineArray(struct soap *soap, ProductLineArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToProductLineArray(struct soap *soap, ProductLineArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToProductLineArray);
	if (soap_out_PointerToProductLineArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToProductLineArray(struct soap *soap, const char *tag, int id, ProductLineArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ProductLineArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ProductLineArray ** SOAP_FMAC4 soap_get_PointerToProductLineArray(struct soap *soap, ProductLineArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToProductLineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ProductLineArray ** SOAP_FMAC4 soap_in_PointerToProductLineArray(struct soap *soap, const char *tag, ProductLineArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ProductLineArray **)soap_malloc(soap, sizeof(ProductLineArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ProductLineArray *)soap_instantiate_ProductLineArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ProductLineArray ** p = (ProductLineArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ProductLineArray, sizeof(ProductLineArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AsinRequest(struct soap *soap, ns1__AsinRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AsinRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AsinRequest(struct soap *soap, ns1__AsinRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AsinRequest);
	if (soap_out_PointerTons1__AsinRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AsinRequest(struct soap *soap, const char *tag, int id, ns1__AsinRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AsinRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AsinRequest ** SOAP_FMAC4 soap_get_PointerTons1__AsinRequest(struct soap *soap, ns1__AsinRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AsinRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__AsinRequest ** SOAP_FMAC4 soap_in_PointerTons1__AsinRequest(struct soap *soap, const char *tag, ns1__AsinRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AsinRequest **)soap_malloc(soap, sizeof(ns1__AsinRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AsinRequest *)soap_instantiate_ns1__AsinRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AsinRequest ** p = (ns1__AsinRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AsinRequest, sizeof(ns1__AsinRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BrowseNodeRequest(struct soap *soap, ns1__BrowseNodeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BrowseNodeRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BrowseNodeRequest(struct soap *soap, ns1__BrowseNodeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BrowseNodeRequest);
	if (soap_out_PointerTons1__BrowseNodeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BrowseNodeRequest(struct soap *soap, const char *tag, int id, ns1__BrowseNodeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BrowseNodeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BrowseNodeRequest ** SOAP_FMAC4 soap_get_PointerTons1__BrowseNodeRequest(struct soap *soap, ns1__BrowseNodeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BrowseNodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__BrowseNodeRequest ** SOAP_FMAC4 soap_in_PointerTons1__BrowseNodeRequest(struct soap *soap, const char *tag, ns1__BrowseNodeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BrowseNodeRequest **)soap_malloc(soap, sizeof(ns1__BrowseNodeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BrowseNodeRequest *)soap_instantiate_ns1__BrowseNodeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__BrowseNodeRequest ** p = (ns1__BrowseNodeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BrowseNodeRequest, sizeof(ns1__BrowseNodeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PowerRequest(struct soap *soap, ns1__PowerRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PowerRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PowerRequest(struct soap *soap, ns1__PowerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PowerRequest);
	if (soap_out_PointerTons1__PowerRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PowerRequest(struct soap *soap, const char *tag, int id, ns1__PowerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PowerRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PowerRequest ** SOAP_FMAC4 soap_get_PointerTons1__PowerRequest(struct soap *soap, ns1__PowerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PowerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__PowerRequest ** SOAP_FMAC4 soap_in_PointerTons1__PowerRequest(struct soap *soap, const char *tag, ns1__PowerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PowerRequest **)soap_malloc(soap, sizeof(ns1__PowerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PowerRequest *)soap_instantiate_ns1__PowerRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PowerRequest ** p = (ns1__PowerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PowerRequest, sizeof(ns1__PowerRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__KeywordRequest(struct soap *soap, ns1__KeywordRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__KeywordRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__KeywordRequest(struct soap *soap, ns1__KeywordRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__KeywordRequest);
	if (soap_out_PointerTons1__KeywordRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__KeywordRequest(struct soap *soap, const char *tag, int id, ns1__KeywordRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__KeywordRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__KeywordRequest ** SOAP_FMAC4 soap_get_PointerTons1__KeywordRequest(struct soap *soap, ns1__KeywordRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__KeywordRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__KeywordRequest ** SOAP_FMAC4 soap_in_PointerTons1__KeywordRequest(struct soap *soap, const char *tag, ns1__KeywordRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__KeywordRequest **)soap_malloc(soap, sizeof(ns1__KeywordRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__KeywordRequest *)soap_instantiate_ns1__KeywordRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__KeywordRequest ** p = (ns1__KeywordRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__KeywordRequest, sizeof(ns1__KeywordRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AddItem(struct soap *soap, ns1__AddItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AddItem))
		soap_serialize_PointerTons1__AddItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AddItem(struct soap *soap, ns1__AddItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AddItem);
	if (soap_out_PointerToPointerTons1__AddItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AddItem(struct soap *soap, const char *tag, int id, ns1__AddItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AddItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AddItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AddItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AddItem(struct soap *soap, ns1__AddItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AddItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__AddItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AddItem(struct soap *soap, const char *tag, ns1__AddItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AddItem ***)soap_malloc(soap, sizeof(ns1__AddItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AddItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AddItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AddItem, sizeof(ns1__AddItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AddItem(struct soap *soap, ns1__AddItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AddItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AddItem(struct soap *soap, ns1__AddItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AddItem);
	if (soap_out_PointerTons1__AddItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AddItem(struct soap *soap, const char *tag, int id, ns1__AddItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AddItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AddItem ** SOAP_FMAC4 soap_get_PointerTons1__AddItem(struct soap *soap, ns1__AddItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AddItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__AddItem ** SOAP_FMAC4 soap_in_PointerTons1__AddItem(struct soap *soap, const char *tag, ns1__AddItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AddItem **)soap_malloc(soap, sizeof(ns1__AddItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AddItem *)soap_instantiate_ns1__AddItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AddItem ** p = (ns1__AddItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AddItem, sizeof(ns1__AddItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ItemQuantity(struct soap *soap, ns1__ItemQuantity **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ItemQuantity))
		soap_serialize_PointerTons1__ItemQuantity(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ItemQuantity(struct soap *soap, ns1__ItemQuantity **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ItemQuantity);
	if (soap_out_PointerToPointerTons1__ItemQuantity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ItemQuantity(struct soap *soap, const char *tag, int id, ns1__ItemQuantity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ItemQuantity);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ItemQuantity(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ItemQuantity *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ItemQuantity(struct soap *soap, ns1__ItemQuantity ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ItemQuantity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ItemQuantity *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ItemQuantity(struct soap *soap, const char *tag, ns1__ItemQuantity ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ItemQuantity ***)soap_malloc(soap, sizeof(ns1__ItemQuantity **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ItemQuantity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ItemQuantity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ItemQuantity, sizeof(ns1__ItemQuantity *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemQuantity(struct soap *soap, ns1__ItemQuantity *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemQuantity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemQuantity(struct soap *soap, ns1__ItemQuantity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ItemQuantity);
	if (soap_out_PointerTons1__ItemQuantity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemQuantity(struct soap *soap, const char *tag, int id, ns1__ItemQuantity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ItemQuantity);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ItemQuantity ** SOAP_FMAC4 soap_get_PointerTons1__ItemQuantity(struct soap *soap, ns1__ItemQuantity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemQuantity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ItemQuantity ** SOAP_FMAC4 soap_in_PointerTons1__ItemQuantity(struct soap *soap, const char *tag, ns1__ItemQuantity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ItemQuantity **)soap_malloc(soap, sizeof(ns1__ItemQuantity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ItemQuantity *)soap_instantiate_ns1__ItemQuantity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ItemQuantity ** p = (ns1__ItemQuantity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ItemQuantity, sizeof(ns1__ItemQuantity), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Item(struct soap *soap, ns1__Item **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Item))
		soap_serialize_PointerTons1__Item(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Item(struct soap *soap, ns1__Item **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Item);
	if (soap_out_PointerToPointerTons1__Item(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Item(struct soap *soap, const char *tag, int id, ns1__Item **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Item);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Item(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Item *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Item(struct soap *soap, ns1__Item ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Item *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Item(struct soap *soap, const char *tag, ns1__Item ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Item ***)soap_malloc(soap, sizeof(ns1__Item **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Item(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Item ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Item, sizeof(ns1__Item *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Item(struct soap *soap, ns1__Item *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Item))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Item(struct soap *soap, ns1__Item *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Item);
	if (soap_out_PointerTons1__Item(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Item(struct soap *soap, const char *tag, int id, ns1__Item *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Item);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Item ** SOAP_FMAC4 soap_get_PointerTons1__Item(struct soap *soap, ns1__Item **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Item ** SOAP_FMAC4 soap_in_PointerTons1__Item(struct soap *soap, const char *tag, ns1__Item **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Item **)soap_malloc(soap, sizeof(ns1__Item *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Item *)soap_instantiate_ns1__Item(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Item ** p = (ns1__Item **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Item, sizeof(ns1__Item), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ThirdPartyProductDetails))
		soap_serialize_PointerTons1__ThirdPartyProductDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ThirdPartyProductDetails);
	if (soap_out_PointerToPointerTons1__ThirdPartyProductDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ThirdPartyProductDetails(struct soap *soap, const char *tag, int id, ns1__ThirdPartyProductDetails **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ThirdPartyProductDetails);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ThirdPartyProductDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ThirdPartyProductDetails *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ThirdPartyProductDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ThirdPartyProductDetails *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ThirdPartyProductDetails(struct soap *soap, const char *tag, ns1__ThirdPartyProductDetails ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ThirdPartyProductDetails ***)soap_malloc(soap, sizeof(ns1__ThirdPartyProductDetails **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ThirdPartyProductDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ThirdPartyProductDetails ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ThirdPartyProductDetails, sizeof(ns1__ThirdPartyProductDetails *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ThirdPartyProductDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ThirdPartyProductDetails);
	if (soap_out_PointerTons1__ThirdPartyProductDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ThirdPartyProductDetails(struct soap *soap, const char *tag, int id, ns1__ThirdPartyProductDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ThirdPartyProductDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ThirdPartyProductDetails ** SOAP_FMAC4 soap_get_PointerTons1__ThirdPartyProductDetails(struct soap *soap, ns1__ThirdPartyProductDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ThirdPartyProductDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ThirdPartyProductDetails ** SOAP_FMAC4 soap_in_PointerTons1__ThirdPartyProductDetails(struct soap *soap, const char *tag, ns1__ThirdPartyProductDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ThirdPartyProductDetails **)soap_malloc(soap, sizeof(ns1__ThirdPartyProductDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ThirdPartyProductDetails *)soap_instantiate_ns1__ThirdPartyProductDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ThirdPartyProductDetails ** p = (ns1__ThirdPartyProductDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ThirdPartyProductDetails, sizeof(ns1__ThirdPartyProductDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Feedback(struct soap *soap, ns1__Feedback **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Feedback))
		soap_serialize_PointerTons1__Feedback(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Feedback(struct soap *soap, ns1__Feedback **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Feedback);
	if (soap_out_PointerToPointerTons1__Feedback(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Feedback(struct soap *soap, const char *tag, int id, ns1__Feedback **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Feedback);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Feedback(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Feedback *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Feedback(struct soap *soap, ns1__Feedback ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Feedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Feedback *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Feedback(struct soap *soap, const char *tag, ns1__Feedback ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Feedback ***)soap_malloc(soap, sizeof(ns1__Feedback **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Feedback(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Feedback ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Feedback, sizeof(ns1__Feedback *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Feedback(struct soap *soap, ns1__Feedback *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Feedback))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Feedback(struct soap *soap, ns1__Feedback *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Feedback);
	if (soap_out_PointerTons1__Feedback(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Feedback(struct soap *soap, const char *tag, int id, ns1__Feedback *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Feedback);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Feedback ** SOAP_FMAC4 soap_get_PointerTons1__Feedback(struct soap *soap, ns1__Feedback **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Feedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Feedback ** SOAP_FMAC4 soap_in_PointerTons1__Feedback(struct soap *soap, const char *tag, ns1__Feedback **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Feedback **)soap_malloc(soap, sizeof(ns1__Feedback *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Feedback *)soap_instantiate_ns1__Feedback(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Feedback ** p = (ns1__Feedback **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Feedback, sizeof(ns1__Feedback), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ListingProductDetails))
		soap_serialize_PointerTons1__ListingProductDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ListingProductDetails);
	if (soap_out_PointerToPointerTons1__ListingProductDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ListingProductDetails(struct soap *soap, const char *tag, int id, ns1__ListingProductDetails **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ListingProductDetails);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ListingProductDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ListingProductDetails *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ListingProductDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ListingProductDetails *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ListingProductDetails(struct soap *soap, const char *tag, ns1__ListingProductDetails ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListingProductDetails ***)soap_malloc(soap, sizeof(ns1__ListingProductDetails **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ListingProductDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ListingProductDetails ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ListingProductDetails, sizeof(ns1__ListingProductDetails *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListingProductDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListingProductDetails);
	if (soap_out_PointerTons1__ListingProductDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListingProductDetails(struct soap *soap, const char *tag, int id, ns1__ListingProductDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListingProductDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListingProductDetails ** SOAP_FMAC4 soap_get_PointerTons1__ListingProductDetails(struct soap *soap, ns1__ListingProductDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListingProductDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ListingProductDetails ** SOAP_FMAC4 soap_in_PointerTons1__ListingProductDetails(struct soap *soap, const char *tag, ns1__ListingProductDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListingProductDetails **)soap_malloc(soap, sizeof(ns1__ListingProductDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListingProductDetails *)soap_instantiate_ns1__ListingProductDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListingProductDetails ** p = (ns1__ListingProductDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListingProductDetails, sizeof(ns1__ListingProductDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SellerSearchDetails))
		soap_serialize_PointerTons1__SellerSearchDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SellerSearchDetails);
	if (soap_out_PointerToPointerTons1__SellerSearchDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SellerSearchDetails(struct soap *soap, const char *tag, int id, ns1__SellerSearchDetails **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SellerSearchDetails);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SellerSearchDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SellerSearchDetails *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SellerSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerSearchDetails *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SellerSearchDetails(struct soap *soap, const char *tag, ns1__SellerSearchDetails ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerSearchDetails ***)soap_malloc(soap, sizeof(ns1__SellerSearchDetails **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SellerSearchDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SellerSearchDetails ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SellerSearchDetails, sizeof(ns1__SellerSearchDetails *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellerSearchDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellerSearchDetails);
	if (soap_out_PointerTons1__SellerSearchDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellerSearchDetails(struct soap *soap, const char *tag, int id, ns1__SellerSearchDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellerSearchDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellerSearchDetails ** SOAP_FMAC4 soap_get_PointerTons1__SellerSearchDetails(struct soap *soap, ns1__SellerSearchDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellerSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerSearchDetails ** SOAP_FMAC4 soap_in_PointerTons1__SellerSearchDetails(struct soap *soap, const char *tag, ns1__SellerSearchDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerSearchDetails **)soap_malloc(soap, sizeof(ns1__SellerSearchDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellerSearchDetails *)soap_instantiate_ns1__SellerSearchDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellerSearchDetails ** p = (ns1__SellerSearchDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellerSearchDetails, sizeof(ns1__SellerSearchDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SellerProfileDetails))
		soap_serialize_PointerTons1__SellerProfileDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SellerProfileDetails);
	if (soap_out_PointerToPointerTons1__SellerProfileDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SellerProfileDetails(struct soap *soap, const char *tag, int id, ns1__SellerProfileDetails **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SellerProfileDetails);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SellerProfileDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SellerProfileDetails *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SellerProfileDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerProfileDetails *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SellerProfileDetails(struct soap *soap, const char *tag, ns1__SellerProfileDetails ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerProfileDetails ***)soap_malloc(soap, sizeof(ns1__SellerProfileDetails **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SellerProfileDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SellerProfileDetails ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SellerProfileDetails, sizeof(ns1__SellerProfileDetails *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellerProfileDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellerProfileDetails);
	if (soap_out_PointerTons1__SellerProfileDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellerProfileDetails(struct soap *soap, const char *tag, int id, ns1__SellerProfileDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellerProfileDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellerProfileDetails ** SOAP_FMAC4 soap_get_PointerTons1__SellerProfileDetails(struct soap *soap, ns1__SellerProfileDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellerProfileDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerProfileDetails ** SOAP_FMAC4 soap_in_PointerTons1__SellerProfileDetails(struct soap *soap, const char *tag, ns1__SellerProfileDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerProfileDetails **)soap_malloc(soap, sizeof(ns1__SellerProfileDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellerProfileDetails *)soap_instantiate_ns1__SellerProfileDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellerProfileDetails ** p = (ns1__SellerProfileDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellerProfileDetails, sizeof(ns1__SellerProfileDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MarketplaceSearchDetails))
		soap_serialize_PointerTons1__MarketplaceSearchDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MarketplaceSearchDetails);
	if (soap_out_PointerToPointerTons1__MarketplaceSearchDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MarketplaceSearchDetails(struct soap *soap, const char *tag, int id, ns1__MarketplaceSearchDetails **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MarketplaceSearchDetails);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MarketplaceSearchDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MarketplaceSearchDetails *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MarketplaceSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__MarketplaceSearchDetails *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MarketplaceSearchDetails(struct soap *soap, const char *tag, ns1__MarketplaceSearchDetails ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketplaceSearchDetails ***)soap_malloc(soap, sizeof(ns1__MarketplaceSearchDetails **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MarketplaceSearchDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MarketplaceSearchDetails ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MarketplaceSearchDetails, sizeof(ns1__MarketplaceSearchDetails *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MarketplaceSearchDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MarketplaceSearchDetails);
	if (soap_out_PointerTons1__MarketplaceSearchDetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MarketplaceSearchDetails(struct soap *soap, const char *tag, int id, ns1__MarketplaceSearchDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MarketplaceSearchDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MarketplaceSearchDetails ** SOAP_FMAC4 soap_get_PointerTons1__MarketplaceSearchDetails(struct soap *soap, ns1__MarketplaceSearchDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MarketplaceSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__MarketplaceSearchDetails ** SOAP_FMAC4 soap_in_PointerTons1__MarketplaceSearchDetails(struct soap *soap, const char *tag, ns1__MarketplaceSearchDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketplaceSearchDetails **)soap_malloc(soap, sizeof(ns1__MarketplaceSearchDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MarketplaceSearchDetails *)soap_instantiate_ns1__MarketplaceSearchDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MarketplaceSearchDetails ** p = (ns1__MarketplaceSearchDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MarketplaceSearchDetails, sizeof(ns1__MarketplaceSearchDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CustomerReview(struct soap *soap, ns1__CustomerReview **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CustomerReview))
		soap_serialize_PointerTons1__CustomerReview(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CustomerReview(struct soap *soap, ns1__CustomerReview **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CustomerReview);
	if (soap_out_PointerToPointerTons1__CustomerReview(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CustomerReview(struct soap *soap, const char *tag, int id, ns1__CustomerReview **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CustomerReview);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CustomerReview(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CustomerReview *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CustomerReview(struct soap *soap, ns1__CustomerReview ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CustomerReview(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CustomerReview *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CustomerReview(struct soap *soap, const char *tag, ns1__CustomerReview ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CustomerReview ***)soap_malloc(soap, sizeof(ns1__CustomerReview **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CustomerReview(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CustomerReview ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CustomerReview, sizeof(ns1__CustomerReview *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CustomerReview(struct soap *soap, ns1__CustomerReview *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CustomerReview))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CustomerReview(struct soap *soap, ns1__CustomerReview *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CustomerReview);
	if (soap_out_PointerTons1__CustomerReview(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CustomerReview(struct soap *soap, const char *tag, int id, ns1__CustomerReview *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CustomerReview);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CustomerReview ** SOAP_FMAC4 soap_get_PointerTons1__CustomerReview(struct soap *soap, ns1__CustomerReview **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CustomerReview(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CustomerReview ** SOAP_FMAC4 soap_in_PointerTons1__CustomerReview(struct soap *soap, const char *tag, ns1__CustomerReview **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CustomerReview **)soap_malloc(soap, sizeof(ns1__CustomerReview *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CustomerReview *)soap_instantiate_ns1__CustomerReview(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CustomerReview ** p = (ns1__CustomerReview **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CustomerReview, sizeof(ns1__CustomerReview), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Track(struct soap *soap, ns1__Track **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Track))
		soap_serialize_PointerTons1__Track(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Track(struct soap *soap, ns1__Track **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Track);
	if (soap_out_PointerToPointerTons1__Track(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Track(struct soap *soap, const char *tag, int id, ns1__Track **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Track);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Track(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Track *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Track(struct soap *soap, ns1__Track ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Track(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Track *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Track(struct soap *soap, const char *tag, ns1__Track ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Track ***)soap_malloc(soap, sizeof(ns1__Track **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Track(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Track ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Track, sizeof(ns1__Track *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Track(struct soap *soap, ns1__Track *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Track))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Track(struct soap *soap, ns1__Track *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Track);
	if (soap_out_PointerTons1__Track(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Track(struct soap *soap, const char *tag, int id, ns1__Track *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Track);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Track ** SOAP_FMAC4 soap_get_PointerTons1__Track(struct soap *soap, ns1__Track **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Track(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Track ** SOAP_FMAC4 soap_in_PointerTons1__Track(struct soap *soap, const char *tag, ns1__Track **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Track **)soap_malloc(soap, sizeof(ns1__Track *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Track *)soap_instantiate_ns1__Track(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Track ** p = (ns1__Track **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Track, sizeof(ns1__Track), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__BrowseNode(struct soap *soap, ns1__BrowseNode **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__BrowseNode))
		soap_serialize_PointerTons1__BrowseNode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__BrowseNode(struct soap *soap, ns1__BrowseNode **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__BrowseNode);
	if (soap_out_PointerToPointerTons1__BrowseNode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__BrowseNode(struct soap *soap, const char *tag, int id, ns1__BrowseNode **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__BrowseNode);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__BrowseNode(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__BrowseNode *** SOAP_FMAC4 soap_get_PointerToPointerTons1__BrowseNode(struct soap *soap, ns1__BrowseNode ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__BrowseNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__BrowseNode *** SOAP_FMAC4 soap_in_PointerToPointerTons1__BrowseNode(struct soap *soap, const char *tag, ns1__BrowseNode ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BrowseNode ***)soap_malloc(soap, sizeof(ns1__BrowseNode **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__BrowseNode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__BrowseNode ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__BrowseNode, sizeof(ns1__BrowseNode *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BrowseNode(struct soap *soap, ns1__BrowseNode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BrowseNode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BrowseNode(struct soap *soap, ns1__BrowseNode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BrowseNode);
	if (soap_out_PointerTons1__BrowseNode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BrowseNode(struct soap *soap, const char *tag, int id, ns1__BrowseNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BrowseNode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BrowseNode ** SOAP_FMAC4 soap_get_PointerTons1__BrowseNode(struct soap *soap, ns1__BrowseNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BrowseNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__BrowseNode ** SOAP_FMAC4 soap_in_PointerTons1__BrowseNode(struct soap *soap, const char *tag, ns1__BrowseNode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BrowseNode **)soap_malloc(soap, sizeof(ns1__BrowseNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BrowseNode *)soap_instantiate_ns1__BrowseNode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__BrowseNode ** p = (ns1__BrowseNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BrowseNode, sizeof(ns1__BrowseNode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__KeyPhrase(struct soap *soap, ns1__KeyPhrase **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__KeyPhrase))
		soap_serialize_PointerTons1__KeyPhrase(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__KeyPhrase(struct soap *soap, ns1__KeyPhrase **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__KeyPhrase);
	if (soap_out_PointerToPointerTons1__KeyPhrase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__KeyPhrase(struct soap *soap, const char *tag, int id, ns1__KeyPhrase **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__KeyPhrase);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__KeyPhrase(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__KeyPhrase *** SOAP_FMAC4 soap_get_PointerToPointerTons1__KeyPhrase(struct soap *soap, ns1__KeyPhrase ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__KeyPhrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__KeyPhrase *** SOAP_FMAC4 soap_in_PointerToPointerTons1__KeyPhrase(struct soap *soap, const char *tag, ns1__KeyPhrase ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__KeyPhrase ***)soap_malloc(soap, sizeof(ns1__KeyPhrase **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__KeyPhrase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__KeyPhrase ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__KeyPhrase, sizeof(ns1__KeyPhrase *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__KeyPhrase(struct soap *soap, ns1__KeyPhrase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__KeyPhrase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__KeyPhrase(struct soap *soap, ns1__KeyPhrase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__KeyPhrase);
	if (soap_out_PointerTons1__KeyPhrase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__KeyPhrase(struct soap *soap, const char *tag, int id, ns1__KeyPhrase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__KeyPhrase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__KeyPhrase ** SOAP_FMAC4 soap_get_PointerTons1__KeyPhrase(struct soap *soap, ns1__KeyPhrase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__KeyPhrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__KeyPhrase ** SOAP_FMAC4 soap_in_PointerTons1__KeyPhrase(struct soap *soap, const char *tag, ns1__KeyPhrase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__KeyPhrase **)soap_malloc(soap, sizeof(ns1__KeyPhrase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__KeyPhrase *)soap_instantiate_ns1__KeyPhrase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__KeyPhrase ** p = (ns1__KeyPhrase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__KeyPhrase, sizeof(ns1__KeyPhrase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Details(struct soap *soap, ns1__Details **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Details))
		soap_serialize_PointerTons1__Details(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Details(struct soap *soap, ns1__Details **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Details);
	if (soap_out_PointerToPointerTons1__Details(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Details(struct soap *soap, const char *tag, int id, ns1__Details **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Details);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Details(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Details *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Details(struct soap *soap, ns1__Details ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Details(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Details *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Details(struct soap *soap, const char *tag, ns1__Details ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Details ***)soap_malloc(soap, sizeof(ns1__Details **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Details(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Details ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Details, sizeof(ns1__Details *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Details(struct soap *soap, ns1__Details *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Details))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Details(struct soap *soap, ns1__Details *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Details);
	if (soap_out_PointerTons1__Details(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Details(struct soap *soap, const char *tag, int id, ns1__Details *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Details);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Details ** SOAP_FMAC4 soap_get_PointerTons1__Details(struct soap *soap, ns1__Details **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Details(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Details ** SOAP_FMAC4 soap_in_PointerTons1__Details(struct soap *soap, const char *tag, ns1__Details **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Details **)soap_malloc(soap, sizeof(ns1__Details *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Details *)soap_instantiate_ns1__Details(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Details ** p = (ns1__Details **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Details, sizeof(ns1__Details), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ProductLine(struct soap *soap, ns1__ProductLine **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ProductLine))
		soap_serialize_PointerTons1__ProductLine(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ProductLine(struct soap *soap, ns1__ProductLine **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ProductLine);
	if (soap_out_PointerToPointerTons1__ProductLine(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ProductLine(struct soap *soap, const char *tag, int id, ns1__ProductLine **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ProductLine);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ProductLine(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ProductLine *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ProductLine(struct soap *soap, ns1__ProductLine ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ProductLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ProductLine *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ProductLine(struct soap *soap, const char *tag, ns1__ProductLine ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ProductLine ***)soap_malloc(soap, sizeof(ns1__ProductLine **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ProductLine(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ProductLine ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ProductLine, sizeof(ns1__ProductLine *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProductLine(struct soap *soap, ns1__ProductLine *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProductLine))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProductLine(struct soap *soap, ns1__ProductLine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ProductLine);
	if (soap_out_PointerTons1__ProductLine(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProductLine(struct soap *soap, const char *tag, int id, ns1__ProductLine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProductLine);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ProductLine ** SOAP_FMAC4 soap_get_PointerTons1__ProductLine(struct soap *soap, ns1__ProductLine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProductLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ProductLine ** SOAP_FMAC4 soap_in_PointerTons1__ProductLine(struct soap *soap, const char *tag, ns1__ProductLine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ProductLine **)soap_malloc(soap, sizeof(ns1__ProductLine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ProductLine *)soap_instantiate_ns1__ProductLine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ProductLine ** p = (ns1__ProductLine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProductLine, sizeof(ns1__ProductLine), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToItemQuantityArray(struct soap *soap, ItemQuantityArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToItemQuantityArray(struct soap *soap, ItemQuantityArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToItemQuantityArray);
	if (soap_out_PointerToItemQuantityArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToItemQuantityArray(struct soap *soap, const char *tag, int id, ItemQuantityArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ItemQuantityArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ItemQuantityArray ** SOAP_FMAC4 soap_get_PointerToItemQuantityArray(struct soap *soap, ItemQuantityArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToItemQuantityArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ItemQuantityArray ** SOAP_FMAC4 soap_in_PointerToItemQuantityArray(struct soap *soap, const char *tag, ItemQuantityArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ItemQuantityArray **)soap_malloc(soap, sizeof(ItemQuantityArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ItemQuantityArray *)soap_instantiate_ItemQuantityArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ItemQuantityArray ** p = (ItemQuantityArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ItemQuantityArray, sizeof(ItemQuantityArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToItemIdArray(struct soap *soap, ItemIdArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToItemIdArray(struct soap *soap, ItemIdArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToItemIdArray);
	if (soap_out_PointerToItemIdArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToItemIdArray(struct soap *soap, const char *tag, int id, ItemIdArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ItemIdArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ItemIdArray ** SOAP_FMAC4 soap_get_PointerToItemIdArray(struct soap *soap, ItemIdArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToItemIdArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ItemIdArray ** SOAP_FMAC4 soap_in_PointerToItemIdArray(struct soap *soap, const char *tag, ItemIdArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ItemIdArray **)soap_malloc(soap, sizeof(ItemIdArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ItemIdArray *)soap_instantiate_ItemIdArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ItemIdArray ** p = (ItemIdArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ItemIdArray, sizeof(ItemIdArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToAddItemArray(struct soap *soap, AddItemArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToAddItemArray(struct soap *soap, AddItemArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToAddItemArray);
	if (soap_out_PointerToAddItemArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToAddItemArray(struct soap *soap, const char *tag, int id, AddItemArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_AddItemArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 AddItemArray ** SOAP_FMAC4 soap_get_PointerToAddItemArray(struct soap *soap, AddItemArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToAddItemArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 AddItemArray ** SOAP_FMAC4 soap_in_PointerToAddItemArray(struct soap *soap, const char *tag, AddItemArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (AddItemArray **)soap_malloc(soap, sizeof(AddItemArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (AddItemArray *)soap_instantiate_AddItemArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	AddItemArray ** p = (AddItemArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_AddItemArray, sizeof(AddItemArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToItemArray(struct soap *soap, ItemArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToItemArray(struct soap *soap, ItemArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToItemArray);
	if (soap_out_PointerToItemArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToItemArray(struct soap *soap, const char *tag, int id, ItemArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ItemArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ItemArray ** SOAP_FMAC4 soap_get_PointerToItemArray(struct soap *soap, ItemArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToItemArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ItemArray ** SOAP_FMAC4 soap_in_PointerToItemArray(struct soap *soap, const char *tag, ItemArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ItemArray **)soap_malloc(soap, sizeof(ItemArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ItemArray *)soap_instantiate_ItemArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ItemArray ** p = (ItemArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ItemArray, sizeof(ItemArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToThirdPartyProductDetailsArray(struct soap *soap, ThirdPartyProductDetailsArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToThirdPartyProductDetailsArray(struct soap *soap, ThirdPartyProductDetailsArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToThirdPartyProductDetailsArray);
	if (soap_out_PointerToThirdPartyProductDetailsArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToThirdPartyProductDetailsArray(struct soap *soap, const char *tag, int id, ThirdPartyProductDetailsArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ThirdPartyProductDetailsArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ThirdPartyProductDetailsArray ** SOAP_FMAC4 soap_get_PointerToThirdPartyProductDetailsArray(struct soap *soap, ThirdPartyProductDetailsArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToThirdPartyProductDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ThirdPartyProductDetailsArray ** SOAP_FMAC4 soap_in_PointerToThirdPartyProductDetailsArray(struct soap *soap, const char *tag, ThirdPartyProductDetailsArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ThirdPartyProductDetailsArray **)soap_malloc(soap, sizeof(ThirdPartyProductDetailsArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ThirdPartyProductDetailsArray *)soap_instantiate_ThirdPartyProductDetailsArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ThirdPartyProductDetailsArray ** p = (ThirdPartyProductDetailsArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ThirdPartyProductDetailsArray, sizeof(ThirdPartyProductDetailsArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToFeedbackArray(struct soap *soap, FeedbackArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToFeedbackArray(struct soap *soap, FeedbackArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToFeedbackArray);
	if (soap_out_PointerToFeedbackArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToFeedbackArray(struct soap *soap, const char *tag, int id, FeedbackArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_FeedbackArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 FeedbackArray ** SOAP_FMAC4 soap_get_PointerToFeedbackArray(struct soap *soap, FeedbackArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToFeedbackArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 FeedbackArray ** SOAP_FMAC4 soap_in_PointerToFeedbackArray(struct soap *soap, const char *tag, FeedbackArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (FeedbackArray **)soap_malloc(soap, sizeof(FeedbackArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (FeedbackArray *)soap_instantiate_FeedbackArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	FeedbackArray ** p = (FeedbackArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FeedbackArray, sizeof(FeedbackArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToListingProductDetailsArray(struct soap *soap, ListingProductDetailsArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToListingProductDetailsArray(struct soap *soap, ListingProductDetailsArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToListingProductDetailsArray);
	if (soap_out_PointerToListingProductDetailsArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToListingProductDetailsArray(struct soap *soap, const char *tag, int id, ListingProductDetailsArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ListingProductDetailsArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ListingProductDetailsArray ** SOAP_FMAC4 soap_get_PointerToListingProductDetailsArray(struct soap *soap, ListingProductDetailsArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToListingProductDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ListingProductDetailsArray ** SOAP_FMAC4 soap_in_PointerToListingProductDetailsArray(struct soap *soap, const char *tag, ListingProductDetailsArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ListingProductDetailsArray **)soap_malloc(soap, sizeof(ListingProductDetailsArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ListingProductDetailsArray *)soap_instantiate_ListingProductDetailsArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ListingProductDetailsArray ** p = (ListingProductDetailsArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ListingProductDetailsArray, sizeof(ListingProductDetailsArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellerFeedback(struct soap *soap, ns1__SellerFeedback *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellerFeedback))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellerFeedback(struct soap *soap, ns1__SellerFeedback *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellerFeedback);
	if (soap_out_PointerTons1__SellerFeedback(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellerFeedback(struct soap *soap, const char *tag, int id, ns1__SellerFeedback *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellerFeedback);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellerFeedback ** SOAP_FMAC4 soap_get_PointerTons1__SellerFeedback(struct soap *soap, ns1__SellerFeedback **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellerFeedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SellerFeedback ** SOAP_FMAC4 soap_in_PointerTons1__SellerFeedback(struct soap *soap, const char *tag, ns1__SellerFeedback **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellerFeedback **)soap_malloc(soap, sizeof(ns1__SellerFeedback *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellerFeedback *)soap_instantiate_ns1__SellerFeedback(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellerFeedback ** p = (ns1__SellerFeedback **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellerFeedback, sizeof(ns1__SellerFeedback), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListingProductInfo(struct soap *soap, ns1__ListingProductInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListingProductInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListingProductInfo(struct soap *soap, ns1__ListingProductInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListingProductInfo);
	if (soap_out_PointerTons1__ListingProductInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListingProductInfo(struct soap *soap, const char *tag, int id, ns1__ListingProductInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListingProductInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListingProductInfo ** SOAP_FMAC4 soap_get_PointerTons1__ListingProductInfo(struct soap *soap, ns1__ListingProductInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListingProductInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ListingProductInfo ** SOAP_FMAC4 soap_in_PointerTons1__ListingProductInfo(struct soap *soap, const char *tag, ns1__ListingProductInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListingProductInfo **)soap_malloc(soap, sizeof(ns1__ListingProductInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListingProductInfo *)soap_instantiate_ns1__ListingProductInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListingProductInfo ** p = (ns1__ListingProductInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListingProductInfo, sizeof(ns1__ListingProductInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSellerSearchDetailsArray(struct soap *soap, SellerSearchDetailsArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSellerSearchDetailsArray(struct soap *soap, SellerSearchDetailsArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSellerSearchDetailsArray);
	if (soap_out_PointerToSellerSearchDetailsArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSellerSearchDetailsArray(struct soap *soap, const char *tag, int id, SellerSearchDetailsArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_SellerSearchDetailsArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 SellerSearchDetailsArray ** SOAP_FMAC4 soap_get_PointerToSellerSearchDetailsArray(struct soap *soap, SellerSearchDetailsArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSellerSearchDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 SellerSearchDetailsArray ** SOAP_FMAC4 soap_in_PointerToSellerSearchDetailsArray(struct soap *soap, const char *tag, SellerSearchDetailsArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (SellerSearchDetailsArray **)soap_malloc(soap, sizeof(SellerSearchDetailsArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (SellerSearchDetailsArray *)soap_instantiate_SellerSearchDetailsArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	SellerSearchDetailsArray ** p = (SellerSearchDetailsArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SellerSearchDetailsArray, sizeof(SellerSearchDetailsArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSellerProfileDetailsArray(struct soap *soap, SellerProfileDetailsArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSellerProfileDetailsArray(struct soap *soap, SellerProfileDetailsArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSellerProfileDetailsArray);
	if (soap_out_PointerToSellerProfileDetailsArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSellerProfileDetailsArray(struct soap *soap, const char *tag, int id, SellerProfileDetailsArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_SellerProfileDetailsArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 SellerProfileDetailsArray ** SOAP_FMAC4 soap_get_PointerToSellerProfileDetailsArray(struct soap *soap, SellerProfileDetailsArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSellerProfileDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 SellerProfileDetailsArray ** SOAP_FMAC4 soap_in_PointerToSellerProfileDetailsArray(struct soap *soap, const char *tag, SellerProfileDetailsArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (SellerProfileDetailsArray **)soap_malloc(soap, sizeof(SellerProfileDetailsArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (SellerProfileDetailsArray *)soap_instantiate_SellerProfileDetailsArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	SellerProfileDetailsArray ** p = (SellerProfileDetailsArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SellerProfileDetailsArray, sizeof(SellerProfileDetailsArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMarketplaceSearchDetailsArray(struct soap *soap, MarketplaceSearchDetailsArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMarketplaceSearchDetailsArray(struct soap *soap, MarketplaceSearchDetailsArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMarketplaceSearchDetailsArray);
	if (soap_out_PointerToMarketplaceSearchDetailsArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMarketplaceSearchDetailsArray(struct soap *soap, const char *tag, int id, MarketplaceSearchDetailsArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_MarketplaceSearchDetailsArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MarketplaceSearchDetailsArray ** SOAP_FMAC4 soap_get_PointerToMarketplaceSearchDetailsArray(struct soap *soap, MarketplaceSearchDetailsArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMarketplaceSearchDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MarketplaceSearchDetailsArray ** SOAP_FMAC4 soap_in_PointerToMarketplaceSearchDetailsArray(struct soap *soap, const char *tag, MarketplaceSearchDetailsArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MarketplaceSearchDetailsArray **)soap_malloc(soap, sizeof(MarketplaceSearchDetailsArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MarketplaceSearchDetailsArray *)soap_instantiate_MarketplaceSearchDetailsArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MarketplaceSearchDetailsArray ** p = (MarketplaceSearchDetailsArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MarketplaceSearchDetailsArray, sizeof(MarketplaceSearchDetailsArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCustomerReviewArray(struct soap *soap, CustomerReviewArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCustomerReviewArray(struct soap *soap, CustomerReviewArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCustomerReviewArray);
	if (soap_out_PointerToCustomerReviewArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCustomerReviewArray(struct soap *soap, const char *tag, int id, CustomerReviewArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_CustomerReviewArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CustomerReviewArray ** SOAP_FMAC4 soap_get_PointerToCustomerReviewArray(struct soap *soap, CustomerReviewArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCustomerReviewArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CustomerReviewArray ** SOAP_FMAC4 soap_in_PointerToCustomerReviewArray(struct soap *soap, const char *tag, CustomerReviewArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CustomerReviewArray **)soap_malloc(soap, sizeof(CustomerReviewArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CustomerReviewArray *)soap_instantiate_CustomerReviewArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CustomerReviewArray ** p = (CustomerReviewArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CustomerReviewArray, sizeof(CustomerReviewArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToListArray(struct soap *soap, ListArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToListArray(struct soap *soap, ListArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToListArray);
	if (soap_out_PointerToListArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToListArray(struct soap *soap, const char *tag, int id, ListArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ListArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ListArray ** SOAP_FMAC4 soap_get_PointerToListArray(struct soap *soap, ListArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToListArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ListArray ** SOAP_FMAC4 soap_in_PointerToListArray(struct soap *soap, const char *tag, ListArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ListArray **)soap_malloc(soap, sizeof(ListArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ListArray *)soap_instantiate_ListArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ListArray ** p = (ListArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ListArray, sizeof(ListArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSimilarProductsArray(struct soap *soap, SimilarProductsArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSimilarProductsArray(struct soap *soap, SimilarProductsArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSimilarProductsArray);
	if (soap_out_PointerToSimilarProductsArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSimilarProductsArray(struct soap *soap, const char *tag, int id, SimilarProductsArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_SimilarProductsArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 SimilarProductsArray ** SOAP_FMAC4 soap_get_PointerToSimilarProductsArray(struct soap *soap, SimilarProductsArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSimilarProductsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 SimilarProductsArray ** SOAP_FMAC4 soap_in_PointerToSimilarProductsArray(struct soap *soap, const char *tag, SimilarProductsArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (SimilarProductsArray **)soap_malloc(soap, sizeof(SimilarProductsArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (SimilarProductsArray *)soap_instantiate_SimilarProductsArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	SimilarProductsArray ** p = (SimilarProductsArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SimilarProductsArray, sizeof(SimilarProductsArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Reviews(struct soap *soap, ns1__Reviews *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Reviews))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Reviews(struct soap *soap, ns1__Reviews *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Reviews);
	if (soap_out_PointerTons1__Reviews(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Reviews(struct soap *soap, const char *tag, int id, ns1__Reviews *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Reviews);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Reviews ** SOAP_FMAC4 soap_get_PointerTons1__Reviews(struct soap *soap, ns1__Reviews **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Reviews(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Reviews ** SOAP_FMAC4 soap_in_PointerTons1__Reviews(struct soap *soap, const char *tag, ns1__Reviews **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Reviews **)soap_malloc(soap, sizeof(ns1__Reviews *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Reviews *)soap_instantiate_ns1__Reviews(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Reviews ** p = (ns1__Reviews **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Reviews, sizeof(ns1__Reviews), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPlatformArray(struct soap *soap, PlatformArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPlatformArray(struct soap *soap, PlatformArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPlatformArray);
	if (soap_out_PointerToPlatformArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPlatformArray(struct soap *soap, const char *tag, int id, PlatformArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_PlatformArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 PlatformArray ** SOAP_FMAC4 soap_get_PointerToPlatformArray(struct soap *soap, PlatformArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPlatformArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 PlatformArray ** SOAP_FMAC4 soap_in_PointerToPlatformArray(struct soap *soap, const char *tag, PlatformArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (PlatformArray **)soap_malloc(soap, sizeof(PlatformArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (PlatformArray *)soap_instantiate_PlatformArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	PlatformArray ** p = (PlatformArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PlatformArray, sizeof(PlatformArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToAccessoryArray(struct soap *soap, AccessoryArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToAccessoryArray(struct soap *soap, AccessoryArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToAccessoryArray);
	if (soap_out_PointerToAccessoryArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToAccessoryArray(struct soap *soap, const char *tag, int id, AccessoryArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_AccessoryArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 AccessoryArray ** SOAP_FMAC4 soap_get_PointerToAccessoryArray(struct soap *soap, AccessoryArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToAccessoryArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 AccessoryArray ** SOAP_FMAC4 soap_in_PointerToAccessoryArray(struct soap *soap, const char *tag, AccessoryArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (AccessoryArray **)soap_malloc(soap, sizeof(AccessoryArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (AccessoryArray *)soap_instantiate_AccessoryArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	AccessoryArray ** p = (AccessoryArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_AccessoryArray, sizeof(AccessoryArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrackArray(struct soap *soap, TrackArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrackArray(struct soap *soap, TrackArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTrackArray);
	if (soap_out_PointerToTrackArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrackArray(struct soap *soap, const char *tag, int id, TrackArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_TrackArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TrackArray ** SOAP_FMAC4 soap_get_PointerToTrackArray(struct soap *soap, TrackArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrackArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TrackArray ** SOAP_FMAC4 soap_in_PointerToTrackArray(struct soap *soap, const char *tag, TrackArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrackArray **)soap_malloc(soap, sizeof(TrackArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrackArray *)soap_instantiate_TrackArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TrackArray ** p = (TrackArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrackArray, sizeof(TrackArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToFeaturesArray(struct soap *soap, FeaturesArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToFeaturesArray(struct soap *soap, FeaturesArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToFeaturesArray);
	if (soap_out_PointerToFeaturesArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToFeaturesArray(struct soap *soap, const char *tag, int id, FeaturesArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_FeaturesArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 FeaturesArray ** SOAP_FMAC4 soap_get_PointerToFeaturesArray(struct soap *soap, FeaturesArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToFeaturesArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 FeaturesArray ** SOAP_FMAC4 soap_in_PointerToFeaturesArray(struct soap *soap, const char *tag, FeaturesArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (FeaturesArray **)soap_malloc(soap, sizeof(FeaturesArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (FeaturesArray *)soap_instantiate_FeaturesArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	FeaturesArray ** p = (FeaturesArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FeaturesArray, sizeof(FeaturesArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToBrowseNodeArray(struct soap *soap, BrowseNodeArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToBrowseNodeArray(struct soap *soap, BrowseNodeArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToBrowseNodeArray);
	if (soap_out_PointerToBrowseNodeArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToBrowseNodeArray(struct soap *soap, const char *tag, int id, BrowseNodeArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_BrowseNodeArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 BrowseNodeArray ** SOAP_FMAC4 soap_get_PointerToBrowseNodeArray(struct soap *soap, BrowseNodeArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToBrowseNodeArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 BrowseNodeArray ** SOAP_FMAC4 soap_in_PointerToBrowseNodeArray(struct soap *soap, const char *tag, BrowseNodeArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (BrowseNodeArray **)soap_malloc(soap, sizeof(BrowseNodeArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (BrowseNodeArray *)soap_instantiate_BrowseNodeArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	BrowseNodeArray ** p = (BrowseNodeArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_BrowseNodeArray, sizeof(BrowseNodeArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ThirdPartyProductInfo(struct soap *soap, ns1__ThirdPartyProductInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ThirdPartyProductInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ThirdPartyProductInfo(struct soap *soap, ns1__ThirdPartyProductInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ThirdPartyProductInfo);
	if (soap_out_PointerTons1__ThirdPartyProductInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ThirdPartyProductInfo(struct soap *soap, const char *tag, int id, ns1__ThirdPartyProductInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ThirdPartyProductInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ThirdPartyProductInfo ** SOAP_FMAC4 soap_get_PointerTons1__ThirdPartyProductInfo(struct soap *soap, ns1__ThirdPartyProductInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ThirdPartyProductInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ThirdPartyProductInfo ** SOAP_FMAC4 soap_in_PointerTons1__ThirdPartyProductInfo(struct soap *soap, const char *tag, ns1__ThirdPartyProductInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ThirdPartyProductInfo **)soap_malloc(soap, sizeof(ns1__ThirdPartyProductInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ThirdPartyProductInfo *)soap_instantiate_ns1__ThirdPartyProductInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ThirdPartyProductInfo ** p = (ns1__ThirdPartyProductInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ThirdPartyProductInfo, sizeof(ns1__ThirdPartyProductInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDirectorArray(struct soap *soap, DirectorArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDirectorArray(struct soap *soap, DirectorArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDirectorArray);
	if (soap_out_PointerToDirectorArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDirectorArray(struct soap *soap, const char *tag, int id, DirectorArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_DirectorArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DirectorArray ** SOAP_FMAC4 soap_get_PointerToDirectorArray(struct soap *soap, DirectorArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDirectorArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 DirectorArray ** SOAP_FMAC4 soap_in_PointerToDirectorArray(struct soap *soap, const char *tag, DirectorArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (DirectorArray **)soap_malloc(soap, sizeof(DirectorArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DirectorArray *)soap_instantiate_DirectorArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	DirectorArray ** p = (DirectorArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DirectorArray, sizeof(DirectorArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToStarringArray(struct soap *soap, StarringArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToStarringArray(struct soap *soap, StarringArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToStarringArray);
	if (soap_out_PointerToStarringArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToStarringArray(struct soap *soap, const char *tag, int id, StarringArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_StarringArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 StarringArray ** SOAP_FMAC4 soap_get_PointerToStarringArray(struct soap *soap, StarringArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToStarringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 StarringArray ** SOAP_FMAC4 soap_in_PointerToStarringArray(struct soap *soap, const char *tag, StarringArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (StarringArray **)soap_malloc(soap, sizeof(StarringArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (StarringArray *)soap_instantiate_StarringArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	StarringArray ** p = (StarringArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_StarringArray, sizeof(StarringArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToAuthorArray(struct soap *soap, AuthorArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToAuthorArray(struct soap *soap, AuthorArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToAuthorArray);
	if (soap_out_PointerToAuthorArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToAuthorArray(struct soap *soap, const char *tag, int id, AuthorArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_AuthorArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 AuthorArray ** SOAP_FMAC4 soap_get_PointerToAuthorArray(struct soap *soap, AuthorArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToAuthorArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 AuthorArray ** SOAP_FMAC4 soap_in_PointerToAuthorArray(struct soap *soap, const char *tag, AuthorArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (AuthorArray **)soap_malloc(soap, sizeof(AuthorArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (AuthorArray *)soap_instantiate_AuthorArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	AuthorArray ** p = (AuthorArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_AuthorArray, sizeof(AuthorArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArtistArray(struct soap *soap, ArtistArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArtistArray(struct soap *soap, ArtistArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArtistArray);
	if (soap_out_PointerToArtistArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArtistArray(struct soap *soap, const char *tag, int id, ArtistArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArtistArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArtistArray ** SOAP_FMAC4 soap_get_PointerToArtistArray(struct soap *soap, ArtistArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArtistArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArtistArray ** SOAP_FMAC4 soap_in_PointerToArtistArray(struct soap *soap, const char *tag, ArtistArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArtistArray **)soap_malloc(soap, sizeof(ArtistArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArtistArray *)soap_instantiate_ArtistArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArtistArray ** p = (ArtistArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArtistArray, sizeof(ArtistArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToKeyPhraseArray(struct soap *soap, KeyPhraseArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToKeyPhraseArray(struct soap *soap, KeyPhraseArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToKeyPhraseArray);
	if (soap_out_PointerToKeyPhraseArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToKeyPhraseArray(struct soap *soap, const char *tag, int id, KeyPhraseArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_KeyPhraseArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 KeyPhraseArray ** SOAP_FMAC4 soap_get_PointerToKeyPhraseArray(struct soap *soap, KeyPhraseArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToKeyPhraseArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 KeyPhraseArray ** SOAP_FMAC4 soap_in_PointerToKeyPhraseArray(struct soap *soap, const char *tag, KeyPhraseArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (KeyPhraseArray **)soap_malloc(soap, sizeof(KeyPhraseArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (KeyPhraseArray *)soap_instantiate_KeyPhraseArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	KeyPhraseArray ** p = (KeyPhraseArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_KeyPhraseArray, sizeof(KeyPhraseArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDetailsArray(struct soap *soap, DetailsArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDetailsArray(struct soap *soap, DetailsArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDetailsArray);
	if (soap_out_PointerToDetailsArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDetailsArray(struct soap *soap, const char *tag, int id, DetailsArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_DetailsArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DetailsArray ** SOAP_FMAC4 soap_get_PointerToDetailsArray(struct soap *soap, DetailsArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDetailsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 DetailsArray ** SOAP_FMAC4 soap_in_PointerToDetailsArray(struct soap *soap, const char *tag, DetailsArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (DetailsArray **)soap_malloc(soap, sizeof(DetailsArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DetailsArray *)soap_instantiate_DetailsArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	DetailsArray ** p = (DetailsArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DetailsArray, sizeof(DetailsArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProductInfo(struct soap *soap, ns1__ProductInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProductInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProductInfo(struct soap *soap, ns1__ProductInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ProductInfo);
	if (soap_out_PointerTons1__ProductInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProductInfo(struct soap *soap, const char *tag, int id, ns1__ProductInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProductInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ProductInfo ** SOAP_FMAC4 soap_get_PointerTons1__ProductInfo(struct soap *soap, ns1__ProductInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProductInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ProductInfo ** SOAP_FMAC4 soap_in_PointerTons1__ProductInfo(struct soap *soap, const char *tag, ns1__ProductInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ProductInfo **)soap_malloc(soap, sizeof(ns1__ProductInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ProductInfo *)soap_instantiate_ns1__ProductInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ProductInfo ** p = (ns1__ProductInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProductInfo, sizeof(ns1__ProductInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */
